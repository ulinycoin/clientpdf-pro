
> app-spa@3.2.0 lint
> eslint . --format json

[{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/astro.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/build-vercel.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/LanguageSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/WelcomeScreen.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/common/FileUpload.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/common/PDFMultiPagePreview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/common/PDFPreview.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/common/ProgressBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/common/ToolLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/layout/Sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/layout/ToolGroupNav.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/smart/SmartCompressionPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/smart/SmartImageFilterPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/smart/SmartMergePanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/smart/SmartOrganizePanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/AddFormFieldsPDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Tool' is defined but never used.","line":11,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'HASH_TOOL_MAP' is defined but never used.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":23},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'formFields'. Either include it or remove the dependency array.","line":89,"column":6,"nodeType":"ArrayExpression","endLine":89,"endColumn":38,"suggestions":[{"desc":"Update the dependencies array to be: [currentPage, formFields]","fix":{"range":[3525,3557],"text":"[currentPage, formFields]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 't'. Either include it or remove the dependency array.","line":162,"column":6,"nodeType":"ArrayExpression","endLine":162,"endColumn":24,"suggestions":[{"desc":"Update the dependencies array to be: [file.file, formFields, t]","fix":{"range":[5845,5863],"text":"[file.file, formFields, t]"}}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback } from 'react';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { Button } from '@/components/ui/button';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport { Canvas } from './AddFormFieldsPDF/Canvas';\nimport { Toolbar } from './AddFormFieldsPDF/Toolbar';\nimport { FieldPanel } from './AddFormFieldsPDF/FieldPanel';\nimport { addFormFieldsToPDF } from '@/services/pdfService';\nimport type { UploadedFile } from '@/types/pdf';\nimport type { Tool } from '@/types';\nimport { HASH_TOOL_MAP } from '@/types';\nimport type { FormField } from '@/types/formFields';\nimport { CheckCircle2, Copy } from 'lucide-react';\n\nexport const AddFormFieldsPDF: React.FC = () => {\n  const { t } = useI18n();\n  const { sharedFile, clearSharedFile, setSharedFile } = useSharedFile();\n  const [file, setFile] = useState<UploadedFile | null>(null);\n  const [result, setResult] = useState<Blob | null>(null);\n  const [resultSaved, setResultSaved] = useState(false);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [, setProgress] = useState({ percent: 0, message: '' });\n\n  // Form fields state\n  const [formFields, setFormFields] = useState<FormField[]>([]);\n  const [selectedFieldId, setSelectedFieldId] = useState<string | null>(null);\n  const [currentPage, setCurrentPage] = useState(0);\n  const [totalPages, setTotalPages] = useState(0);\n  const [scale, setScale] = useState(1);\n\n  // Auto-load shared file\n  useEffect(() => {\n    if (sharedFile && !file) {\n      const sharedFileObj = new File([sharedFile.blob], sharedFile.name, { type: 'application/pdf' });\n      handleFilesSelected([sharedFileObj]);\n      clearSharedFile();\n    }\n  }, [sharedFile, file, clearSharedFile]);\n\n  // Auto-save result to sharedFile when processing is complete\n  useEffect(() => {\n    if (result && !isProcessing && !resultSaved) {\n      const fileName = file?.name.replace(/\\.pdf$/i, '_with_form.pdf') || 'with_form.pdf';\n      setSharedFile(result, fileName, 'add-form-fields-pdf');\n      setResultSaved(true);\n    }\n  }, [result, isProcessing, resultSaved, file?.name, setSharedFile]);\n\n  const handleFilesSelected = async (selectedFiles: File[]) => {\n    const selectedFile = selectedFiles[0];\n    if (!selectedFile) return;\n\n    const uploadedFile: UploadedFile = {\n      id: `${Date.now()}`,\n      file: selectedFile,\n      name: selectedFile.name,\n      size: selectedFile.size,\n      status: 'completed',\n    };\n\n    setFile(uploadedFile);\n    setResult(null);\n    setResultSaved(false);\n    setFormFields([]);\n    setSelectedFieldId(null);\n  };\n\n  // Get selected field\n  const selectedField = formFields.find(field => field.id === selectedFieldId) || null;\n\n  // Add new field\n  const handleAddField = useCallback((type: FormField['type']) => {\n    const newField: FormField = {\n      id: `field_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      type,\n      name: `${type}_field_${formFields.length + 1}`,\n      x: 100,\n      y: 100,\n      width: type === 'checkbox' || type === 'radio' ? 20 : 200,\n      height: type === 'multiline' ? 80 : 20,\n      page: currentPage,\n      ...(type === 'dropdown' && { options: ['Option 1', 'Option 2', 'Option 3'] }),\n      ...(type === 'radio' && { group: `radio_group_${formFields.filter(f => f.type === 'radio').length + 1}`, value: 'option1' }),\n    } as FormField;\n\n    setFormFields(prev => [...prev, newField]);\n    setSelectedFieldId(newField.id);\n  }, [currentPage, formFields.length]);\n\n  // Update field\n  const handleUpdateField = useCallback((fieldId: string, updates: Partial<FormField>) => {\n    setFormFields(prev => prev.map(field =>\n      field.id === fieldId ? { ...field, ...updates } as FormField : field\n    ));\n  }, []);\n\n  // Delete field\n  const handleDeleteField = useCallback((fieldId: string) => {\n    setFormFields(prev => prev.filter(field => field.id !== fieldId));\n    if (selectedFieldId === fieldId) {\n      setSelectedFieldId(null);\n    }\n  }, [selectedFieldId]);\n\n  // Handle Duplication (Clone selected field)\n  const handleDuplicateField = useCallback(() => {\n    if (!selectedFieldId) return;\n    const fieldToClone = formFields.find(f => f.id === selectedFieldId);\n    if (!fieldToClone) return;\n\n    const newField: FormField = {\n      ...fieldToClone,\n      id: `field_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      name: `${fieldToClone.name}_copy`,\n      x: fieldToClone.x + 20, // Offset slightly\n      y: fieldToClone.y + 20,\n    };\n\n    setFormFields(prev => [...prev, newField]);\n    setSelectedFieldId(newField.id);\n  }, [selectedFieldId, formFields]);\n\n  // Move field\n  const handleMoveField = useCallback((fieldId: string, x: number, y: number) => {\n    handleUpdateField(fieldId, { x, y });\n  }, [handleUpdateField]);\n\n  // Resize field\n  const handleResizeField = useCallback((fieldId: string, width: number, height: number) => {\n    handleUpdateField(fieldId, { width, height });\n  }, [handleUpdateField]);\n\n  // Handle save\n  const handleSave = useCallback(async () => {\n    if (!file?.file || formFields.length === 0) {\n      alert(t('addFormFields.alertNoFields'));\n      return;\n    }\n\n    setIsProcessing(true);\n\n    try {\n      const result = await addFormFieldsToPDF(file.file, {\n        fields: formFields,\n        onProgress: (percent, message) => {\n          setProgress({ percent, message });\n        },\n      });\n\n      if (result.success && result.data) {\n        setResult(result.data);\n      } else {\n        alert('Error: ' + (result.error?.message || 'Unknown error'));\n      }\n    } catch (error) {\n      console.error('Error saving PDF:', error);\n      alert('Error: ' + (error instanceof Error ? error.message : 'Unknown error'));\n    } finally {\n      setIsProcessing(false);\n    }\n  }, [file, formFields]);\n\n  const handleDownload = () => {\n    if (!result) return;\n\n    const url = URL.createObjectURL(result);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = file?.name.replace('.pdf', '_with_form.pdf') || 'document_with_form.pdf';\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n  };\n\n  const handleReset = () => {\n    setFile(null);\n    setResult(null);\n    setResultSaved(false);\n    setFormFields([]);\n    setSelectedFieldId(null);\n  };\n\n\n\n  const renderContent = () => {\n    if (!file) return null;\n\n    if (result) {\n      return (\n        <div className=\"space-y-6\">\n          <div className=\"bg-gradient-to-r from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20 border-2 border-green-200 dark:border-green-800 rounded-2xl p-8\">\n            <div className=\"text-center space-y-4\">\n              <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/50 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <CheckCircle2 className=\"w-10 h-10 text-green-600 dark:text-green-400\" />\n              </div>\n              <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white\">\n                {t('common.success')}\n              </h2>\n              <div className=\"text-gray-600 dark:text-gray-400 space-y-1\">\n                <p>{t('addFormFields.addedCount', { count: formFields.length })}</p>\n                <p>{t('addFormFields.newSize', { size: (result.size / 1024).toFixed(2) })}</p>\n              </div>\n            </div>\n          </div>\n          <div className=\"flex gap-3 justify-center\">\n            <Button onClick={handleDownload} size=\"lg\" className=\"bg-green-600 hover:bg-green-700 text-white shadow-lg hover:shadow-xl transition-all\">\n              {t('common.download')}\n            </Button>\n            <Button variant=\"outline\" onClick={handleReset} size=\"lg\">\n              {t('common.processAnother')}\n            </Button>\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"flex flex-col h-full space-y-4\">\n        {/* Toolbar */}\n        <div className=\"flex-shrink-0\">\n          <Toolbar\n            currentPage={currentPage}\n            totalPages={totalPages}\n            scale={scale}\n            onPageChange={setCurrentPage}\n            onScaleChange={setScale}\n            onSave={handleSave}\n            onAddField={handleAddField}\n            hideSave={true} // Hide save here as it's in actions\n          />\n        </div>\n\n        {/* Canvas Area */}\n        <div className=\"flex-1 overflow-hidden bg-gray-100 dark:bg-gray-800 rounded-xl relative border border-gray-200 dark:border-gray-700\">\n          <div className=\"absolute inset-0 overflow-auto flex items-center justify-center p-4\">\n            <Canvas\n              pdfFile={file?.file || null}\n              currentPage={currentPage}\n              formFields={formFields}\n              selectedFieldId={selectedFieldId}\n              scale={scale}\n              onFieldSelect={setSelectedFieldId}\n              onFieldMove={handleMoveField}\n              onFieldResize={handleResizeField}\n              onPageChange={setCurrentPage}\n              onTotalPagesChange={setTotalPages}\n            />\n          </div>\n        </div>\n\n        {/* Status Bar */}\n        <div className=\"text-xs text-center text-gray-500\">\n          {t('addFormFields.fields', { count: formFields.length })}\n          {selectedField && ` | ${selectedField.name} (${selectedField.type})`}\n        </div>\n      </div>\n    );\n  };\n\n  const renderSettings = () => {\n    if (!selectedField) {\n      return (\n        <div className=\"text-center text-gray-500 py-8\">\n          <p>{t('addFormFields.selectFieldToEdit')}</p>\n          <Button variant=\"outline\" size=\"sm\" className=\"mt-4\" onClick={() => handleAddField('text')}>\n            + Add New Field\n          </Button>\n        </div>\n      );\n    }\n    return (\n      <div className=\"space-y-4\">\n        <FieldPanel\n          selectedField={selectedField}\n          onFieldUpdate={handleUpdateField}\n          onFieldDelete={handleDeleteField}\n        />\n        <Button variant=\"outline\" className=\"w-full\" onClick={handleDuplicateField}>\n          <Copy className=\"w-4 h-4 mr-2\" /> Duplicate Field\n        </Button>\n      </div>\n    );\n  };\n\n  const renderActions = () => {\n    return (\n      <Button\n        onClick={handleSave}\n        disabled={isProcessing || !file || formFields.length === 0}\n        className=\"w-full py-6 text-lg rounded-xl font-bold shadow-lg hover:shadow-xl transition-all\"\n      >\n        {isProcessing ? t('common.processing') : t('common.save')}\n      </Button>\n    );\n  };\n\n  return (\n    <ToolLayout\n      title={t('tools.add-form-fields-pdf.name')}\n      description={t('tools.add-form-fields-pdf.description')}\n      hasFiles={!!file}\n      onUpload={handleFilesSelected}\n      isProcessing={isProcessing}\n      maxFiles={1}\n      uploadTitle={t('common.selectFile')}\n      uploadDescription={t('upload.singleFileAllowed')}\n      settings={!result ? renderSettings() : null}\n      actions={!result ? renderActions() : null}\n    >\n      {renderContent()}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/AddFormFieldsPDF/Canvas.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'currentPage', 'onPageChange', and 'onTotalPagesChange'. Either include them or remove the dependency array. If 'onTotalPagesChange' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":57,"column":6,"nodeType":"ArrayExpression","endLine":57,"endColumn":15,"suggestions":[{"desc":"Update the dependencies array to be: [currentPage, onPageChange, onTotalPagesChange, pdfFile]","fix":{"range":[1865,1874],"text":"[currentPage, onPageChange, onTotalPagesChange, pdfFile]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'rendering'. Either include it or remove the dependency array.","line":89,"column":6,"nodeType":"ArrayExpression","endLine":89,"endColumn":34,"suggestions":[{"desc":"Update the dependencies array to be: [pdfDoc, currentPage, scale, rendering]","fix":{"range":[2673,2701],"text":"[pdfDoc, currentPage, scale, rendering]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useRef, useState } from 'react';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport type { FormField } from '@/types/formFields';\n\ninterface CanvasProps {\n  pdfFile: File | null;\n  currentPage: number;\n  formFields: FormField[];\n  selectedFieldId: string | null;\n  scale: number;\n  onFieldSelect: (id: string | null) => void;\n  onFieldMove: (id: string, x: number, y: number) => void;\n  onFieldResize: (id: string, width: number, height: number) => void;\n  onPageChange: (page: number) => void;\n  onTotalPagesChange: (total: number) => void;\n}\n\nexport const Canvas: React.FC<CanvasProps> = ({\n  pdfFile,\n  currentPage,\n  formFields,\n  selectedFieldId,\n  scale,\n  onFieldSelect,\n  onFieldMove,\n  onFieldResize,\n  onPageChange,\n  onTotalPagesChange,\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [pdfDoc, setPdfDoc] = useState<pdfjsLib.PDFDocumentProxy | null>(null);\n  const [rendering, setRendering] = useState(false);\n  const [dragging, setDragging] = useState<{ fieldId: string; startX: number; startY: number; offsetX: number; offsetY: number } | null>(null);\n  const [resizing, setResizing] = useState<{ fieldId: string; startX: number; startY: number; startWidth: number; startHeight: number } | null>(null);\n\n  // Load PDF document\n  useEffect(() => {\n    if (!pdfFile) return;\n\n    const loadPdf = async () => {\n      try {\n        const arrayBuffer = await pdfFile.arrayBuffer();\n        const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });\n        const pdf = await loadingTask.promise;\n        setPdfDoc(pdf);\n        onTotalPagesChange(pdf.numPages);\n        if (currentPage >= pdf.numPages) {\n          onPageChange(0);\n        }\n      } catch (error) {\n        console.error('Error loading PDF:', error);\n      }\n    };\n\n    loadPdf();\n  }, [pdfFile]);\n\n  // Render current page\n  useEffect(() => {\n    if (!pdfDoc || !canvasRef.current || rendering) return;\n\n    const renderPage = async () => {\n      setRendering(true);\n      try {\n        const page = await pdfDoc.getPage(currentPage + 1);\n        const viewport = page.getViewport({ scale });\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n\n        const context = canvas.getContext('2d');\n        if (!context) return;\n\n        canvas.width = viewport.width;\n        canvas.height = viewport.height;\n\n        await page.render({\n          canvasContext: context,\n          viewport,\n        }).promise;\n      } catch (error) {\n        console.error('Error rendering page:', error);\n      } finally {\n        setRendering(false);\n      }\n    };\n\n    renderPage();\n  }, [pdfDoc, currentPage, scale]);\n\n  // Handle mouse down on field\n  const handleFieldMouseDown = (e: React.MouseEvent, fieldId: string) => {\n    e.stopPropagation();\n    onFieldSelect(fieldId);\n\n    const field = formFields.find(f => f.id === fieldId);\n    if (!field) return;\n\n    const rect = canvasRef.current?.getBoundingClientRect();\n    if (!rect) return;\n\n    const x = (e.clientX - rect.left) / scale;\n    const y = (e.clientY - rect.top) / scale;\n\n    // Check if clicking on resize handle (bottom-right corner)\n    const isResizeHandle =\n      x >= field.x + field.width - 10 &&\n      x <= field.x + field.width &&\n      y >= field.y + field.height - 10 &&\n      y <= field.y + field.height;\n\n    if (isResizeHandle) {\n      setResizing({\n        fieldId,\n        startX: x,\n        startY: y,\n        startWidth: field.width,\n        startHeight: field.height,\n      });\n    } else {\n      setDragging({\n        fieldId,\n        startX: x,\n        startY: y,\n        offsetX: x - field.x,\n        offsetY: y - field.y,\n      });\n    }\n  };\n\n  // Handle mouse move\n  const handleMouseMove = (e: React.MouseEvent) => {\n    const rect = canvasRef.current?.getBoundingClientRect();\n    if (!rect) return;\n\n    const x = (e.clientX - rect.left) / scale;\n    const y = (e.clientY - rect.top) / scale;\n\n    if (dragging) {\n      const newX = Math.max(0, x - dragging.offsetX);\n      const newY = Math.max(0, y - dragging.offsetY);\n      onFieldMove(dragging.fieldId, newX, newY);\n    } else if (resizing) {\n      const deltaX = x - resizing.startX;\n      const deltaY = y - resizing.startY;\n      const newWidth = Math.max(20, resizing.startWidth + deltaX);\n      const newHeight = Math.max(15, resizing.startHeight + deltaY);\n      onFieldResize(resizing.fieldId, newWidth, newHeight);\n    }\n  };\n\n  // Handle mouse up\n  const handleMouseUp = () => {\n    setDragging(null);\n    setResizing(null);\n  };\n\n  // Handle canvas click (deselect)\n  const handleCanvasClick = (e: React.MouseEvent) => {\n    if (e.target === canvasRef.current) {\n      onFieldSelect(null);\n    }\n  };\n\n  // Get fields for current page\n  const currentPageFields = formFields.filter(field => field.page === currentPage);\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"relative w-full h-full overflow-auto bg-gray-100 dark:bg-gray-800 flex items-start justify-center p-8\"\n      onMouseMove={handleMouseMove}\n      onMouseUp={handleMouseUp}\n      onMouseLeave={handleMouseUp}\n    >\n      <div className=\"relative\" style={{ cursor: dragging || resizing ? 'move' : 'default' }}>\n        <canvas\n          ref={canvasRef}\n          className=\"shadow-lg\"\n          onClick={handleCanvasClick}\n        />\n        {/* Render form fields as overlays */}\n        {currentPageFields.map(field => (\n          <div\n            key={field.id}\n            className={`absolute border-2 ${\n              selectedFieldId === field.id\n                ? 'border-ocean-500 bg-ocean-100/30 dark:bg-ocean-500/20'\n                : 'border-gray-400 bg-gray-200/30 dark:bg-gray-600/20 hover:border-ocean-400'\n            } cursor-move`}\n            style={{\n              left: field.x * scale,\n              top: field.y * scale,\n              width: field.width * scale,\n              height: field.height * scale,\n            }}\n            onMouseDown={(e) => handleFieldMouseDown(e, field.id)}\n          >\n            {/* Field label */}\n            <div className=\"absolute -top-6 left-0 text-xs bg-gray-800 text-white px-2 py-1 rounded whitespace-nowrap\">\n              {field.name}\n            </div>\n\n            {/* Field type indicator */}\n            <div className=\"flex items-center justify-center h-full text-xs text-gray-600 dark:text-gray-300 font-mono\">\n              {field.type === 'text' && 'üìù Text'}\n              {field.type === 'multiline' && 'üìÑ Multiline'}\n              {field.type === 'checkbox' && '‚òëÔ∏è'}\n              {field.type === 'radio' && 'üîò'}\n              {field.type === 'dropdown' && '‚ñº'}\n            </div>\n\n            {/* Resize handle */}\n            {selectedFieldId === field.id && (\n              <div\n                className=\"absolute bottom-0 right-0 w-3 h-3 bg-ocean-500 cursor-se-resize\"\n                style={{ marginBottom: -1, marginRight: -1 }}\n              />\n            )}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/AddFormFieldsPDF/FieldPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/AddFormFieldsPDF/Toolbar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/AddTextPDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Tool' is defined but never used.","line":11,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'HASH_TOOL_MAP' is defined but never used.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":23},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleFilesSelected'. Either include it or remove the dependency array.","line":54,"column":6,"nodeType":"ArrayExpression","endLine":54,"endColumn":41,"suggestions":[{"desc":"Update the dependencies array to be: [sharedFile, file, clearSharedFile, handleFilesSelected]","fix":{"range":[1627,1662],"text":"[sharedFile, file, clearSharedFile, handleFilesSelected]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 't'. Either include it or remove the dependency array.","line":91,"column":6,"nodeType":"ArrayExpression","endLine":91,"endColumn":32,"suggestions":[{"desc":"Update the dependencies array to be: [toolMode, addTextElement, t]","fix":{"range":[2780,2806],"text":"[toolMode, addTextElement, t]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 't'. Either include it or remove the dependency array.","line":114,"column":6,"nodeType":"ArrayExpression","endLine":114,"endColumn":21,"suggestions":[{"desc":"Update the dependencies array to be: [file.file, savePDF, t]","fix":{"range":[3471,3486],"text":"[file.file, savePDF, t]"}}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback } from 'react';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { Button } from '@/components/ui/button';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport { useAddTextTool } from '@/hooks/useAddTextTool';\nimport { Canvas } from './AddTextPDF/Canvas';\nimport { Toolbar } from './AddTextPDF/Toolbar';\nimport { FormatPanel } from './AddTextPDF/FormatPanel';\nimport type { UploadedFile } from '@/types/pdf';\nimport type { Tool } from '@/types';\nimport { HASH_TOOL_MAP } from '@/types';\nimport { CheckCircle2 } from 'lucide-react';\n\nexport const AddTextPDF: React.FC = () => {\n  const { t } = useI18n();\n  const { sharedFile, clearSharedFile, setSharedFile } = useSharedFile();\n  const [file, setFile] = useState<UploadedFile | null>(null);\n  const [result, setResult] = useState<Blob | null>(null);\n  const [resultSaved, setResultSaved] = useState(false);\n\n  const {\n    textElements,\n    selectedElementId,\n    currentPage,\n    totalPages,\n    scale,\n    toolMode,\n    isProcessing,\n    canUndo,\n    canRedo,\n    addTextElement,\n    updateTextElement,\n    deleteTextElement,\n    selectElement,\n    moveElement,\n    goToPage,\n    setTotalPages,\n    setScale,\n    setToolMode,\n    undo,\n    redo,\n    savePDF,\n    reset,\n  } = useAddTextTool();\n\n  // Auto-load shared file\n  useEffect(() => {\n    if (sharedFile && !file) {\n      const sharedFileObj = new File([sharedFile.blob], sharedFile.name, { type: 'application/pdf' });\n      handleFilesSelected([sharedFileObj]);\n      clearSharedFile();\n    }\n  }, [sharedFile, file, clearSharedFile]);\n\n  // Auto-save result to sharedFile when processing is complete\n  useEffect(() => {\n    if (result && !isProcessing && !resultSaved) {\n      const fileName = file?.name.replace(/\\.pdf$/i, '_with_text.pdf') || 'with_text.pdf';\n      setSharedFile(result, fileName, 'add-text-pdf');\n      setResultSaved(true);\n    }\n  }, [result, isProcessing, resultSaved, file?.name, setSharedFile]);\n\n  const handleFilesSelected = async (selectedFiles: File[]) => {\n    const selectedFile = selectedFiles[0];\n    if (!selectedFile) return;\n\n    const uploadedFile: UploadedFile = {\n      id: `${Date.now()}`,\n      file: selectedFile,\n      name: selectedFile.name,\n      size: selectedFile.size,\n      status: 'completed',\n    };\n\n    setFile(uploadedFile);\n    setResult(null);\n    setResultSaved(false);\n    reset();\n  };\n\n  // Get selected element\n  const selectedElement = textElements.find(el => el.id === selectedElementId) || null;\n\n  // Handle canvas click\n  const handleCanvasClick = useCallback((x: number, y: number) => {\n    if (toolMode === 'add') {\n      addTextElement(x, y, t('addText.clickToEdit'));\n    }\n  }, [toolMode, addTextElement]);\n\n  // Handle element selection\n  const handleElementSelect = useCallback((id: string) => {\n    selectElement(id);\n  }, [selectElement]);\n\n  // Handle element movement\n  const handleElementMove = useCallback((id: string, x: number, y: number) => {\n    moveElement(id, x, y);\n  }, [moveElement]);\n\n  // Handle save\n  const handleSave = useCallback(async () => {\n    if (!file?.file) return;\n\n    try {\n      const resultBlob = await savePDF(file.file);\n      setResult(resultBlob);\n    } catch (error) {\n      console.error('Error saving PDF:', error);\n      alert(t('common.error') + ': ' + (error instanceof Error ? error.message : 'Unknown error'));\n    }\n  }, [file, savePDF]);\n\n  // Keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.target instanceof HTMLInputElement ||\n        event.target instanceof HTMLTextAreaElement) {\n        return;\n      }\n\n      if (event.ctrlKey || event.metaKey) {\n        switch (event.key) {\n          case 'z':\n            event.preventDefault();\n            if (event.shiftKey) {\n              redo();\n            } else {\n              undo();\n            }\n            break;\n          case 'y':\n            event.preventDefault();\n            redo();\n            break;\n          case 's':\n            event.preventDefault();\n            handleSave();\n            break;\n        }\n      }\n\n      if (event.key === 'Delete' || event.key === 'Backspace') {\n        if (selectedElementId) {\n          event.preventDefault();\n          deleteTextElement(selectedElementId);\n        }\n      }\n\n      if (event.key === 'Escape') {\n        selectElement('');\n        setToolMode('add');\n      }\n\n      if (event.ctrlKey || event.metaKey) {\n        switch (event.key) {\n          case '=':\n          case '+':\n            event.preventDefault();\n            setScale(scale + 0.25);\n            break;\n          case '-':\n            event.preventDefault();\n            setScale(scale - 0.25);\n            break;\n          case '0':\n            event.preventDefault();\n            setScale(1);\n            break;\n        }\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyDown);\n    return () => window.removeEventListener('keydown', handleKeyDown);\n  }, [undo, redo, handleSave, selectedElementId, deleteTextElement, selectElement, setToolMode, scale, setScale]);\n\n  const handleDownload = () => {\n    if (!result) return;\n\n    const url = URL.createObjectURL(result);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = file?.name.replace('.pdf', '_with_text.pdf') || t('addText.defaultFileName');\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n  };\n\n  const handleReset = () => {\n    setFile(null);\n    setResult(null);\n    setResultSaved(false);\n    reset();\n  };\n\n\n\n  const renderContent = () => {\n    if (!file) return null;\n\n    if (result) {\n      return (\n        <div className=\"space-y-6\">\n          <div className=\"bg-gradient-to-r from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20 border-2 border-green-200 dark:border-green-800 rounded-2xl p-8\">\n            <div className=\"text-center space-y-4\">\n              <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/50 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <CheckCircle2 className=\"w-10 h-10 text-green-600 dark:text-green-400\" />\n              </div>\n              <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white\">\n                {t('common.success')}\n              </h2>\n              <div className=\"text-gray-600 dark:text-gray-400 space-y-1\">\n                <p>{t('addText.addedCount', { count: textElements.length })}</p>\n                <p>{t('addText.newSize')}: <span className=\"font-semibold\">{(result.size / 1024).toFixed(2)} KB</span></p>\n              </div>\n            </div>\n          </div>\n          <div className=\"flex gap-3 justify-center\">\n            <Button onClick={handleDownload} size=\"lg\" className=\"bg-green-600 hover:bg-green-700 text-white shadow-lg hover:shadow-xl transition-all\">\n              {t('common.download')}\n            </Button>\n            <Button variant=\"outline\" onClick={handleReset} size=\"lg\">\n              {t('common.processAnother')}\n            </Button>\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"flex flex-col h-full space-y-4\">\n        {/* Toolbar - Pagination / Zoom / Undo / Redo */}\n        <div className=\"flex-shrink-0\">\n          <Toolbar\n            currentPage={currentPage}\n            totalPages={totalPages}\n            scale={scale}\n            canUndo={canUndo}\n            canRedo={canRedo}\n            toolMode={toolMode}\n            onPageChange={goToPage}\n            onScaleChange={setScale}\n            onUndo={undo}\n            onRedo={redo}\n            onToolModeChange={setToolMode}\n            onSave={handleSave}\n            // Hide save button in toolbar as it's in actions now\n            hideSave={true}\n          />\n        </div>\n\n        {/* Canvas area */}\n        <div className=\"flex-1 overflow-hidden bg-gray-100 dark:bg-gray-800 rounded-xl relative border border-gray-200 dark:border-gray-700\">\n          <div className=\"absolute inset-0 overflow-auto flex items-center justify-center p-4\">\n            <Canvas\n              pdfFile={file?.file || null}\n              currentPage={currentPage}\n              textElements={textElements}\n              selectedElementId={selectedElementId}\n              scale={scale}\n              onCanvasClick={handleCanvasClick}\n              onElementSelect={handleElementSelect}\n              onElementMove={handleElementMove}\n              onPageChange={goToPage}\n              onTotalPagesChange={setTotalPages}\n            />\n          </div>\n        </div>\n\n        {/* Status Bar */}\n        <div className=\"text-xs text-center text-gray-500\">\n          {toolMode === 'add' ? t('addText.modeAdd') : t('addText.modeSelect')}\n          {selectedElement && ` | ${t('addText.selected', { text: selectedElement.text.slice(0, 20) + (selectedElement.text.length > 20 ? '...' : '') })}`}\n        </div>\n      </div>\n    );\n  };\n\n  const renderSettings = () => {\n    return (\n      <FormatPanel\n        selectedElement={selectedElement}\n        onElementUpdate={updateTextElement}\n      />\n    );\n  };\n\n  const renderActions = () => {\n    return (\n      <Button\n        onClick={handleSave}\n        disabled={isProcessing || !file}\n        className=\"w-full py-6 text-lg rounded-xl font-bold shadow-lg hover:shadow-xl transition-all\"\n      >\n        {isProcessing ? t('common.processing') : t('common.save')}\n      </Button>\n    );\n  };\n\n  return (\n    <ToolLayout\n      title={t('tools.add-text-pdf.name')}\n      description={t('tools.add-text-pdf.description')}\n      hasFiles={!!file}\n      onUpload={handleFilesSelected}\n      isProcessing={isProcessing}\n      maxFiles={1}\n      uploadTitle={t('common.selectFile')}\n      uploadDescription={t('upload.singleFileAllowed')}\n      settings={!result ? renderSettings() : null}\n      actions={!result ? renderActions() : null}\n    >\n      {renderContent()}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/AddTextPDF/Canvas.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'renderPage'. Either include it or remove the dependency array.","line":82,"column":6,"nodeType":"ArrayExpression","endLine":82,"endColumn":39,"suggestions":[{"desc":"Update the dependencies array to be: [currentPage, onTotalPagesChange, renderPage]","fix":{"range":[2363,2396],"text":"[currentPage, onTotalPagesChange, renderPage]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'renderTextElements'. Either include it or remove the dependency array.","line":187,"column":6,"nodeType":"ArrayExpression","endLine":187,"endColumn":72,"suggestions":[{"desc":"Update the dependencies array to be: [scale, canvasState.scale, renderTextElements]","fix":{"range":[5191,5257],"text":"[scale, canvasState.scale, renderTextElements]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useRef, useEffect, useCallback, useState } from 'react';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport pdfjsWorker from 'pdfjs-dist/build/pdf.worker.min.mjs?url';\nimport type { TextElement } from '@/types/addText';\n\n// Set worker path\npdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorker;\n\ninterface CanvasState {\n  scale: number;\n  offsetX: number;\n  offsetY: number;\n  isDragging: boolean;\n  dragStartX: number;\n  dragStartY: number;\n}\n\ninterface CanvasProps {\n  pdfFile: File | null;\n  currentPage: number;\n  textElements: TextElement[];\n  selectedElementId: string | null;\n  scale: number;\n  onCanvasClick: (x: number, y: number) => void;\n  onElementSelect: (id: string) => void;\n  onElementMove: (id: string, x: number, y: number) => void;\n  onPageChange?: (page: number) => void;\n  onTotalPagesChange: (total: number) => void;\n}\n\nexport const Canvas: React.FC<CanvasProps> = ({\n  pdfFile,\n  currentPage,\n  textElements,\n  selectedElementId,\n  scale,\n  onCanvasClick,\n  onElementSelect,\n  onElementMove,\n  onTotalPagesChange\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const renderTaskRef = useRef<pdfjsLib.RenderTask | null>(null);\n  const isRenderingRef = useRef(false);\n\n  const [pdfDocument, setPdfDocument] = useState<pdfjsLib.PDFDocumentProxy | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [canvasState, setCanvasState] = useState<CanvasState>({\n    scale: 1,\n    offsetX: 0,\n    offsetY: 0,\n    isDragging: false,\n    dragStartX: 0,\n    dragStartY: 0\n  });\n  const [draggedElement, setDraggedElement] = useState<string | null>(null);\n\n  // Filter text elements for current page only\n  const currentPageElements = textElements.filter(el => el.pageNumber === currentPage);\n\n  // Load PDF document\n  const loadPDF = useCallback(async (file: File) => {\n    if (!file) return;\n\n    setIsLoading(true);\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\n\n      setPdfDocument(pdf);\n      onTotalPagesChange(pdf.numPages);\n\n      if (currentPage <= pdf.numPages) {\n        await renderPage(pdf, currentPage);\n      }\n    } catch (error: unknown) {\n      console.error('Error loading PDF:', error);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [currentPage, onTotalPagesChange]);\n\n  // Helper function to render multiline text\n  const renderMultilineText = useCallback((\n    context: CanvasRenderingContext2D,\n    text: string,\n    x: number,\n    y: number,\n    fontSize: number,\n    lineHeight?: number\n  ) => {\n    const lines = text.split('\\n');\n    const actualLineHeight = lineHeight || fontSize * 1.2;\n\n    lines.forEach((line, index) => {\n      const lineY = y + (index * actualLineHeight);\n      context.fillText(line, x, lineY);\n    });\n\n    return lines.length * actualLineHeight;\n  }, []);\n\n  // Get text bounds for multiline text\n  const getMultilineTextBounds = useCallback((\n    context: CanvasRenderingContext2D,\n    text: string,\n    fontSize: number,\n    lineHeight?: number\n  ) => {\n    const lines = text.split('\\n');\n    const actualLineHeight = lineHeight || fontSize * 1.2;\n\n    let maxWidth = 0;\n    lines.forEach(line => {\n      const metrics = context.measureText(line);\n      maxWidth = Math.max(maxWidth, metrics.width);\n    });\n\n    return {\n      width: maxWidth,\n      height: lines.length * actualLineHeight,\n      lineCount: lines.length\n    };\n  }, []);\n\n  // Render PDF page\n  const renderPage = useCallback(async (pdf: pdfjsLib.PDFDocumentProxy, pageNumber: number) => {\n\n    if (!pdf || !canvasRef.current) return;\n\n    // Cancel any existing render task\n    if (renderTaskRef.current) {\n      try {\n        await renderTaskRef.current.cancel();\n      } catch {\n        // Task might already be completed or cancelled\n      }\n      renderTaskRef.current = null;\n    }\n\n    // Wait for any ongoing rendering to complete\n    if (isRenderingRef.current) {\n      return;\n    }\n\n    isRenderingRef.current = true;\n\n    try {\n      const page = await pdf.getPage(pageNumber);\n      const canvas = canvasRef.current;\n      const context = canvas.getContext('2d');\n\n      if (!context) {\n        isRenderingRef.current = false;\n        return;\n      }\n\n      const viewport = page.getViewport({ scale: scale * canvasState.scale });\n\n      canvas.width = viewport.width;\n      canvas.height = viewport.height;\n      canvas.style.width = `${viewport.width}px`;\n      canvas.style.height = `${viewport.height}px`;\n\n      context.clearRect(0, 0, canvas.width, canvas.height);\n\n      const renderContext = {\n        canvasContext: context,\n        viewport: viewport\n      };\n\n      // @ts-expect-error - pdfjs types mismatch in v5\n      renderTaskRef.current = page.render(renderContext);\n      await renderTaskRef.current.promise;\n      renderTaskRef.current = null;\n\n      renderTextElements(context);\n\n    } catch (error: unknown) {\n      if (error instanceof Error && error.name !== 'RenderingCancelledException') {\n        console.error('Error rendering page:', error);\n      }\n    } finally {\n      isRenderingRef.current = false;\n    }\n  }, [scale, canvasState.scale, currentPageElements, selectedElementId]);\n\n  // Render text elements overlay\n  const renderTextElements = useCallback((context: CanvasRenderingContext2D) => {\n    currentPageElements.forEach(element => {\n      context.save();\n\n      context.font = `${element.fontSize * scale}px ${element.fontFamily}`;\n      context.fillStyle = element.color;\n      context.textBaseline = 'top';\n\n      const bounds = getMultilineTextBounds(\n        context,\n        element.text,\n        element.fontSize * scale\n      );\n\n      if (element.id === selectedElementId) {\n        context.strokeStyle = '#007bff';\n        context.lineWidth = 2;\n        context.setLineDash([5, 5]);\n\n        context.strokeRect(\n          element.x * scale - 2,\n          element.y * scale - 2,\n          bounds.width + 4,\n          bounds.height + 4\n        );\n      }\n\n      renderMultilineText(\n        context,\n        element.text,\n        element.x * scale,\n        element.y * scale,\n        element.fontSize * scale\n      );\n\n      context.restore();\n    });\n  }, [currentPageElements, selectedElementId, scale, renderMultilineText, getMultilineTextBounds]);\n\n  // Handle canvas click\n  const handleCanvasClick = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!canvasRef.current) return;\n\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = (event.clientX - rect.left) / scale;\n    const y = (event.clientY - rect.top) / scale;\n\n    const clickedElement = currentPageElements.find(element => {\n      const canvas2d = canvas.getContext('2d');\n      if (!canvas2d) return false;\n\n      canvas2d.font = `${element.fontSize * scale}px ${element.fontFamily}`;\n      const bounds = getMultilineTextBounds(\n        canvas2d,\n        element.text,\n        element.fontSize * scale\n      );\n\n      return (\n        x >= element.x &&\n        x <= element.x + (bounds.width / scale) &&\n        y >= element.y &&\n        y <= element.y + (bounds.height / scale)\n      );\n    });\n\n    if (clickedElement) {\n      onElementSelect(clickedElement.id);\n    } else {\n      onCanvasClick(x, y);\n    }\n  }, [currentPageElements, scale, onElementSelect, onCanvasClick, getMultilineTextBounds]);\n\n  // Handle mouse down for dragging\n  const handleMouseDown = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!canvasRef.current || !selectedElementId) return;\n\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = (event.clientX - rect.left) / scale;\n    const y = (event.clientY - rect.top) / scale;\n\n    const selectedElement = currentPageElements.find(el => el.id === selectedElementId);\n    if (selectedElement) {\n      setDraggedElement(selectedElementId);\n      setCanvasState(prev => ({\n        ...prev,\n        isDragging: true,\n        dragStartX: x - selectedElement.x,\n        dragStartY: y - selectedElement.y\n      }));\n    }\n  }, [selectedElementId, currentPageElements, scale]);\n\n  // Handle mouse move for dragging\n  const handleMouseMove = useCallback((event: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!canvasState.isDragging || !draggedElement || !canvasRef.current) return;\n\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const x = (event.clientX - rect.left) / scale;\n    const y = (event.clientY - rect.top) / scale;\n\n    const newX = x - canvasState.dragStartX;\n    const newY = y - canvasState.dragStartY;\n\n    onElementMove(draggedElement, Math.max(0, newX), Math.max(0, newY));\n  }, [canvasState.isDragging, canvasState.dragStartX, canvasState.dragStartY, draggedElement, scale, onElementMove]);\n\n  // Handle mouse up\n  const handleMouseUp = useCallback(() => {\n    setCanvasState(prev => ({ ...prev, isDragging: false }));\n    setDraggedElement(null);\n  }, []);\n\n  // Load PDF when file changes\n  useEffect(() => {\n    if (pdfFile) {\n      loadPDF(pdfFile);\n    }\n  }, [pdfFile, loadPDF]);\n\n  // Re-render when page or elements change\n  useEffect(() => {\n    if (!pdfDocument) return;\n\n    const timeoutId = setTimeout(() => {\n      renderPage(pdfDocument, currentPage);\n    }, 50);\n\n    return () => {\n      clearTimeout(timeoutId);\n    };\n  }, [pdfDocument, currentPage, currentPageElements, selectedElementId, scale, renderPage]);\n\n  // Cleanup render task on unmount\n  useEffect(() => {\n    return () => {\n      if (renderTaskRef.current) {\n        try {\n          renderTaskRef.current.cancel();\n        } catch {\n          // Task might already be completed\n        }\n        renderTaskRef.current = null;\n      }\n      isRenderingRef.current = false;\n    };\n  }, []);\n\n  return (\n    <div\n      ref={containerRef}\n      className=\"relative bg-gray-100 dark:bg-gray-900 rounded-lg overflow-auto h-full\"\n      style={{\n        width: '100%',\n        overflowX: 'auto',\n        overflowY: 'auto'\n      }}\n    >\n      {isLoading && (\n        <div className=\"absolute inset-0 flex items-center justify-center bg-white/75 dark:bg-gray-900/75 z-10\">\n          <div className=\"text-center\">\n            <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-ocean-500 mx-auto\"></div>\n            <p className=\"mt-2 text-gray-600 dark:text-gray-400\">Loading PDF...</p>\n          </div>\n        </div>\n      )}\n\n      <canvas\n        ref={canvasRef}\n        onClick={handleCanvasClick}\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n        onMouseLeave={handleMouseUp}\n        className=\"cursor-crosshair\"\n        style={{\n          display: 'block',\n          margin: '20px auto',\n          boxShadow: '0 4px 8px rgba(0,0,0,0.1)',\n          maxWidth: 'none'\n        }}\n      />\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/AddTextPDF/FormatPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/AddTextPDF/Toolbar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/CompressPDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1513,1516],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1513,1516],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { FileUpload } from '@/components/common/FileUpload';\nimport { ProgressBar } from '@/components/common/ProgressBar';\nimport { PDFPreview } from '@/components/common/PDFPreview';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport pdfService from '@/services/pdfService';\nimport type { UploadedFile } from '@/types/pdf';\nimport type { Tool } from '@/types';\nimport { HASH_TOOL_MAP } from '@/types';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { Minimize2, Shield, Stamp, Scissors } from 'lucide-react';\nimport { SmartCompressionPanel } from '@/components/smart/SmartCompressionPanel';\nimport type { CompressionAnalysis } from '@/types/pdf';\n\ntype CompressionQuality = 'low' | 'medium' | 'high';\n\nexport const CompressPDF: React.FC = () => {\n  const { t } = useI18n();\n  const { sharedFile, clearSharedFile, setSharedFile: saveSharedFile } = useSharedFile();\n  const [file, setFile] = useState<UploadedFile | null>(null);\n  const [quality, setQuality] = useState<CompressionQuality>('medium');\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [progressMessage, setProgressMessage] = useState('');\n  const [result, setResult] = useState<{ blob: Blob; metadata: any } | null>(null);\n  const [loadedFromShared, setLoadedFromShared] = useState(false);\n  const [resultSaved, setResultSaved] = useState(false);\n  const [analysis, setAnalysis] = useState<CompressionAnalysis | null>(null);\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n\n  // Auto-load file from shared state\n  useEffect(() => {\n    if (sharedFile && !file && !result) {\n      // Convert Blob to File\n      const sharedFileObj = new File([sharedFile.blob], sharedFile.name, {\n        type: 'application/pdf',\n      });\n\n      const uploadedFile: UploadedFile = {\n        id: `${Date.now()}`,\n        file: sharedFileObj,\n        name: sharedFile.name,\n        size: sharedFileObj.size,\n        status: 'pending',\n      };\n\n      setFile(uploadedFile);\n      setLoadedFromShared(true);\n\n      // Get PDF info\n      pdfService.getPDFInfo(sharedFileObj).then((info) => {\n        setFile((prev) => (prev ? { ...prev, info, status: 'completed' } : null));\n      }).catch(() => {\n        setFile((prev) =>\n          prev ? { ...prev, status: 'error', error: 'Failed to read PDF' } : null\n        );\n      });\n\n      // Analyze compression\n      setIsAnalyzing(true);\n      pdfService.analyzeCompression(sharedFileObj).then((res) => {\n        setAnalysis(res);\n        setQuality(res.recommendedQuality);\n      }).catch(err => console.error(err))\n        .finally(() => setIsAnalyzing(false));\n\n      // Clear shared file after loading\n\n      // Clear shared file after loading\n      clearSharedFile();\n    }\n  }, [sharedFile, file, result, clearSharedFile]);\n\n  // Auto-save result to sharedFile when processing is complete\n  useEffect(() => {\n    if (result?.blob && !isProcessing && !resultSaved) {\n      const fileName = file?.name.replace(/\\.pdf$/i, '_compressed.pdf') || 'compressed.pdf';\n      saveSharedFile(result.blob, fileName, 'compress-pdf');\n      setResultSaved(true);\n    }\n  }, [result, isProcessing, resultSaved, file?.name, saveSharedFile]);\n\n  const handleFileSelected = async (selectedFiles: File[]) => {\n    const selectedFile = selectedFiles[0];\n    if (!selectedFile) return;\n\n    const uploadedFile: UploadedFile = {\n      id: `${Date.now()}`,\n      file: selectedFile,\n      name: selectedFile.name,\n      size: selectedFile.size,\n      status: 'pending',\n    };\n\n    setFile(uploadedFile);\n\n    // Get PDF info\n    try {\n      const info = await pdfService.getPDFInfo(selectedFile);\n      setFile((prev) => (prev ? { ...prev, info, status: 'completed' } : null));\n\n      // Analyze compression\n      setIsAnalyzing(true);\n      const res = await pdfService.analyzeCompression(selectedFile);\n      setAnalysis(res);\n      setQuality(res.recommendedQuality);\n      setIsAnalyzing(false);\n    } catch {\n      setFile((prev) =>\n        prev ? { ...prev, status: 'error', error: 'Failed to read PDF' } : null\n      );\n      setIsAnalyzing(false);\n    }\n    setFile((prev) =>\n      prev ? { ...prev, status: 'error', error: 'Failed to read PDF' } : null\n    );\n  }\n\n\n  const handleCompress = async () => {\n    if (!file) return;\n\n    setIsProcessing(true);\n    setProgress(0);\n    setResult(null);\n    setResultSaved(false);\n\n    try {\n      const result = await pdfService.compressPDF(file.file, quality, (prog, msg) => {\n        setProgress(prog);\n        setProgressMessage(msg);\n      });\n\n      if (result.success && result.data) {\n        setResult({ blob: result.data, metadata: result.metadata });\n      } else {\n        alert(result.error?.message || 'Compression failed');\n      }\n    } catch (error) {\n      alert('An error occurred during compression');\n      console.error(error);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleDownload = () => {\n    if (result?.blob) {\n      const filename = file?.name.replace('.pdf', '_compressed.pdf') || 'compressed.pdf';\n      pdfService.downloadFile(result.blob, filename);\n    }\n  };\n\n  const handleReset = () => {\n    setFile(null);\n    setResult(null);\n    setResultSaved(false);\n    setProgress(0);\n    setProgressMessage('');\n    clearSharedFile();\n    setLoadedFromShared(false);\n    setAnalysis(null);\n  };\n\n  const handleQuickAction = (toolId: Tool) => {\n    // Save the compressed PDF to shared state for the next tool\n    if (result?.blob) {\n      const filename = file?.name.replace('.pdf', '_compressed.pdf') || 'compressed.pdf';\n      saveSharedFile(result.blob, filename, 'compress-pdf');\n    }\n    // Navigate to the selected tool\n    window.location.hash = HASH_TOOL_MAP[toolId];\n  };\n\n  // Quality presets\n  const qualityPresets: Array<{\n    id: CompressionQuality;\n    icon: string;\n    reduction: string;\n    description: string;\n  }> = [\n      {\n        id: 'low',\n        icon: 'üóúÔ∏è',\n        reduction: '~70%',\n        description: t('compress.quality.low.description'),\n      },\n      {\n        id: 'medium',\n        icon: '‚öñÔ∏è',\n        reduction: '~50%',\n        description: t('compress.quality.medium.description'),\n      },\n      {\n        id: 'high',\n        icon: '‚ú®',\n        reduction: '~30%',\n        description: t('compress.quality.high.description'),\n      },\n    ];\n\n  return (\n    <ToolLayout\n      title={t('tools.compress-pdf.name')}\n      description={t('tools.compress-pdf.description')}\n      hasFiles={!!file}\n      isProcessing={isProcessing}\n      onUpload={(files) => handleFileSelected(files)}\n      uploadContent={\n        <FileUpload\n          accept=\".pdf\"\n          multiple={false}\n          onFilesSelected={handleFileSelected}\n          maxSizeMB={100}\n          disabled={isProcessing}\n          title={t('common.selectFile')}\n          description={t('upload.singleFileAllowed')}\n        />\n      }\n      settings={\n        file && !result ? (\n          <div className=\"space-y-6 animate-slide-up\">\n\n            <SmartCompressionPanel\n              analysis={analysis}\n              isAnalyzing={isAnalyzing}\n              currentQuality={quality}\n              onApplyRecommendation={(q) => setQuality(q)}\n            />\n\n            <div className=\"space-y-4\">\n              <h3 className=\"font-semibold text-gray-900 dark:text-white flex items-center gap-2\">\n                <span className=\"text-xl\">‚öôÔ∏è</span> {t('compress.selectQuality')}\n              </h3>\n\n              <div className=\"space-y-3\">\n                {qualityPresets.map((preset) => (\n                  <div\n                    key={preset.id}\n                    onClick={() => setQuality(preset.id)}\n                    className={`cursor-pointer rounded-lg border-2 p-4 transition-all ${quality === preset.id\n                      ? 'border-ocean-500 bg-ocean-50 dark:bg-ocean-900/20'\n                      : 'border-gray-200 dark:border-gray-700 hover:border-ocean-200 dark:hover:border-ocean-800'\n                      }`}\n                  >\n                    <div className=\"flex items-start gap-3\">\n                      <span className=\"text-2xl\">{preset.icon}</span>\n                      <div className=\"flex-1\">\n                        <div className=\"flex items-center justify-between\">\n                          <span className={`font-medium ${quality === preset.id ? 'text-ocean-700 dark:text-ocean-300' : 'text-gray-900 dark:text-white'\n                            }`}>\n                            {t(`compress.quality.${preset.id}.name`)}\n                          </span>\n                          <Badge variant={quality === preset.id ? 'default' : 'secondary'} className=\"text-xs\">\n                            {preset.reduction}\n                          </Badge>\n                        </div>\n                        <p className=\"text-xs text-gray-500 dark:text-gray-400 mt-1\">\n                          {preset.description}\n                        </p>\n                      </div>\n                    </div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          </div>\n        ) : null\n      }\n      actions={\n        file && !result ? (\n          <Button\n            onClick={handleCompress}\n            disabled={isProcessing}\n            className=\"w-full text-lg py-6 shadow-lg shadow-ocean-500/20 bg-ocean-500 hover:bg-ocean-600 text-white\"\n            size=\"lg\"\n          >\n            {isProcessing ? t('common.processing') : t('compress.compressButton')}\n          </Button>\n        ) : result ? (\n          <div className=\"space-y-3\">\n            <Button\n              onClick={handleDownload}\n              className=\"w-full bg-green-600 hover:bg-green-700 text-white shadow-lg shadow-green-500/20\"\n              size=\"lg\"\n            >\n              {t('common.download')}\n            </Button>\n            <Button\n              onClick={handleReset}\n              variant=\"outline\"\n              className=\"w-full\"\n            >\n              {t('compress.compressAnother')}\n            </Button>\n          </div>\n        ) : null\n      }\n    >\n      {file && !result && (\n        <div className=\"space-y-6 animate-fade-in\">\n          {/* Auto-Loaded Banner */}\n          {loadedFromShared && (\n            <div className=\"bg-ocean-50 dark:bg-ocean-900/20 border border-ocean-200 dark:border-ocean-800 rounded-lg p-4 flex items-center justify-between\">\n              <div className=\"flex items-center gap-3\">\n                <span className=\"text-2xl\">‚ú®</span>\n                <div>\n                  <p className=\"font-medium text-ocean-700 dark:text-ocean-300\">\n                    {t('compress.autoLoaded.title')}\n                  </p>\n                  <p className=\"text-sm text-ocean-600 dark:text-ocean-400\">\n                    {t('compress.autoLoaded.description')}\n                  </p>\n                </div>\n              </div>\n            </div>\n          )}\n\n          <div className=\"flex justify-center\">\n            <div className=\"relative group\">\n              <div className=\"absolute -inset-1 bg-gradient-to-r from-ocean-500 to-purple-500 rounded-lg blur opacity-25 group-hover:opacity-50 transition duration-1000\"></div>\n              <div className=\"relative\">\n                <PDFPreview file={file.file} width={300} height={400} />\n              </div>\n            </div>\n          </div>\n\n          <div className=\"text-center\">\n            <h3 className=\"text-lg font-medium text-gray-900 dark:text-white\">\n              {file.name}\n            </h3>\n            <p className=\"text-gray-500 dark:text-gray-400\">\n              {pdfService.formatFileSize(file.size)} ‚Ä¢ {file.info?.pages} {t('common.pages')}\n            </p>\n          </div>\n        </div>\n      )}\n\n      {isProcessing && (\n        <div className=\"mt-8\">\n          <ProgressBar progress={progress} message={progressMessage} />\n        </div>\n      )}\n\n      {result && (\n        <div className=\"space-y-8 animate-scale-in\">\n          <Card className=\"bg-green-50/50 dark:bg-green-900/10 border-green-200 dark:border-green-800 backdrop-blur-sm overflow-hidden\">\n            <CardContent className=\"p-8\">\n              <div className=\"flex flex-col items-center text-center space-y-6\">\n                <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/50 rounded-full flex items-center justify-center animate-bounce-slow\">\n                  <span className=\"text-4xl\">üéâ</span>\n                </div>\n\n                <div className=\"space-y-2\">\n                  <h2 className=\"text-3xl font-bold text-gray-900 dark:text-white\">\n                    {t('compress.success.title')}\n                  </h2>\n                  <p className=\"text-center text-gray-500 dark:text-gray-400 max-w-md mx-auto\">\n                    {t('compress.success.saved')} <span className=\"text-green-600 font-bold\">{result.metadata?.compressionRatio}%</span>\n                  </p>\n                </div>\n\n                <div className=\"grid grid-cols-2 gap-8 w-full max-w-md\">\n                  <div className=\"p-4 rounded-xl bg-white dark:bg-gray-800 border border-gray-100 dark:border-gray-700 shadow-sm\">\n                    <p className=\"text-sm text-gray-500 dark:text-gray-400 mb-1\">{t('compress.originalSize')}</p>\n                    <p className=\"text-xl font-semibold text-gray-900 dark:text-white line-through opacity-50\">\n                      {pdfService.formatFileSize(result.metadata?.originalSize || 0)}\n                    </p>\n                  </div>\n                  <div className=\"p-4 rounded-xl bg-green-50 dark:bg-green-900/20 border border-green-100 dark:border-green-800 shadow-sm relative overflow-hidden\">\n                    <div className=\"absolute inset-0 bg-green-500/5 dark:bg-green-400/5 animate-pulse\"></div>\n                    <p className=\"text-sm text-green-600 dark:text-green-400 mb-1 font-medium\">{t('compress.success.compressedSize')}</p>\n                    <p className=\"text-2xl font-bold text-green-700 dark:text-green-300\">\n                      {pdfService.formatFileSize(result.metadata?.processedSize || 0)}\n                    </p>\n                  </div>\n                </div>\n              </div>\n            </CardContent>\n          </Card>\n\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n            <Button onClick={() => handleQuickAction('protect-pdf')} variant=\"outline\" className=\"h-auto py-4 flex flex-col gap-2 hover:border-ocean-400 hover:bg-ocean-50 dark:hover:bg-ocean-900/10 transition-all hover:-translate-y-1\">\n              <Shield className=\"h-6 w-6 text-ocean-500\" />\n              <span>{t('tools.protect-pdf.name')}</span>\n            </Button>\n            <Button onClick={() => handleQuickAction('merge-pdf')} variant=\"outline\" className=\"h-auto py-4 flex flex-col gap-2 hover:border-ocean-400 hover:bg-ocean-50 dark:hover:bg-ocean-900/10 transition-all hover:-translate-y-1\">\n              <Minimize2 className=\"h-6 w-6 text-ocean-500\" />\n              <span>{t('tools.merge-pdf.name')}</span>\n            </Button>\n            <Button onClick={() => handleQuickAction('split-pdf')} variant=\"outline\" className=\"h-auto py-4 flex flex-col gap-2 hover:border-ocean-400 hover:bg-ocean-50 dark:hover:bg-ocean-900/10 transition-all hover:-translate-y-1\">\n              <Scissors className=\"h-6 w-6 text-ocean-500\" />\n              <span>{t('tools.split-pdf.name')}</span>\n            </Button>\n            <Button onClick={() => handleQuickAction('watermark-pdf')} variant=\"outline\" className=\"h-auto py-4 flex flex-col gap-2 hover:border-ocean-400 hover:bg-ocean-50 dark:hover:bg-ocean-900/10 transition-all hover:-translate-y-1\">\n              <Stamp className=\"h-6 w-6 text-ocean-500\" />\n              <span>{t('tools.watermark-pdf.name')}</span>\n            </Button>\n          </div>\n        </div>\n      )}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/DeletePagesPDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Tool' is defined but never used.","line":9,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'HASH_TOOL_MAP' is defined but never used.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { ProgressBar } from '@/components/common/ProgressBar';\nimport { PDFPreview } from '@/components/common/PDFPreview';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport pdfService from '@/services/pdfService';\nimport type { UploadedFile } from '@/types/pdf';\nimport type { Tool } from '@/types';\nimport { HASH_TOOL_MAP } from '@/types';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Trash2, AlertTriangle, FileStack, CheckCircle2 } from 'lucide-react';\n\nexport const DeletePagesPDF: React.FC = () => {\n  const { t } = useI18n();\n  const { sharedFile, clearSharedFile, setSharedFile } = useSharedFile();\n  const [file, setFile] = useState<UploadedFile | null>(null);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [progressMessage, setProgressMessage] = useState('');\n  const [result, setResult] = useState<Blob | null>(null);\n  const [loadedFromShared, setLoadedFromShared] = useState(false);\n  const [resultSaved, setResultSaved] = useState(false);\n  const [pagesToDelete, setPagesToDelete] = useState('');\n\n  // Auto-load file from shared state\n  useEffect(() => {\n    if (sharedFile && !file && !result) {\n      const sharedFileObj = new File([sharedFile.blob], sharedFile.name, {\n        type: 'application/pdf',\n      });\n\n      const uploadedFile: UploadedFile = {\n        id: `${Date.now()}`,\n        file: sharedFileObj,\n        name: sharedFile.name,\n        size: sharedFileObj.size,\n        status: 'pending',\n      };\n\n      setFile(uploadedFile);\n      setLoadedFromShared(true);\n\n      pdfService.getPDFInfo(sharedFileObj).then((info) => {\n        setFile((prev) => (prev ? { ...prev, info, status: 'completed' } : null));\n      }).catch(() => {\n        setFile((prev) =>\n          prev ? { ...prev, status: 'error', error: 'Failed to read PDF' } : null\n        );\n      });\n\n      clearSharedFile();\n    }\n  }, [sharedFile, file, result, clearSharedFile]);\n\n  // Auto-save result to sharedFile when processing is complete\n  useEffect(() => {\n    if (result && !isProcessing && !resultSaved) {\n      const fileName = file?.name.replace(/\\.pdf$/i, '_deleted_pages.pdf') || 'deleted_pages.pdf';\n      setSharedFile(result, fileName, 'delete-pages-pdf');\n      setResultSaved(true);\n    }\n  }, [result, isProcessing, resultSaved, file?.name, setSharedFile]);\n\n  const handleFileSelected = async (selectedFiles: File[]) => {\n    const selectedFile = selectedFiles[0];\n    if (!selectedFile) return;\n\n    const uploadedFile: UploadedFile = {\n      id: `${Date.now()}`,\n      file: selectedFile,\n      name: selectedFile.name,\n      size: selectedFile.size,\n      status: 'pending',\n    };\n\n    setFile(uploadedFile);\n\n    try {\n      const info = await pdfService.getPDFInfo(selectedFile);\n      setFile((prev) => (prev ? { ...prev, info, status: 'completed' } : null));\n    } catch {\n      setFile((prev) =>\n        prev ? { ...prev, status: 'error', error: 'Failed to read PDF' } : null\n      );\n    }\n  };\n\n  const handleRemoveFile = () => {\n    setFile(null);\n    setResult(null);\n    setResultSaved(false);\n  };\n\n  const parsePageNumbers = (input: string, maxPages: number): number[] => {\n    const pages = new Set<number>();\n    const parts = input.split(',').map(p => p.trim());\n\n    for (const part of parts) {\n      if (part.includes('-')) {\n        const [start, end] = part.split('-').map(n => parseInt(n.trim()));\n        if (!isNaN(start) && !isNaN(end)) {\n          for (let i = Math.max(1, start); i <= Math.min(maxPages, end); i++) {\n            pages.add(i);\n          }\n        }\n      } else {\n        const pageNum = parseInt(part);\n        if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= maxPages) {\n          pages.add(pageNum);\n        }\n      }\n    }\n\n    return Array.from(pages).sort((a, b) => a - b);\n  };\n\n  const handleDelete = async () => {\n    if (!file) return;\n\n    const maxPages = file.info?.pages || 0;\n    const pageNumbersToDelete = parsePageNumbers(pagesToDelete, maxPages);\n\n    if (pageNumbersToDelete.length === 0) {\n      alert(t('deletePages.invalidPages'));\n      return;\n    }\n\n    if (pageNumbersToDelete.length >= maxPages) {\n      alert(t('deletePages.cannotDeleteAll'));\n      return;\n    }\n\n    setIsProcessing(true);\n    setProgress(0);\n    setResult(null);\n    setResultSaved(false);\n\n    try {\n      // Use delete functionality to remove pages\n      const deleteResult = await pdfService.deletePDF(\n        file.file,\n        pageNumbersToDelete,\n        (prog, msg) => {\n          setProgress(prog);\n          setProgressMessage(msg);\n        }\n      );\n\n      if (deleteResult.success && deleteResult.data) {\n        setResult(deleteResult.data);\n      } else {\n        alert(t('deletePages.failed'));\n      }\n    } catch (error) {\n      alert(t('deletePages.failed'));\n      console.error(error);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleDownload = () => {\n    if (!result || !file) return;\n    const filename = file.name.replace('.pdf', '_pages-deleted.pdf');\n    pdfService.downloadFile(result, filename);\n  };\n\n  const handleReset = () => {\n    setFile(null);\n    setResult(null);\n    setResultSaved(false);\n    setProgress(0);\n    setProgressMessage('');\n    setLoadedFromShared(false);\n    setPagesToDelete('');\n  };\n\n\n\n  const maxPages = file?.info?.pages || 1;\n\n  const renderContent = () => {\n    if (!file) return null;\n\n    if (result) {\n      return (\n        <div className=\"space-y-6\">\n          <div className=\"bg-gradient-to-r from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20 border-2 border-green-200 dark:border-green-800 rounded-2xl p-8\">\n            <div className=\"text-center space-y-4\">\n              <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/50 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <CheckCircle2 className=\"w-10 h-10 text-green-600 dark:text-green-400\" />\n              </div>\n              <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white\">\n                {t('deletePages.success')}\n              </h2>\n              <p className=\"text-gray-600 dark:text-gray-400\">\n                {t('deletePages.successDescription')}\n              </p>\n            </div>\n          </div>\n\n          <div className=\"flex gap-3 justify-center\">\n            <Button onClick={handleDownload} size=\"lg\" className=\"bg-green-600 hover:bg-green-700 text-white shadow-lg hover:shadow-xl transition-all\">\n              {t('common.download')}\n            </Button>\n            <Button onClick={handleReset} variant=\"outline\" size=\"lg\">\n              {t('deletePages.deleteAnother')}\n            </Button>\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"space-y-6\">\n        {/* Auto-loaded indicator */}\n        {loadedFromShared && (\n          <div className=\"bg-ocean-50 dark:bg-ocean-900/20 border border-ocean-200 dark:border-ocean-800 rounded-lg p-4 animate-in fade-in slide-in-from-top-2\">\n            <div className=\"flex items-center justify-between\">\n              <div className=\"flex items-center gap-3\">\n                <span className=\"text-2xl\">‚ú®</span>\n                <div>\n                  <p className=\"font-medium text-ocean-700 dark:text-ocean-300\">\n                    {t('common.autoLoaded')}\n                  </p>\n                  <p className=\"text-sm text-ocean-600 dark:text-ocean-400\">\n                    {t('common.autoLoadedDescription')}\n                  </p>\n                </div>\n              </div>\n              <Button\n                variant=\"ghost\"\n                onClick={handleRemoveFile}\n                className=\"text-ocean-600 dark:text-ocean-400 hover:text-ocean-800 dark:hover:text-ocean-200 font-semibold text-sm\"\n              >\n                ‚úï {t('common.close')}\n              </Button>\n            </div>\n          </div>\n        )}\n\n        {/* File Preview Card */}\n        <Card className=\"overflow-hidden border-ocean-100 dark:border-gray-700\">\n          <CardContent className=\"p-6\">\n            <div className=\"flex items-start gap-6\">\n              <div className=\"flex-shrink-0 relative group\">\n                <div className=\"absolute inset-0 bg-black/5 opacity-0 group-hover:opacity-100 transition-opacity rounded-lg\" />\n                <PDFPreview file={file.file} width={160} height={220} />\n              </div>\n              <div className=\"flex-1 space-y-4\">\n                <div>\n                  <h3 className=\"font-semibold text-lg text-gray-900 dark:text-white mb-1\">\n                    {file.name}\n                  </h3>\n                  <div className=\"flex flex-wrap gap-3 text-sm text-gray-500 dark:text-gray-400\">\n                    <span className=\"flex items-center gap-1\">\n                      <FileStack className=\"w-4 h-4\" />\n                      {file.info?.pages || 0} {t('common.pages')}\n                    </span>\n                    <span className=\"w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-600 self-center\" />\n                    <span>{pdfService.formatFileSize(file.size)}</span>\n                  </div>\n                </div>\n\n                <div className=\"flex items-center gap-2\">\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    onClick={handleRemoveFile}\n                    disabled={isProcessing}\n                    className=\"text-error-500 hover:text-error-600 hover:bg-error-50 dark:hover:bg-error-900/20\"\n                  >\n                    {t('common.changeFile')}\n                  </Button>\n                </div>\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n\n        {isProcessing && (\n          <div className=\"mt-8\">\n            <ProgressBar progress={progress} message={progressMessage} />\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  const renderSettings = () => {\n    return (\n      <div className=\"space-y-6\">\n        <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white flex items-center gap-2\">\n          <Trash2 className=\"w-5 h-5 text-red-500\" />\n          {t('deletePages.selectPages')}\n        </h3>\n\n        {/* Pages Input */}\n        <div className=\"space-y-4\">\n          <div className=\"bg-gray-50 dark:bg-gray-800/50 rounded-xl p-4\">\n            <Label className=\"text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2 block\">\n              {t('deletePages.pagesToDelete')}\n            </Label>\n            <Input\n              type=\"text\"\n              value={pagesToDelete}\n              onChange={(e) => setPagesToDelete(e.target.value)}\n              placeholder=\"e.g. 1, 3, 5-7\"\n              disabled={isProcessing}\n              className=\"bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700\"\n            />\n            <p className=\"text-xs text-gray-500 mt-2\">\n              {t('deletePages.hint', { total: String(maxPages) })}\n            </p>\n          </div>\n\n          {/* Warning */}\n          <div className=\"bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-xl p-4 flex gap-3\">\n            <AlertTriangle className=\"w-5 h-5 text-amber-600 dark:text-amber-500 flex-shrink-0\" />\n            <div className=\"text-sm\">\n              <p className=\"font-semibold text-amber-800 dark:text-amber-400 mb-1\">\n                {t('deletePages.warning')}\n              </p>\n              <p className=\"text-amber-700 dark:text-amber-300 text-xs\">\n                {t('deletePages.warningDescription')}\n              </p>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  const renderActions = () => {\n    return (\n      <Button\n        onClick={handleDelete}\n        disabled={isProcessing || !file || !pagesToDelete}\n        className=\"w-full py-6 text-lg rounded-xl font-bold shadow-lg hover:shadow-xl transition-all !bg-red-600 hover:!bg-red-700 text-white\"\n      >\n        {isProcessing ? t('common.processing') : (\n          <span className=\"flex items-center gap-2\">\n            <Trash2 className=\"w-5 h-5\" />\n            {t('deletePages.deleteButton')}\n          </span>\n        )}\n      </Button>\n    );\n  };\n\n  return (\n    <ToolLayout\n      title={t('tools.delete-pages-pdf.name')}\n      description={t('tools.delete-pages-pdf.description')}\n      hasFiles={!!file}\n      onUpload={handleFileSelected}\n      isProcessing={isProcessing}\n      maxFiles={1}\n      uploadTitle={t('common.selectFile')}\n      uploadDescription={t('upload.singleFileAllowed')}\n      settings={!result ? renderSettings() : null}\n      actions={!result ? renderActions() : null}\n    >\n      {renderContent()}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/EditTextPDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1030,1033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1030,1033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":27,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1171,1174],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1171,1174],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4326,4329],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4326,4329],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":123,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":123,"endColumn":17},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useCallback has an unnecessary dependency: 'editMode_type'. Either exclude it or remove the dependency array.","line":218,"column":6,"nodeType":"ArrayExpression","endLine":218,"endColumn":180,"suggestions":[{"desc":"Update the dependencies array to be: [selections, activeSelectionId, showPreview, backgroundColor, textColor, fontSize, fontFamily, textOffsetX, textOffsetY, textAlign, canvasScale, getFontString]","fix":{"range":[8977,9151],"text":"[selections, activeSelectionId, showPreview, backgroundColor, textColor, fontSize, fontFamily, textOffsetX, textOffsetY, textAlign, canvasScale, getFontString]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":243,"column":56,"nodeType":null,"messageId":"unusedVar","endLine":243,"endColumn":57},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":243,"column":59,"nodeType":"BlockStatement","messageId":"unexpected","endLine":243,"endColumn":62,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[10025,10026],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleFilesSelected'. Either include it or remove the dependency array.","line":247,"column":6,"nodeType":"ArrayExpression","endLine":247,"endColumn":58,"suggestions":[{"desc":"Update the dependencies array to be: [sharedFile, file, result, clearSharedFile, loadPDF, handleFilesSelected]","fix":{"range":[10087,10139],"text":"[sharedFile, file, result, clearSharedFile, loadPDF, handleFilesSelected]"}}]},{"ruleId":"prefer-const","severity":2,"message":"'updatedSelection' is never reassigned. Use 'const' instead.","line":347,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":347,"endColumn":27,"fix":{"range":[14118,14164],"text":"const updatedSelection = { ...activeSelection };"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":512,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":512,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20994,20997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20994,20997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":615,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":615,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25465,25468],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25465,25468],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect } from 'react';\nimport { ToolLayout } from '@/components/common/ToolLayout';\n\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport pdfService from '@/services/pdfService';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport type { UploadedFile, TextOccurrence } from '@/types/pdf';\n\nimport { Input } from '@/components/ui/input';\nimport { Button } from '@/components/ui/button';\nimport { Label } from '@/components/ui/label';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { CheckCircle2, Type, AlignLeft, AlignCenter, AlignRight, Bold, Italic } from 'lucide-react';\n\n// Configure PDF.js worker\n// Worker configured in pdfService.ts (globally)\n\nexport const EditTextPDF: React.FC = () => {\n  const { t } = useI18n();\n  const { sharedFile, clearSharedFile, setSharedFile } = useSharedFile();\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const renderTaskRef = useRef<any>(null);\n\n  // File state\n  const [file, setFile] = useState<UploadedFile | null>(null);\n  const [pdfDocument, setPdfDocument] = useState<any>(null);\n  const [totalPages, setTotalPages] = useState(0);\n  const [selectedPage, setSelectedPage] = useState(1);\n\n  // Selection state\n  const [selections, setSelections] = useState<TextOccurrence[]>([]);\n  const [activeSelectionId, setActiveSelectionId] = useState<string | null>(null);\n  const [isSelecting, setIsSelecting] = useState(false);\n  const [selectionStart, setSelectionStart] = useState<{ x: number; y: number } | null>(null);\n  const [isEditingSelection, setIsEditingSelection] = useState(false);\n  const [editMode, setEditMode] = useState<'move' | 'resize-nw' | 'resize-ne' | 'resize-sw' | 'resize-se' | null>(null);\n  const [editStart, setEditStart] = useState<{ x: number; y: number } | null>(null);\n\n  // Processing state\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [result, setResult] = useState<Blob | null>(null);\n  const [resultSaved, setResultSaved] = useState(false);\n\n  // UI state\n  // UI state\n  const [backgroundColor, setBackgroundColor] = useState('#ffffff');\n  const [textColor, setTextColor] = useState('#000000');\n  const [fontSize, setFontSize] = useState(12);\n  const [fontFamily, setFontFamily] = useState('Arial');\n  const [textOffsetX] = useState(0);\n  const [textOffsetY] = useState(0);\n  const [showPreview, setShowPreview] = useState(false);\n  const [isBold, setIsBold] = useState(false);\n  const [isItalic, setIsItalic] = useState(false);\n  const [textAlign, setTextAlign] = useState<'left' | 'center' | 'right'>('left');\n  const [editMode_type, setEditModeType] = useState<'replace' | 'cover'>('replace');\n  const [canvasScale] = useState(1.5);\n\n  // Helper function to build font string\n  const getFontString = React.useCallback((size: number, family: string) => {\n    const styles = [];\n    if (isItalic) styles.push('italic');\n    if (isBold) styles.push('bold');\n    return `${styles.join(' ')} ${size}px ${family}`.trim();\n  }, [isBold, isItalic]);\n\n  // Helper function to draw multiline text\n  const drawMultilineText = (\n    context: CanvasRenderingContext2D,\n    text: string,\n    x: number,\n    y: number,\n    maxWidth: number,\n    lineHeight: number,\n    alignment: 'left' | 'center' | 'right'\n  ) => {\n    const words = text.split(' ');\n    let line = '';\n    let currentY = y;\n    const lines: string[] = [];\n\n    for (let i = 0; i < words.length; i++) {\n      const testLine = line + words[i] + ' ';\n      const metrics = context.measureText(testLine);\n      const testWidth = metrics.width;\n      if (testWidth > maxWidth && i > 0) {\n        lines.push(line);\n        line = words[i] + ' ';\n      } else {\n        line = testLine;\n      }\n    }\n    lines.push(line);\n\n    for (let i = 0; i < lines.length; i++) {\n      let lineX = x;\n      const lineText = lines[i].trim();\n      const lineWidth = context.measureText(lineText).width;\n\n      if (alignment === 'center') {\n        lineX = x + (maxWidth - lineWidth) / 2;\n      } else if (alignment === 'right') {\n        lineX = x + maxWidth - lineWidth;\n      }\n\n      context.fillText(lineText, lineX, currentY);\n      currentY += lineHeight;\n    }\n  };\n\n  const renderPagePreview = React.useCallback(async (\n    pdf: any,\n    pageNumber: number,\n    tempSelection?: TextOccurrence | null,\n    currentMode: 'replace' | 'cover' | 'move' | null = null\n  ) => {\n    if (!pdf || !canvasRef.current) return;\n\n    if (renderTaskRef.current) {\n      try {\n        renderTaskRef.current.cancel();\n      } catch (e) { /* ignore */ }\n      renderTaskRef.current = null;\n    }\n\n    try {\n      const page = await pdf.getPage(pageNumber);\n      const viewport = page.getViewport({ scale: canvasScale });\n      const canvas = canvasRef.current;\n      const context = canvas.getContext('2d');\n      if (!context) return;\n\n      canvas.width = viewport.width;\n      canvas.height = viewport.height;\n\n      renderTaskRef.current = page.render({\n        canvasContext: context,\n        viewport: viewport,\n      });\n\n      await renderTaskRef.current.promise;\n      renderTaskRef.current = null;\n\n      const pageSelections = selections.filter(s => s.pageNumber === pageNumber);\n      const allSelections = tempSelection ? [...pageSelections, tempSelection] : pageSelections;\n\n      for (const sel of allSelections) {\n        const isActive = sel.id === activeSelectionId || (tempSelection && sel.id === tempSelection.id);\n\n        if (showPreview) {\n          context.fillStyle = backgroundColor;\n          context.fillRect(sel.x, sel.y, sel.width, sel.height);\n\n          if (sel.mode === 'replace' && sel.text) {\n            context.fillStyle = textColor;\n            const previewFontSize = fontSize * canvasScale;\n            context.font = getFontString(previewFontSize, fontFamily);\n            context.textBaseline = 'top';\n            const lineHeight = previewFontSize * 1.2;\n            const maxWidth = sel.width - (textOffsetX * canvasScale);\n\n            drawMultilineText(\n              context,\n              sel.text,\n              sel.x + (textOffsetX * canvasScale),\n              sel.y + (textOffsetY * canvasScale),\n              maxWidth,\n              lineHeight,\n              sel.textAlign || textAlign\n            );\n          }\n          context.strokeStyle = isActive ? 'rgba(0, 255, 0, 0.9)' : 'rgba(0, 200, 0, 0.5)';\n          context.lineWidth = isActive ? 3 : 2;\n          context.strokeRect(sel.x, sel.y, sel.width, sel.height);\n        } else {\n          // Selection mode\n          context.fillStyle = isActive ? 'rgba(255, 0, 0, 0.3)' : 'rgba(255, 100, 100, 0.2)';\n          context.fillRect(sel.x, sel.y, sel.width, sel.height);\n          context.strokeStyle = isActive ? 'rgba(255, 0, 0, 0.9)' : 'rgba(255, 100, 100, 0.6)';\n          context.lineWidth = isActive ? 3 : 2;\n          context.strokeRect(sel.x, sel.y, sel.width, sel.height);\n\n          if (currentMode === 'move' && isActive && tempSelection && tempSelection.id === sel.id && sel.originalX !== undefined) {\n            context.strokeStyle = 'rgba(0, 0, 255, 0.6)';\n            context.lineWidth = 2;\n            context.setLineDash([5, 5]);\n            context.strokeRect(sel.originalX, sel.originalY!, sel.originalWidth!, sel.originalHeight!);\n            context.setLineDash([]);\n          }\n\n          if (isActive) {\n            const handleSize = 10;\n            context.fillStyle = 'rgba(255, 255, 255, 0.9)';\n            context.strokeStyle = 'rgba(255, 0, 0, 1)';\n            context.lineWidth = 2;\n            // Corners\n            context.fillRect(sel.x - handleSize / 2, sel.y - handleSize / 2, handleSize, handleSize);\n            context.strokeRect(sel.x - handleSize / 2, sel.y - handleSize / 2, handleSize, handleSize);\n            context.fillRect(sel.x + sel.width - handleSize / 2, sel.y - handleSize / 2, handleSize, handleSize);\n            context.strokeRect(sel.x + sel.width - handleSize / 2, sel.y - handleSize / 2, handleSize, handleSize);\n            context.fillRect(sel.x - handleSize / 2, sel.y + sel.height - handleSize / 2, handleSize, handleSize);\n            context.strokeRect(sel.x - handleSize / 2, sel.y + sel.height - handleSize / 2, handleSize, handleSize);\n            context.fillRect(sel.x + sel.width - handleSize / 2, sel.y + sel.height - handleSize / 2, handleSize, handleSize);\n            context.strokeRect(sel.x + sel.width - handleSize / 2, sel.y + sel.height - handleSize / 2, handleSize, handleSize);\n          }\n          if (sel.mode === 'cover') {\n            context.fillStyle = 'rgba(255, 255, 255, 0.8)';\n            context.font = 'bold 12px Arial';\n            context.fillText('üé®', sel.x + 5, sel.y + 5);\n          }\n        }\n      }\n    } catch (error: unknown) {\n      if ((error as { name?: string })?.name === 'RenderingCancelledException') return;\n      console.error('Error rendering preview:', error);\n    }\n  }, [selections, activeSelectionId, showPreview, backgroundColor, textColor, fontSize, fontFamily, textOffsetX, textOffsetY, textAlign, canvasScale, getFontString, editMode_type]);\n\n  const loadPDF = React.useCallback(async (pdfFile: File) => {\n    try {\n      const arrayBuffer = await pdfFile.arrayBuffer();\n      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\n      setPdfDocument(pdf);\n      setTotalPages(pdf.numPages);\n      setSelectedPage(1);\n      setTimeout(() => renderPagePreview(pdf, 1), 100);\n    } catch (error) {\n      console.error('Error loading PDF:', error);\n      alert('Failed to load PDF');\n    }\n  }, [renderPagePreview]);\n\n  // Auto-load shared file\n  useEffect(() => {\n    if (sharedFile && !file && !result) {\n      const sharedFileObj = new File([sharedFile.blob], sharedFile.name, { type: 'application/pdf' });\n      handleFilesSelected([sharedFileObj]);\n      clearSharedFile();\n    }\n    return () => {\n      if (renderTaskRef.current) {\n        try { renderTaskRef.current.cancel(); } catch (e) { };\n        renderTaskRef.current = null;\n      }\n    };\n  }, [sharedFile, file, result, clearSharedFile, loadPDF]);\n\n  // Auto-update preview\n  useEffect(() => {\n    if (pdfDocument && selections.length > 0) {\n      renderPagePreview(pdfDocument, selectedPage);\n    }\n  }, [pdfDocument, selections, selectedPage, showPreview, fontSize, fontFamily, textColor, backgroundColor, textOffsetX, textOffsetY, isBold, isItalic, textAlign, renderPagePreview]);\n\n  // Auto-save result\n  useEffect(() => {\n    if (result && !isProcessing && !resultSaved) {\n      const fileName = file?.name.replace(/\\.pdf$/i, '_edited.pdf') || 'edited.pdf';\n      setSharedFile(result, fileName, 'edit-text-pdf');\n      setResultSaved(true);\n    }\n  }, [result, isProcessing, resultSaved, file?.name, setSharedFile]);\n\n  const handleFilesSelected = async (selectedFiles: File[]) => {\n    const selectedFile = selectedFiles[0];\n    if (!selectedFile) return;\n\n    const uploadedFile: UploadedFile = {\n      id: `${Date.now()}`,\n      file: selectedFile,\n      name: selectedFile.name,\n      size: selectedFile.size,\n      status: 'completed',\n    };\n    setFile(uploadedFile);\n    setResult(null);\n    setResultSaved(false);\n    setSelections([]);\n    setActiveSelectionId(null);\n    await loadPDF(selectedFile);\n  };\n\n  const getClickTarget = (x: number, y: number, selection: TextOccurrence): 'move' | 'resize-nw' | 'resize-ne' | 'resize-sw' | 'resize-se' | null => {\n    if (!selection) return null;\n    const handleSize = 10;\n    const tolerance = handleSize / 2;\n    if (Math.abs(x - selection.x) < tolerance && Math.abs(y - selection.y) < tolerance) return 'resize-nw';\n    if (Math.abs(x - (selection.x + selection.width)) < tolerance && Math.abs(y - selection.y) < tolerance) return 'resize-ne';\n    if (Math.abs(x - selection.x) < tolerance && Math.abs(y - (selection.y + selection.height)) < tolerance) return 'resize-sw';\n    if (Math.abs(x - (selection.x + selection.width)) < tolerance && Math.abs(y - (selection.y + selection.height)) < tolerance) return 'resize-se';\n    if (x >= selection.x && x <= selection.x + selection.width && y >= selection.y && y <= selection.y + selection.height) return 'move';\n    return null;\n  };\n\n  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!canvasRef.current) return;\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const scaleX = canvas.width / rect.width;\n    const scaleY = canvas.height / rect.height;\n    const x = (e.clientX - rect.left) * scaleX;\n    const y = (e.clientY - rect.top) * scaleY;\n\n    if (!showPreview) {\n      if (activeSelectionId) {\n        const activeSelection = selections.find(s => s.id === activeSelectionId);\n        if (activeSelection) {\n          const clickTarget = getClickTarget(x, y, activeSelection);\n          if (clickTarget) {\n            setIsEditingSelection(true);\n            setEditMode(clickTarget);\n            setEditStart({ x, y });\n            return;\n          }\n        }\n      }\n      for (const selection of selections) {\n        const clickTarget = getClickTarget(x, y, selection);\n        if (clickTarget) {\n          setActiveSelectionId(selection.id);\n          setIsEditingSelection(true);\n          setEditMode(clickTarget);\n          setEditStart({ x, y });\n          return;\n        }\n      }\n    }\n    setIsSelecting(true);\n    setSelectionStart({ x, y });\n  };\n\n  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!canvasRef.current || !pdfDocument) return;\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const scaleX = canvas.width / rect.width;\n    const scaleY = canvas.height / rect.height;\n    const x = (e.clientX - rect.left) * scaleX;\n    const y = (e.clientY - rect.top) * scaleY;\n\n    if (isEditingSelection && editStart && activeSelectionId && editMode) {\n      const activeSelection = selections.find(s => s.id === activeSelectionId);\n      if (!activeSelection) return;\n      const dx = x - editStart.x;\n      const dy = y - editStart.y;\n      let updatedSelection = { ...activeSelection };\n\n      switch (editMode) {\n        case 'move':\n          updatedSelection.x = activeSelection.x + dx;\n          updatedSelection.y = activeSelection.y + dy;\n          break;\n        case 'resize-nw':\n          updatedSelection.x = activeSelection.x + dx;\n          updatedSelection.y = activeSelection.y + dy;\n          updatedSelection.width = activeSelection.width - dx;\n          updatedSelection.height = activeSelection.height - dy;\n          break;\n        case 'resize-ne':\n          updatedSelection.y = activeSelection.y + dy;\n          updatedSelection.width = activeSelection.width + dx;\n          updatedSelection.height = activeSelection.height - dy;\n          break;\n        case 'resize-sw':\n          updatedSelection.x = activeSelection.x + dx;\n          updatedSelection.width = activeSelection.width - dx;\n          updatedSelection.height = activeSelection.height + dy;\n          break;\n        case 'resize-se':\n          updatedSelection.width = activeSelection.width + dx;\n          updatedSelection.height = activeSelection.height + dy;\n          break;\n      }\n      if (updatedSelection.width < 10) updatedSelection.width = 10;\n      if (updatedSelection.height < 10) updatedSelection.height = 10;\n      setSelections(prev => prev.map(s => s.id === activeSelectionId ? updatedSelection : s));\n      setEditStart({ x, y });\n      return;\n    }\n\n    if (isSelecting && selectionStart) {\n      const tempX = Math.min(selectionStart.x, x);\n      const tempY = Math.min(selectionStart.y, y);\n      const tempWidth = Math.abs(x - selectionStart.x);\n      const tempHeight = Math.abs(y - selectionStart.y);\n      const tempSelection: TextOccurrence = {\n        id: 'temp', text: '', x: tempX, y: tempY, width: tempWidth,\n        height: tempHeight, pageNumber: selectedPage, mode: editMode_type, textAlign: textAlign\n      };\n      renderPagePreview(pdfDocument, selectedPage, tempSelection, editMode_type);\n      return;\n    }\n\n    // Cursor logic\n    if (!showPreview && !isSelecting && !isEditingSelection) {\n      let cursorSet = false;\n      if (activeSelectionId) {\n        const activeSelection = selections.find(s => s.id === activeSelectionId);\n        if (activeSelection) {\n          const target = getClickTarget(x, y, activeSelection);\n          if (target) {\n            if (target === 'move') canvas.style.cursor = 'move';\n            else if (target === 'resize-nw' || target === 'resize-se') canvas.style.cursor = 'nwse-resize';\n            else if (target === 'resize-ne' || target === 'resize-sw') canvas.style.cursor = 'nesw-resize';\n            cursorSet = true;\n          }\n        }\n      }\n      if (!cursorSet) {\n        for (const selection of selections) {\n          if (getClickTarget(x, y, selection)) {\n            canvas.style.cursor = 'pointer';\n            cursorSet = true;\n            break;\n          }\n        }\n      }\n      if (!cursorSet) canvas.style.cursor = 'crosshair';\n    }\n  };\n\n  const extractTextFromSelection = async (selection: TextOccurrence) => {\n    if (!pdfDocument) return;\n    try {\n      const page = await pdfDocument.getPage(selectedPage);\n      const textContent = await page.getTextContent();\n      const viewport = page.getViewport({ scale: canvasScale });\n      let extractedText = '';\n      let detectedFontSize = 0;\n      let fontSizeCount = 0;\n\n      const getIntersectionPercentage = (itemX: number, itemY: number, itemW: number, itemH: number, selX: number, selY: number, selW: number, selH: number) => {\n        const x1 = Math.max(itemX, selX);\n        const y1 = Math.max(itemY, selY);\n        const x2 = Math.min(itemX + itemW, selX + selW);\n        const y2 = Math.min(itemY + itemH, selY + selH);\n        if (x2 > x1 && y2 > y1) return ((x2 - x1) * (y2 - y1)) / (itemW * itemH);\n        return 0;\n      };\n\n      for (const item of textContent.items) {\n        if ('str' in item && item.str.trim()) {\n          const transform = item.transform;\n          const itemFontSize = Math.sqrt(transform[0] * transform[0] + transform[1] * transform[1]);\n          const height = item.height || itemFontSize;\n          const itemX = transform[4];\n          const itemY = viewport.height - transform[5] - height;\n          const width = item.width || (item.str.length * itemFontSize * 0.6);\n          if (getIntersectionPercentage(itemX, itemY, width, height, selection.x, selection.y, selection.width, selection.height) > 0.5) {\n            extractedText += item.str + ' ';\n            detectedFontSize += itemFontSize;\n            fontSizeCount++;\n          }\n        }\n      }\n      if (fontSizeCount > 0) {\n        const avgFontSize = Math.round(detectedFontSize / fontSizeCount);\n        selection.fontSize = avgFontSize;\n        setFontSize(Math.max(8, Math.min(72, avgFontSize)));\n      }\n      selection.text = extractedText.trim();\n      setSelections(prev => prev.map(s => s.id === selection.id ? { ...selection } : s));\n    } catch (error) { console.error('Error extracting text:', error); }\n  };\n\n  const handleMouseUp = async (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (isEditingSelection) {\n      setIsEditingSelection(false);\n      setEditMode(null);\n      setEditStart(null);\n      if (activeSelectionId && pdfDocument) {\n        const activeSelection = selections.find(s => s.id === activeSelectionId);\n        if (activeSelection && activeSelection.mode === 'replace') {\n          await extractTextFromSelection(activeSelection);\n        }\n      }\n      return;\n    }\n    if (!isSelecting || !selectionStart || !canvasRef.current || !pdfDocument) return;\n\n    const canvas = canvasRef.current;\n    const rect = canvas.getBoundingClientRect();\n    const scaleX = canvas.width / rect.width;\n    const scaleY = canvas.height / rect.height;\n    const x = (e.clientX - rect.left) * scaleX;\n    const y = (e.clientY - rect.top) * scaleY;\n    const selX = Math.min(selectionStart.x, x);\n    const selY = Math.min(selectionStart.y, y);\n    const selWidth = Math.abs(x - selectionStart.x);\n    const selHeight = Math.abs(y - selectionStart.y);\n\n    const newSelection: TextOccurrence = {\n      id: `sel-${Date.now()}-${Math.random()}`,\n      text: '', x: selX, y: selY, width: selWidth, height: selHeight,\n      pageNumber: selectedPage, mode: editMode_type, textAlign: textAlign\n    };\n\n    if (newSelection.mode === 'replace') await extractTextFromSelection(newSelection);\n    setSelections(prev => [...prev, newSelection]);\n    setActiveSelectionId(newSelection.id);\n    setIsSelecting(false);\n    setSelectionStart(null);\n  };\n\n  const handleReplaceText = async () => {\n    if (!file || selections.length === 0) return;\n    setIsProcessing(true);\n    try {\n      const result = await pdfService.editTextInPDFVector(\n        file.file,\n        { selections, backgroundColor, textColor, fontSize, fontFamily: fontFamily as any, isBold, isItalic, textOffsetX, textOffsetY, canvasScale },\n        () => { }\n      );\n      if (result.success && result.data) {\n        setResult(result.data);\n      } else {\n        throw result.error || new Error('Failed to edit PDF');\n      }\n    } catch (error: unknown) {\n      console.error('Error replacing text:', error);\n      const errorMsg = (error as Error)?.message || '';\n      if (errorMsg.includes('cannot encode') || errorMsg.includes('WinAnsi')) {\n        alert('‚ö†Ô∏è Error: Selected font does not support non-Latin characters.');\n      } else {\n        alert(t('editText.replaceError') || 'Failed to replace text');\n      }\n    } finally { setIsProcessing(false); }\n  };\n\n  const handleDownload = () => {\n    if (!result) return;\n    const url = URL.createObjectURL(result);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = file?.name.replace(/\\.pdf$/i, '_edited.pdf') || 'edited.pdf';\n    link.click();\n    URL.revokeObjectURL(url);\n  };\n\n  const handleReset = () => {\n    setFile(null); setResult(null); setResultSaved(false); setSelections([]); setActiveSelectionId(null);\n  };\n\n  const renderContent = () => {\n    if (!file) return null;\n    if (result) {\n      return (\n        <div className=\"space-y-6\">\n          <div className=\"bg-gradient-to-r from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20 border-2 border-green-200 dark:border-green-800 rounded-2xl p-8\">\n            <div className=\"text-center space-y-4\">\n              <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/50 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <CheckCircle2 className=\"w-10 h-10 text-green-600 dark:text-green-400\" />\n              </div>\n              <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white\">{t('common.success')}</h2>\n            </div>\n          </div>\n          <div className=\"flex gap-3 justify-center\">\n            <Button onClick={handleDownload} size=\"lg\" className=\"bg-green-600 hover:bg-green-700 text-white shadow-lg hover:shadow-xl transition-all\">{t('common.download')}</Button>\n            <Button variant=\"outline\" onClick={handleReset} size=\"lg\">{t('common.processAnother')}</Button>\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"flex flex-col h-full space-y-4\">\n        {/* Preview Toolbar */}\n        <div className=\"flex justify-between items-center bg-white dark:bg-gray-800 p-2 rounded-lg border border-gray-200 dark:border-gray-700\">\n          <div className=\"flex items-center gap-2\">\n            <Button variant=\"ghost\" size=\"sm\" onClick={() => {\n              const newPage = Math.max(1, selectedPage - 1);\n              setSelectedPage(newPage);\n              renderPagePreview(pdfDocument, newPage);\n            }} disabled={selectedPage <= 1}>Previous</Button>\n            <span className=\"text-sm\">Page {selectedPage} / {totalPages}</span>\n            <Button variant=\"ghost\" size=\"sm\" onClick={() => {\n              const newPage = Math.min(totalPages, selectedPage + 1);\n              setSelectedPage(newPage);\n              renderPagePreview(pdfDocument, newPage);\n            }} disabled={selectedPage >= totalPages}>Next</Button>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <Label className=\"text-xs\">Preview</Label>\n            <input type=\"checkbox\" checked={showPreview} onChange={(e) => setShowPreview(e.target.checked)} className=\"toggle\" />\n          </div>\n        </div>\n\n        {/* Canvas */}\n        <div className=\"flex-1 overflow-auto bg-gray-100 dark:bg-gray-900 rounded-xl relative border border-gray-200 dark:border-gray-700 flex justify-center p-4\">\n          <canvas\n            ref={canvasRef}\n            onMouseDown={handleMouseDown}\n            onMouseMove={handleMouseMove}\n            onMouseUp={handleMouseUp}\n            onMouseLeave={handleMouseUp}\n            className=\"shadow-lg max-w-full\"\n            style={{ maxHeight: 'calc(100vh - 300px)' }}\n          />\n        </div>\n      </div>\n    );\n  };\n\n  const renderSettings = () => {\n    return (\n      <div className=\"space-y-6\">\n        <h3 className=\"text-lg font-semibold flex items-center gap-2\">\n          <Type className=\"w-5 h-5\" /> {t('editText.settings')}\n        </h3>\n\n        {/* Mode Selection */}\n        <div className=\"space-y-3\">\n          <Label>Edit Mode</Label>\n          <Select value={editMode_type} onValueChange={(v: any) => setEditModeType(v)}>\n            <SelectTrigger><SelectValue /></SelectTrigger>\n            <SelectContent>\n              <SelectItem value=\"replace\">Replace Text</SelectItem>\n              <SelectItem value=\"cover\">Redact / Cover</SelectItem>\n            </SelectContent>\n          </Select>\n        </div>\n\n        {/* Text Input (Only for Replace mode) */}\n        {editMode_type === 'replace' && (\n          <div className=\"space-y-3\">\n            <Label>Replacement Text</Label>\n            <textarea\n              className=\"w-full p-2 border rounded-md dark:bg-gray-800 dark:border-gray-700\"\n              rows={3}\n              placeholder=\"Enter text...\"\n              value={activeSelectionId ? selections.find(s => s.id === activeSelectionId)?.text || '' : ''}\n              onChange={(e) => {\n                if (activeSelectionId) {\n                  setSelections(prev => prev.map(s => s.id === activeSelectionId ? { ...s, text: e.target.value } : s));\n                }\n              }}\n            />\n          </div>\n        )}\n\n        {/* Styling */}\n        <div className=\"grid grid-cols-2 gap-4\">\n          <div className=\"space-y-2\">\n            <Label>Font Size</Label>\n            <Input type=\"number\" value={fontSize} onChange={(e) => setFontSize(parseInt(e.target.value))} />\n          </div>\n          <div className=\"space-y-2\">\n            <Label>Family</Label>\n            <Select value={fontFamily} onValueChange={setFontFamily}>\n              <SelectTrigger><SelectValue /></SelectTrigger>\n              <SelectContent>\n                <SelectItem value=\"Arial\">Arial</SelectItem>\n                <SelectItem value=\"Times New Roman\">Times New Roman</SelectItem>\n                <SelectItem value=\"Courier New\">Courier New</SelectItem>\n                <SelectItem value=\"Helvetica\">Helvetica</SelectItem>\n              </SelectContent>\n            </Select>\n          </div>\n        </div>\n        <div className=\"flex gap-2\">\n          <Button variant={isBold ? \"default\" : \"outline\"} size=\"icon\" onClick={() => setIsBold(!isBold)}><Bold className=\"w-4 h-4\" /></Button>\n          <Button variant={isItalic ? \"default\" : \"outline\"} size=\"icon\" onClick={() => setIsItalic(!isItalic)}><Italic className=\"w-4 h-4\" /></Button>\n          <div className=\"bg-gray-200 w-px mx-2\"></div>\n          <Button variant={textAlign === 'left' ? \"default\" : \"outline\"} size=\"icon\" onClick={() => setTextAlign('left')}><AlignLeft className=\"w-4 h-4\" /></Button>\n          <Button variant={textAlign === 'center' ? \"default\" : \"outline\"} size=\"icon\" onClick={() => setTextAlign('center')}><AlignCenter className=\"w-4 h-4\" /></Button>\n          <Button variant={textAlign === 'right' ? \"default\" : \"outline\"} size=\"icon\" onClick={() => setTextAlign('right')}><AlignRight className=\"w-4 h-4\" /></Button>\n        </div>\n\n        {/* Colors */}\n        <div className=\"space-y-2\">\n          <Label>Text Color</Label>\n          <div className=\"flex gap-2\">\n            <Input type=\"color\" value={textColor} onChange={(e) => setTextColor(e.target.value)} className=\"w-12 h-10 p-1\" />\n            <Input type=\"text\" value={textColor} onChange={(e) => setTextColor(e.target.value)} className=\"flex-1\" />\n          </div>\n        </div>\n        <div className=\"space-y-2\">\n          <Label>Background Color</Label>\n          <div className=\"flex gap-2\">\n            <Input type=\"color\" value={backgroundColor} onChange={(e) => setBackgroundColor(e.target.value)} className=\"w-12 h-10 p-1\" />\n            <Input type=\"text\" value={backgroundColor} onChange={(e) => setBackgroundColor(e.target.value)} className=\"flex-1\" />\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  const renderActions = () => {\n    return (\n      <Button onClick={handleReplaceText} disabled={isProcessing || !file || selections.length === 0} className=\"w-full py-6 text-lg font-bold\">\n        {isProcessing ? t('common.processing') : 'Apply Changes'}\n      </Button>\n    );\n  };\n\n  return (\n    <ToolLayout\n      title={t('tools.edit-text-pdf.name')}\n      description={t('tools.edit-text-pdf.description')}\n      hasFiles={!!file}\n      onUpload={handleFilesSelected}\n      isProcessing={isProcessing}\n      maxFiles={1}\n      uploadTitle={t('common.selectFile')}\n      uploadDescription={t('upload.singleFileAllowed')}\n      settings={!result ? renderSettings() : null}\n      actions={!result ? renderActions() : null}\n    >\n      {renderContent()}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/ExtractImagesPDF.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/ExtractPagesPDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ProgressBar' is defined but never used.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Card' is defined but never used.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CardContent' is defined but never used.","line":14,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'progress' is assigned a value but never used.","line":22,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'progressMessage' is assigned a value but never used.","line":23,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":73,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":73,"endColumn":19}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { ProgressBar } from '@/components/common/ProgressBar';\nimport { PDFPreview } from '@/components/common/PDFPreview';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport pdfService from '@/services/pdfService';\nimport type { UploadedFile } from '@/types/pdf';\nimport type { Tool } from '@/types';\nimport { HASH_TOOL_MAP } from '@/types';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { CheckCircle2, Minimize2, Shield, Stamp, Layers } from 'lucide-react';\n\nexport const ExtractPagesPDF: React.FC = () => {\n  const { t } = useI18n();\n  const { sharedFile, clearSharedFile, setSharedFile } = useSharedFile();\n  const [file, setFile] = useState<UploadedFile | null>(null);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [progressMessage, setProgressMessage] = useState('');\n  const [result, setResult] = useState<Blob | null>(null);\n  const [loadedFromShared, setLoadedFromShared] = useState(false);\n  const [resultSaved, setResultSaved] = useState(false);\n  const [pagesToExtract, setPagesToExtract] = useState('');\n\n  useEffect(() => {\n    if (sharedFile && !file && !result) {\n      const sharedFileObj = new File([sharedFile.blob], sharedFile.name, { type: 'application/pdf' });\n      const uploadedFile: UploadedFile = {\n        id: `${Date.now()}`,\n        file: sharedFileObj,\n        name: sharedFile.name,\n        size: sharedFileObj.size,\n        status: 'pending',\n      };\n      setFile(uploadedFile);\n      setLoadedFromShared(true);\n      pdfService.getPDFInfo(sharedFileObj).then((info) => {\n        setFile((prev) => (prev ? { ...prev, info, status: 'completed' } : null));\n      }).catch(() => {\n        setFile((prev) => prev ? { ...prev, status: 'error', error: 'Failed to read PDF' } : null);\n      });\n      clearSharedFile();\n    }\n  }, [sharedFile, file, result, clearSharedFile]);\n\n  useEffect(() => {\n    if (result && !isProcessing && !resultSaved) {\n      const fileName = file?.name.replace(/\\.pdf$/i, '_extracted_pages.pdf') || 'extracted_pages.pdf';\n      setSharedFile(result, fileName, 'extract-pages-pdf');\n      setResultSaved(true);\n    }\n  }, [result, isProcessing, resultSaved, file?.name, setSharedFile]);\n\n  const handleFileSelected = async (selectedFiles: File[]) => {\n    const selectedFile = selectedFiles[0];\n    if (!selectedFile) return;\n    const uploadedFile: UploadedFile = {\n      id: `${Date.now()}`,\n      file: selectedFile,\n      name: selectedFile.name,\n      size: selectedFile.size,\n      status: 'pending',\n    };\n    setFile(uploadedFile);\n    setResult(null);\n    try {\n      const info = await pdfService.getPDFInfo(selectedFile);\n      setFile((prev) => (prev ? { ...prev, info, status: 'completed' } : null));\n    } catch (error) {\n      setFile((prev) => prev ? { ...prev, status: 'error', error: 'Failed to read PDF' } : null);\n    }\n  };\n\n  const parsePageNumbers = (input: string, maxPages: number): number[] => {\n    const pages = new Set<number>();\n    const parts = input.split(',').map(p => p.trim());\n    for (const part of parts) {\n      if (part.includes('-')) {\n        const [start, end] = part.split('-').map(n => parseInt(n.trim()));\n        if (!isNaN(start) && !isNaN(end)) {\n          for (let i = Math.max(1, start); i <= Math.min(maxPages, end); i++) pages.add(i);\n        }\n      } else {\n        const pageNum = parseInt(part);\n        if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= maxPages) pages.add(pageNum);\n      }\n    }\n    return Array.from(pages).sort((a, b) => a - b);\n  };\n\n  const handleExtract = async () => {\n    if (!file) return;\n    const maxPages = file.info?.pages || 0;\n    const pageNumbers = parsePageNumbers(pagesToExtract, maxPages);\n    if (pageNumbers.length === 0) {\n      alert(t('extractPages.invalidPages'));\n      return;\n    }\n    setIsProcessing(true);\n    setProgress(0);\n    setResult(null);\n    setResultSaved(false);\n    try {\n      const extractResult = await pdfService.extractPDF(file.file, pageNumbers, (prog, msg) => {\n        setProgress(prog);\n        setProgressMessage(msg);\n      });\n      if (extractResult.success && extractResult.data) {\n        setResult(extractResult.data);\n      } else {\n        alert(t('extractPages.failed'));\n      }\n    } catch (error) {\n      alert(t('extractPages.failed'));\n      console.error(error);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleDownload = () => {\n    if (!result || !file) return;\n    const filename = file.name.replace('.pdf', '_extracted.pdf');\n    pdfService.downloadFile(result, filename);\n  };\n\n  const handleReset = () => {\n    setFile(null);\n    setResult(null);\n    setResultSaved(false);\n    setProgress(0);\n    setProgressMessage('');\n    setLoadedFromShared(false);\n    setPagesToExtract('');\n  };\n\n  const handleQuickAction = async (toolId: Tool) => {\n    if (!result || !file) return;\n    const filename = file.name.replace('.pdf', '_extracted.pdf');\n    setSharedFile(result, filename, 'extract-pages-pdf');\n    await new Promise(resolve => setTimeout(resolve, 100));\n    window.location.hash = HASH_TOOL_MAP[toolId];\n  };\n\n  const maxPages = file?.info?.pages || 1;\n\n  const renderContent = () => {\n    if (!file) return null;\n    if (result) {\n      return (\n        <div className=\"text-center space-y-6 animate-in fade-in zoom-in duration-300\">\n          <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/30 rounded-full flex items-center justify-center mx-auto text-green-600\">\n            <CheckCircle2 className=\"w-10 h-10\" />\n          </div>\n          <h2 className=\"text-2xl font-bold\">{t('extractPages.success')}</h2>\n          <p className=\"text-gray-500\">{t('extractPages.successDescription')}</p>\n\n          <div className=\"flex justify-center gap-4\">\n            <Button onClick={handleDownload} size=\"lg\" className=\"bg-green-600 hover:bg-green-700\">{t('common.download')}</Button>\n            <Button onClick={handleReset} variant=\"outline\" size=\"lg\">{t('extractPages.extractAnother')}</Button>\n          </div>\n\n          <div className=\"grid grid-cols-2 lg:grid-cols-4 gap-4 mt-8\">\n            <Button onClick={() => handleQuickAction('compress-pdf')} variant=\"outline\" className=\"h-auto py-4 flex flex-col gap-2\"><Minimize2 className=\"h-5 w-5\" /><span>{t('tools.compress-pdf.name')}</span></Button>\n            <Button onClick={() => handleQuickAction('protect-pdf')} variant=\"outline\" className=\"h-auto py-4 flex flex-col gap-2\"><Shield className=\"h-5 w-5\" /><span>{t('tools.protect-pdf.name')}</span></Button>\n            <Button onClick={() => handleQuickAction('watermark-pdf')} variant=\"outline\" className=\"h-auto py-4 flex flex-col gap-2\"><Stamp className=\"h-5 w-5\" /><span>{t('tools.watermark-pdf.name')}</span></Button>\n            <Button onClick={() => handleQuickAction('merge-pdf')} variant=\"outline\" className=\"h-auto py-4 flex flex-col gap-2\"><Layers className=\"h-5 w-5\" /><span>{t('tools.merge-pdf.name')}</span></Button>\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"flex flex-col items-center space-y-4\">\n        {loadedFromShared && (\n          <div className=\"bg-ocean-50 dark:bg-ocean-900/20 border border-ocean-200 dark:border-ocean-800 rounded-lg p-4 w-full flex items-center justify-between mb-4\">\n            <div className=\"flex items-center gap-2 text-ocean-700 dark:text-ocean-300\">\n              <span className=\"text-xl\">‚ú®</span>\n              <span className=\"font-medium\">{t('common.autoLoaded')}</span>\n            </div>\n          </div>\n        )}\n        <div className=\"relative shadow-lg border rounded-lg overflow-hidden bg-gray-100 dark:bg-gray-800\">\n          <PDFPreview file={file.file} width={300} height={400} />\n        </div>\n        <div className=\"text-center\">\n          <h3 className=\"font-medium\">{file.name}</h3>\n          <p className=\"text-sm text-gray-500\">{file.info?.pages} pages ‚Ä¢ {pdfService.formatFileSize(file.size)}</p>\n        </div>\n      </div>\n    );\n  };\n\n  const renderSettings = () => (\n    <div className=\"space-y-6\">\n      <div className=\"space-y-2\">\n        <Label>{t('extractPages.pagesToExtract')}</Label>\n        <Input\n          value={pagesToExtract}\n          onChange={(e) => setPagesToExtract(e.target.value)}\n          placeholder=\"e.g. 1,3,5-7\"\n        />\n        <p className=\"text-xs text-gray-500\">{t('extractPages.hint', { total: String(maxPages) })}</p>\n      </div>\n\n      <div className=\"bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg text-sm text-blue-700 dark:text-blue-300\">\n        <p className=\"font-medium mb-1\">‚ÑπÔ∏è {t('extractPages.info')}</p>\n        <p>{t('extractPages.infoDescription')}</p>\n      </div>\n    </div>\n  );\n\n  return (\n    <ToolLayout\n      title={t('tools.extract-pages-pdf.name')}\n      description={t('tools.extract-pages-pdf.description')}\n      hasFiles={!!file}\n      onUpload={handleFileSelected}\n      isProcessing={isProcessing}\n      maxFiles={1}\n      uploadTitle={t('common.selectFile')}\n      uploadDescription={t('upload.singleFileAllowed')}\n      accept=\".pdf\"\n      settings={!result && file ? renderSettings() : null}\n      actions={!result && file ? (\n        <Button onClick={handleExtract} disabled={isProcessing || !pagesToExtract} className=\"w-full py-6 text-lg font-bold\">\n          {isProcessing ? t('common.processing') : t('extractPages.extractButton')}\n        </Button>\n      ) : null}\n    >\n      {renderContent()}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/FlattenPDF.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/ImagesToPDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'ProgressBar' is defined but never used.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'PDFMultiPagePreview' is defined but never used.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Card' is defined but never used.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CardContent' is defined but never used.","line":14,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'progress' is assigned a value but never used.","line":41,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'progressMessage' is assigned a value but never used.","line":42,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1870,1873],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1870,1873],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'handleQuickAction' is assigned a value but never used.","line":266,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":266,"endColumn":26}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { ProgressBar } from '@/components/common/ProgressBar';\nimport { PDFMultiPagePreview } from '@/components/common/PDFMultiPagePreview';\nimport { SmartImageFilterPanel } from '@/components/smart/SmartImageFilterPanel';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport pdfService from '@/services/pdfService';\nimport smartImageFilterService, { type SmartImageFilterAnalysis } from '@/services/smartImageFilterService';\nimport type { Tool } from '@/types';\nimport type { ExtractedImage } from '@/types/pdf';\nimport { HASH_TOOL_MAP } from '@/types';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Label } from '@/components/ui/label';\nimport { Badge } from '@/components/ui/badge';\nimport { CheckCircle2, RotateCw, Trash2, Eye } from 'lucide-react';\n\ninterface ImageFile {\n  id: string;\n  file: File;\n  name: string;\n  size: number;\n  preview: string;\n  width?: number;\n  height?: number;\n  hidden?: boolean; // For smart filtering\n}\n\ntype PageSize = 'fit' | 'a4' | 'letter';\ntype Orientation = 'portrait' | 'landscape';\n\nexport const ImagesToPDF: React.FC = () => {\n  const { t } = useI18n();\n  const { setSharedFile: saveSharedFile } = useSharedFile();\n  const [images, setImages] = useState<ImageFile[]>([]);\n  const [pageSize, setPageSize] = useState<PageSize>('fit');\n  const [orientation, setOrientation] = useState<Orientation>('portrait');\n  const [margin, setMargin] = useState<number>(0);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [progressMessage, setProgressMessage] = useState('');\n  const [result, setResult] = useState<{ blob: Blob; metadata: any } | null>(null);\n  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);\n\n  // Smart Image Filter state\n  const [smartEnabled, setSmartEnabled] = useState(true);\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n  const [analysisResult, setAnalysisResult] = useState<SmartImageFilterAnalysis | null>(null);\n  const [selectedCategories, setSelectedCategories] = useState<Set<string>>(new Set(['photo', 'chart', 'logo', 'other']));\n  const [duplicateHashes, setDuplicateHashes] = useState<Map<string, string[]>>(new Map());\n\n  // Analyze images when they change\n  useEffect(() => {\n    if (images.length === 0 || !smartEnabled) {\n      setAnalysisResult(null);\n      return;\n    }\n\n    const analyzeImages = async () => {\n      setIsAnalyzing(true);\n      try {\n        const imagesToAnalyze: ExtractedImage[] = await Promise.all(\n          images.map(async (img, index) => {\n            if (!img.width || !img.height) {\n              const dimensions = await getImageDimensions(img.file);\n              img.width = dimensions.width;\n              img.height = dimensions.height;\n            }\n            return {\n              id: img.id,\n              blob: img.file,\n              filename: img.name,\n              width: img.width || 0,\n              height: img.height || 0,\n              pageNumber: index + 1,\n              format: img.file.type.includes('png') ? 'png' : 'jpg',\n              size: img.size,\n              previewUrl: img.preview,\n            } as ExtractedImage;\n          })\n        );\n\n        const analysis = smartImageFilterService.analyzeImages(imagesToAnalyze);\n        setAnalysisResult(analysis);\n\n        const hashes = await Promise.all(\n          images.map(async (img) => {\n            const buffer = await img.file.arrayBuffer();\n            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);\n            const hashArray = Array.from(new Uint8Array(hashBuffer));\n            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n            return { id: img.id, hash: hashHex };\n          })\n        );\n\n        const duplicateMap = new Map<string, string[]>();\n        hashes.forEach(({ id, hash }) => {\n          if (!duplicateMap.has(hash)) duplicateMap.set(hash, []);\n          duplicateMap.get(hash)!.push(id);\n        });\n\n        const actualDuplicates = new Map<string, string[]>();\n        duplicateMap.forEach((ids, hash) => {\n          if (ids.length > 1) actualDuplicates.set(hash, ids);\n        });\n\n        setDuplicateHashes(actualDuplicates);\n      } catch (error) {\n        console.error('Image analysis failed:', error);\n      } finally {\n        setIsAnalyzing(false);\n      }\n    };\n\n    const timeoutId = setTimeout(analyzeImages, 500);\n    return () => clearTimeout(timeoutId);\n  }, [images, smartEnabled]);\n\n  const getImageDimensions = (file: File): Promise<{ width: number; height: number }> => {\n    return new Promise((resolve) => {\n      const img = new Image();\n      img.onload = () => resolve({ width: img.width, height: img.height });\n      img.onerror = () => resolve({ width: 0, height: 0 });\n      img.src = URL.createObjectURL(file);\n    });\n  };\n\n  const handleFilesSelected = async (selectedFiles: File[]) => {\n    const newImages: ImageFile[] = [];\n    for (let i = 0; i < selectedFiles.length; i++) {\n      const file = selectedFiles[i];\n      if (!file.type.startsWith('image/')) continue;\n      const preview = URL.createObjectURL(file);\n      const dimensions = await getImageDimensions(file);\n      newImages.push({\n        id: `${Date.now()}-${i}`,\n        file,\n        name: file.name,\n        size: file.size,\n        preview,\n        width: dimensions.width,\n        height: dimensions.height,\n      });\n    }\n    setImages((prev) => [...prev, ...newImages]);\n    setResult(null);\n  };\n\n  const handleRemoveImage = (id: string) => {\n    setImages((prev) => {\n      const image = prev.find((img) => img.id === id);\n      if (image) URL.revokeObjectURL(image.preview);\n      return prev.filter((img) => img.id !== id);\n    });\n  };\n\n  const handleApplyFilter = (filterId: string) => {\n    if (!analysisResult) return;\n    const presets = smartImageFilterService.getFilterPresets();\n    const preset = presets.find(p => p.id === filterId);\n    if (!preset) return;\n    const categorizedImages = analysisResult.categories.flatMap(cat => cat.images);\n    const filtered = categorizedImages.filter(preset.filter);\n    const filteredIds = new Set(filtered.map(img => img.id));\n    setImages(prev => prev.map(img => ({ ...img, hidden: !filteredIds.has(img.id) })));\n  };\n\n  const handleSelectCategory = (category: string, selected: boolean) => {\n    setSelectedCategories(prev => {\n      const newSet = new Set(prev);\n      if (selected) newSet.add(category);\n      else newSet.delete(category);\n      return newSet;\n    });\n\n    if (analysisResult) {\n      const selectedCats = selected\n        ? new Set([...selectedCategories, category])\n        : new Set([...selectedCategories].filter(c => c !== category));\n\n      if (selectedCats.size === 0) {\n        setImages(prev => prev.map(img => ({ ...img, hidden: false })));\n        return;\n      }\n      const categoriesToShow = analysisResult.categories.filter(cat => selectedCats.has(cat.category)).flatMap(cat => cat.images);\n      const idsToShow = new Set(categoriesToShow.map(img => img.id));\n      setImages(prev => prev.map(img => ({ ...img, hidden: !idsToShow.has(img.id) })));\n    }\n  };\n\n  const handleRemoveDuplicates = () => {\n    const idsToRemove = new Set<string>();\n    duplicateHashes.forEach((ids) => ids.slice(1).forEach(id => idsToRemove.add(id)));\n    setImages(prev => {\n      prev.forEach(img => { if (idsToRemove.has(img.id)) URL.revokeObjectURL(img.preview); });\n      return prev.filter(img => !idsToRemove.has(img.id));\n    });\n  };\n\n  const handleAutoRotate = () => {\n    const landscapeCount = images.filter(img => (img.width || 0) > (img.height || 0)).length;\n    const portraitCount = images.length - landscapeCount;\n    setOrientation(landscapeCount > portraitCount ? 'landscape' : 'portrait');\n  };\n\n  const handleDragStart = (index: number) => setDraggedIndex(index);\n\n  const handleDragOver = (e: React.DragEvent, index: number) => {\n    e.preventDefault();\n    if (draggedIndex === null || draggedIndex === index) return;\n    const newImages = [...images];\n    const draggedItem = newImages[draggedIndex];\n    newImages.splice(draggedIndex, 1);\n    newImages.splice(index, 0, draggedItem);\n    setImages(newImages);\n    setDraggedIndex(index);\n  };\n\n  const handleDragEnd = () => setDraggedIndex(null);\n\n  const handleConvert = async () => {\n    const visibleImages = images.filter(img => !img.hidden);\n    if (visibleImages.length === 0) {\n      alert(t('imagesToPdf.errors.noImages'));\n      return;\n    }\n    setIsProcessing(true);\n    setProgress(0);\n    setResult(null);\n\n    try {\n      const imageFiles = visibleImages.map((img) => img.file);\n      const result = await pdfService.imagesToPDF(\n        imageFiles,\n        (prog, msg) => { setProgress(prog); setProgressMessage(msg); },\n        { pageSize, orientation, margin }\n      );\n\n      if (result.success && result.data) {\n        setResult({ blob: result.data, metadata: result.metadata });\n      } else {\n        alert(result.error?.message || 'Conversion failed');\n      }\n    } catch (error) {\n      console.error(error);\n      alert('An error occurred during conversion');\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleDownload = () => {\n    if (result?.blob) pdfService.downloadFile(result.blob, 'images-to-pdf.pdf');\n  };\n\n  const handleReset = () => {\n    images.forEach((img) => URL.revokeObjectURL(img.preview));\n    setImages([]);\n    setResult(null);\n    setProgress(0);\n    setProgressMessage('');\n    setAnalysisResult(null);\n  };\n\n  const handleQuickAction = (toolId: Tool) => {\n    if (result?.blob) {\n      saveSharedFile(result.blob, 'images-to-pdf.pdf', 'images-to-pdf');\n    }\n    setTimeout(() => {\n      window.location.hash = HASH_TOOL_MAP[toolId];\n    }, 100);\n  };\n\n  const formatFileSize = (bytes: number) => {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`;\n  };\n\n  const duplicateCount = Array.from(duplicateHashes.values()).reduce((sum, ids) => sum + ids.length - 1, 0);\n  const visibleImagesCount = images.filter(img => !img.hidden).length;\n  const hiddenImagesCount = images.filter(img => img.hidden).length;\n\n  const renderSettings = () => (\n    <div className=\"space-y-6\">\n      {/* Smart Filter Panel (Collapsed/Expanded logic inside component) */}\n      <SmartImageFilterPanel\n        analysisResult={analysisResult}\n        isAnalyzing={isAnalyzing}\n        enabled={smartEnabled}\n        onToggle={setSmartEnabled}\n        onApplyFilter={handleApplyFilter}\n        onSelectCategory={handleSelectCategory}\n        selectedCategories={selectedCategories}\n      />\n\n      <div className=\"grid grid-cols-1 gap-4\">\n        {/* Page Size */}\n        <div>\n          <Label>{t('imagesToPdf.pageSize')}</Label>\n          <div className=\"grid grid-cols-3 gap-2 mt-2\">\n            {(['fit', 'a4', 'letter'] as PageSize[]).map((size) => (\n              <Button\n                key={size}\n                onClick={() => setPageSize(size)}\n                variant={pageSize === size ? \"default\" : \"outline\"}\n                size=\"sm\"\n                className=\"w-full\"\n              >\n                {t(`imagesToPdf.pageSizes.${size}`)}\n              </Button>\n            ))}\n          </div>\n        </div>\n\n        {/* Orientation */}\n        <div>\n          <Label>{t('imagesToPdf.orientation')}</Label>\n          <div className=\"grid grid-cols-2 gap-2 mt-2\">\n            {(['portrait', 'landscape'] as Orientation[]).map((orient) => (\n              <Button\n                key={orient}\n                onClick={() => setOrientation(orient)}\n                variant={orientation === orient ? \"default\" : \"outline\"}\n                size=\"sm\"\n                className=\"w-full\"\n              >\n                {t(`imagesToPdf.orientations.${orient}`)}\n              </Button>\n            ))}\n          </div>\n        </div>\n\n        {/* Margin */}\n        <div>\n          <Label>{t('imagesToPdf.margin')}: {margin}px</Label>\n          <input\n            type=\"range\"\n            min=\"0\"\n            max=\"50\"\n            step=\"5\"\n            value={margin}\n            onChange={(e) => setMargin(Number(e.target.value))}\n            className=\"w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 mt-2\"\n          />\n        </div>\n      </div>\n    </div>\n  );\n\n  const renderContent = () => {\n    if (!images.length) return null; // Should process onUpload instead\n\n    if (result) {\n      return (\n        <div className=\"space-y-6\">\n          <div className=\"bg-gradient-to-r from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20 border-2 border-green-200 dark:border-green-800 rounded-2xl p-8\">\n            <div className=\"text-center space-y-4\">\n              <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/50 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <CheckCircle2 className=\"w-10 h-10 text-green-600 dark:text-green-400\" />\n              </div>\n              <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white\">\n                {t('common.success')}\n              </h2>\n              <div className=\"text-gray-600 dark:text-gray-400 space-y-1\">\n                <p>{t('imagesToPdf.successMessage', { count: result.metadata?.pageCount || images.length })}</p>\n                <p className=\"text-sm\">{t('common.fileSize')}: {formatFileSize(result.metadata?.processedSize || 0)}</p>\n              </div>\n            </div>\n          </div>\n\n          <div className=\"flex gap-3 justify-center\">\n            <Button onClick={handleDownload} size=\"lg\" className=\"bg-green-600 hover:bg-green-700 text-white shadow-lg hover:shadow-xl transition-all\">\n              {t('common.download')}\n            </Button>\n            <Button variant=\"outline\" onClick={handleReset} size=\"lg\">\n              {t('common.convertAnother')}\n            </Button>\n          </div>\n        </div>\n      )\n    }\n\n    return (\n      <div className=\"space-y-6\">\n        {/* Toolbar */}\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center gap-3\">\n            <h3 className=\"text-lg font-semibold text-ocean-900 dark:text-white\">\n              {t('imagesToPdf.imagesList')} ({visibleImagesCount})\n            </h3>\n            {hiddenImagesCount > 0 && <Badge variant=\"secondary\">{hiddenImagesCount} hidden</Badge>}\n          </div>\n          <div className=\"flex gap-2\">\n            {hiddenImagesCount > 0 && (\n              <Button onClick={() => setImages(prev => prev.map(img => ({ ...img, hidden: false })))} variant=\"outline\" size=\"sm\">\n                <Eye className=\"w-4 h-4 mr-2\" /> Show All\n              </Button>\n            )}\n            {duplicateCount > 0 && (\n              <Button onClick={handleRemoveDuplicates} variant=\"outline\" size=\"sm\">\n                <Trash2 className=\"w-4 h-4 mr-2\" /> {t('smartOrganize.removeDuplicates')} ({duplicateCount})\n              </Button>\n            )}\n            <Button onClick={handleAutoRotate} variant=\"outline\" size=\"sm\">\n              <RotateCw className=\"w-4 h-4 mr-2\" /> Auto Orientation\n            </Button>\n            <Button onClick={handleReset} variant=\"ghost\" size=\"sm\" className=\"text-red-500 hover:text-red-600 hover:bg-red-50\">\n              {t('common.clearAll')}\n            </Button>\n          </div>\n        </div>\n\n        {/* Grid */}\n        <div className=\"grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4\">\n          {images.filter(img => !img.hidden).map((image, index) => (\n            <div\n              key={image.id}\n              draggable\n              onDragStart={() => handleDragStart(index)}\n              onDragOver={(e) => handleDragOver(e, index)}\n              onDragEnd={handleDragEnd}\n              className={`relative group cursor-move border-2 rounded-lg overflow-hidden transition-all bg-white dark:bg-gray-800 ${draggedIndex === index ? 'border-ocean-500 shadow-lg scale-105' : 'border-gray-200 dark:border-gray-700'\n                }`}\n            >\n              <div className=\"aspect-[3/4] overflow-hidden bg-gray-100 dark:bg-gray-900\">\n                <img src={image.preview} alt={image.name} className=\"w-full h-full object-contain\" />\n              </div>\n              <div className=\"absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity\">\n                <Button onClick={() => handleRemoveImage(image.id)} variant=\"destructive\" size=\"icon\" className=\"h-8 w-8 rounded-full shadow-md\">\n                  <Trash2 className=\"w-4 h-4\" />\n                </Button>\n              </div>\n              <div className=\"p-2 text-xs truncate border-t dark:border-gray-700\">\n                {index + 1}. {image.name}\n              </div>\n              {image.width && image.height && (\n                <Badge variant=\"secondary\" className=\"absolute top-2 left-2 text-[10px] opacity-75\">\n                  {image.width}√ó{image.height}\n                </Badge>\n              )}\n            </div>\n          ))}\n          {/* Upload More Box */}\n          <div className=\"aspect-[3/4] border-2 border-dashed border-gray-300 dark:border-gray-700 rounded-lg flex flex-col items-center justify-center text-gray-400 hover:text-gray-500 hover:border-gray-400 hover:bg-gray-50 dark:hover:bg-gray-800 cursor-pointer transition-all\"\n            onClick={() => document.getElementById('tool-layout-upload-input')?.click()}\n          >\n            <span className=\"text-4xl mb-2\">+</span>\n            <span className=\"text-sm\">Add More</span>\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  const renderActions = () => (\n    <Button\n      onClick={handleConvert}\n      disabled={isProcessing || !images.length}\n      className=\"w-full py-6 text-lg rounded-xl font-bold shadow-lg hover:shadow-xl transition-all\"\n    >\n      {isProcessing ? t('common.processing') : t('imagesToPdf.convert')}\n    </Button>\n  );\n\n  return (\n    <ToolLayout\n      title={t('tools.images-to-pdf.name')}\n      description={t('tools.images-to-pdf.description')}\n      hasFiles={images.length > 0}\n      onUpload={handleFilesSelected}\n      isProcessing={isProcessing}\n      maxFiles={50}\n      uploadTitle={t('common.selectFile')}\n      uploadDescription={t('upload.multipleFilesAllowed')}\n      accept=\"image/jpeg,image/jpg,image/png\"\n      settings={!result ? renderSettings() : null}\n      actions={!result ? renderActions() : null}\n    >\n      {renderContent()}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/MergePDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1277,1280],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1277,1280],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":50,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":50,"endColumn":21}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback } from 'react';\nimport { ProgressBar } from '@/components/common/ProgressBar';\nimport { PDFPreview } from '@/components/common/PDFPreview';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Badge } from '@/components/ui/badge';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport pdfService from '@/services/pdfService';\nimport { SmartMergePanel } from '@/components/smart/SmartMergePanel';\nimport type { UploadedFile } from '@/types/pdf';\nimport type { Tool } from '@/types';\nimport { HASH_TOOL_MAP } from '@/types';\nimport { toast } from 'sonner';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { Files, Scissors, Minimize2, Shield, Stamp } from 'lucide-react';\n\nexport const MergePDF: React.FC = () => {\n  const { t } = useI18n();\n  const { setSharedFile, sharedFiles, clearSharedFiles } = useSharedFile();\n  const [files, setFiles] = useState<UploadedFile[]>([]);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [progressMessage, setProgressMessage] = useState('');\n  const [result, setResult] = useState<{ blob: Blob; metadata: any } | null>(null);\n  const [draggedIndex, setDraggedIndex] = useState<number | null>(null);\n  const [hasLoadedSharedFiles, setHasLoadedSharedFiles] = useState(false);\n  const [resultSaved, setResultSaved] = useState(false);\n\n  const handleFilesSelected = useCallback(async (selectedFiles: File[], replaceExisting = false) => {\n    const uploadedFiles: UploadedFile[] = selectedFiles.map((file, index) => ({\n      id: `${Date.now()}-${index}`,\n      file,\n      name: file.name,\n      size: file.size,\n      status: 'pending' as const,\n    }));\n\n    setFiles((prev) => replaceExisting ? uploadedFiles : [...prev, ...uploadedFiles]);\n\n    // Get PDF info for each file\n    for (const uploadedFile of uploadedFiles) {\n      try {\n        const info = await pdfService.getPDFInfo(uploadedFile.file);\n        setFiles((prev) =>\n          prev.map((f) =>\n            f.id === uploadedFile.id ? { ...f, info, status: 'completed' as const } : f\n          )\n        );\n      } catch (error) {\n        setFiles((prev) =>\n          prev.map((f) =>\n            f.id === uploadedFile.id\n              ? { ...f, status: 'error' as const, error: 'Failed to read PDF' }\n              : f\n          )\n        );\n      }\n    }\n  }, []);\n\n  // Auto-load shared files from WelcomeScreen\n  React.useEffect(() => {\n    if (sharedFiles && sharedFiles.files.length > 0 && !hasLoadedSharedFiles) {\n      const loadedFiles = sharedFiles.files.map(sf =>\n        new File([sf.blob], sf.name, { type: sf.blob.type })\n      );\n      handleFilesSelected(loadedFiles, true); // true = replace existing files\n      clearSharedFiles();\n      setHasLoadedSharedFiles(true);\n    }\n  }, [sharedFiles, hasLoadedSharedFiles, clearSharedFiles, handleFilesSelected]);\n\n  // Auto-save result to sharedFile when processing is complete\n  React.useEffect(() => {\n    if (result?.blob && !isProcessing && !resultSaved) {\n      setSharedFile(result.blob, 'merged.pdf', 'merge-pdf');\n      setResultSaved(true);\n    }\n  }, [result, isProcessing, resultSaved, setSharedFile]);\n\n  const handleRemoveFile = (id: string) => {\n    setFiles((prev) => prev.filter((f) => f.id !== id));\n  };\n\n  const handleMerge = async () => {\n    if (files.length < 2) {\n      toast.error(t('merge.errors.minFiles'));\n      return;\n    }\n\n    setIsProcessing(true);\n    setProgress(0);\n    setResult(null);\n    setResultSaved(false);\n\n    try {\n      const fileObjects = files.map((f) => f.file);\n      const result = await pdfService.mergePDFs(fileObjects, (prog, msg) => {\n        setProgress(prog);\n        setProgressMessage(msg);\n      });\n\n      if (result.success && result.data) {\n        setResult({ blob: result.data, metadata: result.metadata });\n        toast.success(t('merge.success.title'));\n      } else {\n        toast.error(result.error?.message || 'Merge failed');\n      }\n    } catch (error) {\n      toast.error('An error occurred during merge');\n      console.error(error);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleDownload = () => {\n    if (result?.blob) {\n      pdfService.downloadFile(result.blob, 'merged.pdf');\n    }\n  };\n\n  const handleReset = () => {\n    setFiles([]);\n    setResult(null);\n    setResultSaved(false);\n    setProgress(0);\n    setProgressMessage('');\n  };\n\n  const handleQuickAction = (toolId: Tool) => {\n    // Save the merged PDF to shared state for the next tool\n    if (result?.blob) {\n      setSharedFile(result.blob, 'merged.pdf', 'merge-pdf');\n    }\n    // Navigate to the selected tool\n    window.location.hash = HASH_TOOL_MAP[toolId];\n  };\n\n  // Drag and drop reordering\n  const handleDragStart = (index: number) => {\n    setDraggedIndex(index);\n  };\n\n  const handleDragOver = (e: React.DragEvent, index: number) => {\n    e.preventDefault();\n    if (draggedIndex === null || draggedIndex === index) return;\n\n    // Reorder files\n    const newFiles = [...files];\n    const draggedFile = newFiles[draggedIndex];\n    newFiles.splice(draggedIndex, 1);\n    newFiles.splice(index, 0, draggedFile);\n\n    setFiles(newFiles);\n    setDraggedIndex(index);\n  };\n\n  const handleDragEnd = () => {\n    setDraggedIndex(null);\n  };\n\n  // Smart Merge: Apply sort order from AI suggestions\n  const handleApplySmartSort = (newOrder: string[]) => {\n    const fileMap = new Map(files.map(f => [f.id, f]));\n    const sortedFiles = newOrder\n      .map(id => fileMap.get(id))\n      .filter((f): f is UploadedFile => f !== undefined);\n    setFiles(sortedFiles);\n    toast.success(t('smartMerge.sortApplied') || 'Sort applied');\n  };\n\n  // Smart Merge: Remove duplicate files\n  const handleRemoveDuplicates = (fileIds: string[]) => {\n    setFiles(prev => prev.filter(f => !fileIds.includes(f.id)));\n    toast.success(t('smartMerge.duplicatesRemoved') || `${fileIds.length} duplicate(s) removed`);\n  };\n\n  // Success view\n  if (result) {\n    return (\n      <ToolLayout\n        title={t('tools.merge-pdf.name')}\n        description={t('tools.merge-pdf.description')}\n        hasFiles={true}\n        onUpload={handleFilesSelected}\n        actions={\n          <div className=\"flex flex-col gap-3 w-full\">\n            <Button onClick={handleDownload} size=\"lg\" className=\"w-full bg-green-600 hover:bg-green-700 text-white shadow-lg shadow-green-500/20\">\n              {t('common.download')}\n            </Button>\n            <Button onClick={handleReset} variant=\"outline\" className=\"w-full\">\n              {t('merge.mergeAnother')}\n            </Button>\n          </div>\n        }\n      >\n        <div className=\"space-y-6\">\n          <Card className=\"bg-green-50/50 dark:bg-green-900/10 border-green-200 dark:border-green-800 backdrop-blur-sm\">\n            <CardContent className=\"p-8 text-center space-y-4\">\n              <div className=\"text-6xl mb-4 animate-scale-in\">‚úÖ</div>\n              <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white\">\n                {t('merge.success.title')}\n              </h2>\n              <div className=\"text-gray-600 dark:text-gray-400 space-y-1\">\n                <p>{t('merge.success.pages')}: <span className=\"font-semibold\">{result.metadata?.pageCount}</span></p>\n                <p>{t('merge.success.size')}: <span className=\"font-semibold\">{pdfService.formatFileSize(result.metadata?.processedSize || 0)}</span></p>\n              </div>\n            </CardContent>\n          </Card>\n\n          {/* Quick Actions */}\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n            <Button onClick={() => handleQuickAction('compress-pdf')} variant=\"outline\" className=\"h-auto py-4 flex flex-col gap-2 hover:border-ocean-400 hover:bg-ocean-50 dark:hover:bg-ocean-900/10\">\n              <Minimize2 className=\"h-6 w-6 text-ocean-500\" />\n              <span>{t('tools.compress-pdf.name')}</span>\n            </Button>\n            <Button onClick={() => handleQuickAction('protect-pdf')} variant=\"outline\" className=\"h-auto py-4 flex flex-col gap-2 hover:border-ocean-400 hover:bg-ocean-50 dark:hover:bg-ocean-900/10\">\n              <Shield className=\"h-6 w-6 text-ocean-500\" />\n              <span>{t('tools.protect-pdf.name')}</span>\n            </Button>\n            <Button onClick={() => handleQuickAction('watermark-pdf')} variant=\"outline\" className=\"h-auto py-4 flex flex-col gap-2 hover:border-ocean-400 hover:bg-ocean-50 dark:hover:bg-ocean-900/10\">\n              <Stamp className=\"h-6 w-6 text-ocean-500\" />\n              <span>{t('tools.watermark-pdf.name')}</span>\n            </Button>\n            <Button onClick={() => handleQuickAction('split-pdf')} variant=\"outline\" className=\"h-auto py-4 flex flex-col gap-2 hover:border-ocean-400 hover:bg-ocean-50 dark:hover:bg-ocean-900/10\">\n              <Scissors className=\"h-6 w-6 text-ocean-500\" />\n              <span>{t('tools.split-pdf.name')}</span>\n            </Button>\n          </div>\n        </div>\n      </ToolLayout>\n    );\n  }\n\n  return (\n    <ToolLayout\n      title={t('tools.merge-pdf.name')}\n      description={t('tools.merge-pdf.description')}\n      hasFiles={files.length > 0}\n      isProcessing={isProcessing}\n      onUpload={(newFiles) => handleFilesSelected(newFiles, false)}\n      uploadTitle={t('upload.selectFiles')}\n      uploadDescription={t('upload.multipleFilesAllowed')}\n      settings={\n        files.length >= 2 ? (\n          <div className=\"space-y-6 animate-slide-up\">\n            <SmartMergePanel\n              files={files.map(f => ({ id: f.id, file: f.file, name: f.name }))}\n              onApplySort={handleApplySmartSort}\n              onRemoveDuplicates={handleRemoveDuplicates}\n            />\n          </div>\n        ) : null\n      }\n      actions={\n        <div className=\"space-y-4\">\n          <Button\n            onClick={handleMerge}\n            disabled={isProcessing || files.length < 2}\n            className=\"w-full text-lg py-6 shadow-lg shadow-ocean-500/20 bg-ocean-500 hover:bg-ocean-600 text-white\"\n            size=\"lg\"\n          >\n            {t('merge.mergeButton')}\n          </Button>\n          {files.length > 0 && files.length < 2 && (\n            <p className=\"text-sm text-center text-gray-500 animate-pulse\">\n              {t('merge.minFilesHint')}\n            </p>\n          )}\n        </div>\n      }\n    >\n      {/* Files List */}\n      <div className=\"grid grid-cols-2 lg:grid-cols-3 gap-6\">\n        {files.map((file, index) => (\n          <div\n            key={file.id}\n            draggable={!isProcessing}\n            onDragStart={() => handleDragStart(index)}\n            onDragOver={(e) => handleDragOver(e, index)}\n            onDragEnd={handleDragEnd}\n            className={`relative group ${!isProcessing ? 'cursor-move' : ''} ${draggedIndex === index ? 'opacity-50' : ''\n              }`}\n          >\n            <Card className=\"p-4 hover:shadow-medium transition-all duration-200 relative group h-full border-transparent hover:border-ocean-200 dark:hover:border-ocean-800 bg-white dark:bg-privacy-800\">\n              <div className=\"mb-4 flex justify-center bg-gray-50 dark:bg-gray-900 rounded-lg p-4\">\n                <PDFPreview file={file.file} width={180} height={240} />\n              </div>\n\n              {/* Drag Handle & Info */}\n              <div className=\"space-y-3\">\n                <div className=\"flex items-center justify-between\">\n                  <Badge variant=\"secondary\" className=\"w-8 h-8 p-0 flex items-center justify-center bg-white dark:bg-gray-700 shadow-sm text-sm\">\n                    {index + 1}\n                  </Badge>\n                  {file.info && (\n                    <span className=\"text-sm text-gray-500 font-medium\">{file.info.pages} pages</span>\n                  )}\n                </div>\n                <p className=\"text-sm font-medium truncate text-gray-900 dark:text-gray-100\" title={file.name}>\n                  {file.name}\n                </p>\n              </div>\n\n              {/* Hover Actions */}\n              {!isProcessing && (\n                <div className=\"absolute top-2 right-2 flex flex-col gap-1 opacity-0 group-hover:opacity-100 transition-opacity bg-white/90 dark:bg-black/50 rounded-lg p-1 backdrop-blur-sm shadow-sm\">\n                  <Button\n                    size=\"icon\"\n                    variant=\"ghost\"\n                    className=\"h-6 w-6 text-red-500 hover:text-red-600 hover:bg-red-50 dark:hover:bg-red-900/30\"\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      handleRemoveFile(file.id);\n                    }}\n                  >\n                    <span className=\"sr-only\">Remove</span>\n                    <Scissors className=\"h-3 w-3\" />\n                  </Button>\n                </div>\n              )}\n            </Card>\n          </div>\n        ))}\n\n        {/* Add More Button */}\n        <div className=\"h-full min-h-[200px]\">\n          <label className=\"cursor-pointer h-full border-2 border-dashed border-gray-200 dark:border-privacy-700 hover:border-ocean-400 dark:hover:border-ocean-500 rounded-xl flex flex-col items-center justify-center p-4 transition-all hover:bg-ocean-50/50 dark:hover:bg-ocean-900/10 group\">\n            <input\n              type=\"file\"\n              multiple\n              accept=\".pdf\"\n              className=\"hidden\"\n              onChange={(e) => e.target.files && handleFilesSelected(Array.from(e.target.files), false)}\n            />\n            <div className=\"w-12 h-12 rounded-full bg-ocean-100 dark:bg-ocean-900/50 flex items-center justify-center mb-2 text-ocean-600 dark:text-ocean-400 text-2xl group-hover:scale-110 transition-transform\">\n              <Files className=\"h-6 w-6\" />\n            </div>\n            <span className=\"text-sm font-medium text-gray-600 dark:text-gray-400\">Add File</span>\n          </label>\n        </div>\n      </div>\n\n      {isProcessing && (\n        <div className=\"mt-8\">\n          <ProgressBar progress={progress} message={progressMessage} />\n        </div>\n      )}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/OCRPDF.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'handleFilesSelected' and 't'. Either include them or remove the dependency array.","line":93,"column":6,"nodeType":"ArrayExpression","endLine":93,"endColumn":41,"suggestions":[{"desc":"Update the dependencies array to be: [sharedFile, file, clearSharedFile, handleFilesSelected, t]","fix":{"range":[4250,4285],"text":"[sharedFile, file, clearSharedFile, handleFilesSelected, t]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":171,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7002,7005],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7002,7005],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":213,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8290,8293],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8290,8293],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":491,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":491,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18589,18592],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18589,18592],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":509,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":509,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19918,19921],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19918,19921],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport { FileUpload } from '@/components/common/FileUpload';\nimport { useI18n } from '@/hooks/useI18n';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport pdfjsWorker from 'pdfjs-dist/build/pdf.worker.min.mjs?url';\nimport { detectLanguageAdvanced, type LanguageDetectionResult } from '@/utils/languageDetector';\nimport { QuickOCR } from '@/utils/quickOCR';\nimport { OCRWorkerManager } from '@/utils/ocrWorkerManager';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Textarea } from '@/components/ui/textarea';\nimport { Label } from '@/components/ui/label';\nimport { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { FileText, Image as ImageIcon, Download, Copy, RefreshCw, Eye, Edit } from 'lucide-react';\nimport { ProgressBar } from '@/components/common/ProgressBar';\n\n// Configure PDF.js worker\npdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorker;\n\nconst DEFAULT_LANGUAGE = 'eng';\n\ninterface OCRResult {\n  text: string;\n  confidence: number;\n  language: string;\n  pagesProcessed: number;\n  hocr?: string; // hOCR format (HTML with text positioning)\n  tsv?: string;  // TSV format (tab-separated values)\n}\n\ntype PageSelectionMode = 'all' | 'range' | 'first';\ntype OutputFormat = 'text' | 'searchable-pdf' | 'hocr' | 'tsv';\n\n// Supported languages for OCR\nconst SUPPORTED_LANGUAGES = [\n  // Major European languages\n  { code: 'eng', name: 'English', nativeName: 'English' },\n  { code: 'rus', name: 'Russian', nativeName: '–†—É—Å—Å–∫–∏–π' },\n  { code: 'deu', name: 'German', nativeName: 'Deutsch' },\n  { code: 'fra', name: 'French', nativeName: 'Fran√ßais' },\n  { code: 'spa', name: 'Spanish', nativeName: 'Espa√±ol' },\n  { code: 'ita', name: 'Italian', nativeName: 'Italiano' },\n  // ... (keeping list concise for brevity, full list in original)\n  { code: 'por', name: 'Portuguese', nativeName: 'Portugu√™s' },\n  { code: 'pol', name: 'Polish', nativeName: 'Polski' },\n  { code: 'ukr', name: 'Ukrainian', nativeName: '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞' },\n  { code: 'bel', name: 'Belarusian', nativeName: '–ë–µ–ª–∞—Ä—É—Å–∫–∞—è' },\n  { code: 'nld', name: 'Dutch', nativeName: 'Nederlands' },\n];\n\nexport const OCRPDF: React.FC = () => {\n  const { t } = useI18n();\n  const { sharedFile, clearSharedFile } = useSharedFile();\n  const [file, setFile] = useState<File | null>(null);\n  const [totalPages, setTotalPages] = useState<number>(1);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [progressMessage, setProgressMessage] = useState('');\n  const [result, setResult] = useState<OCRResult | null>(null);\n  const [selectedLanguage, setSelectedLanguage] = useState<string>(DEFAULT_LANGUAGE);\n  const [autoDetectLanguage, setAutoDetectLanguage] = useState(true);\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n  const [languageDetection, setLanguageDetection] = useState<LanguageDetectionResult | null>(null);\n  const [previewUrl, setPreviewUrl] = useState<string | null>(null);\n  const [pageMode, setPageMode] = useState<PageSelectionMode>('all');\n  const [pageRange, setPageRange] = useState({ start: 1, end: 1 });\n  const [outputFormat, setOutputFormat] = useState<OutputFormat>('text');\n  const [editedText, setEditedText] = useState<string>('');\n  const [isEditMode, setIsEditMode] = useState(false);\n\n  // Auto-load shared file from WelcomeScreen\n  useEffect(() => {\n    if (sharedFile && !file) {\n      const loadedFile = new File([sharedFile.blob], sharedFile.name, {\n        type: sharedFile.blob.type,\n      });\n\n      // Check if file type is supported by OCR\n      const fileExt = loadedFile.name.toLowerCase().split('.').pop();\n      const supportedExtensions = ['pdf', 'jpg', 'jpeg', 'png'];\n\n      if (fileExt && supportedExtensions.includes(fileExt)) {\n        handleFilesSelected([loadedFile]);\n      } else {\n        alert(t('ocr.errors.unsupportedFileType').replace('{ext}', fileExt || 'unknown'));\n      }\n\n      clearSharedFile();\n    }\n  }, [sharedFile, file, clearSharedFile]);\n\n  // Cleanup preview URL\n  useEffect(() => {\n    return () => {\n      if (previewUrl) {\n        URL.revokeObjectURL(previewUrl);\n      }\n    };\n  }, [previewUrl]);\n\n  // Advanced language detection using new utilities\n  const performLanguageDetection = async (file: File): Promise<void> => {\n    setIsAnalyzing(true);\n    try {\n      // Step 1: Filename-based detection\n      const filenameDetection = detectLanguageAdvanced(file.name);\n      setLanguageDetection(filenameDetection);\n      setSelectedLanguage(filenameDetection.language);\n\n      // Step 2: Content analysis for better detection (especially for images)\n      const shouldAnalyzeContent = file.type.startsWith('image/') ||\n        (file.type === 'application/pdf' && filenameDetection.confidence !== 'high');\n\n      if (shouldAnalyzeContent && autoDetectLanguage) {\n        setProgressMessage(t('ocr.analyzingContent'));\n        const contentDetection = await QuickOCR.quickAnalyzeForLanguage(file);\n\n        // For images, prefer content detection over filename\n        const shouldUseContentDetection = file.type.startsWith('image/') ||\n          contentDetection.confidence === 'high' ||\n          (contentDetection.confidence === 'medium' && filenameDetection.confidence === 'low');\n\n        if (shouldUseContentDetection) {\n          setLanguageDetection(contentDetection);\n          setSelectedLanguage(contentDetection.language);\n        }\n      }\n    } catch (error) {\n      console.error('Language detection failed:', error);\n    } finally {\n      setIsAnalyzing(false);\n      setProgressMessage('');\n    }\n  };\n\n  const handleFilesSelected = async (selectedFiles: File[]) => {\n    const selectedFile = selectedFiles[0];\n    if (!selectedFile) return;\n\n    setFile(selectedFile);\n    setResult(null);\n\n    // Perform advanced language detection\n    await performLanguageDetection(selectedFile);\n\n    // Get total pages for PDF\n    if (selectedFile.type === 'application/pdf') {\n      try {\n        const arrayBuffer = await selectedFile.arrayBuffer();\n        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\n        const numPages = pdf.numPages;\n        setTotalPages(numPages);\n        setPageRange({ start: 1, end: numPages });\n\n        // Render first page as preview\n        if (numPages > 0) {\n          const page = await pdf.getPage(1);\n          const viewport = page.getViewport({ scale: 1.5 });\n\n          const canvas = document.createElement('canvas');\n          const context = canvas.getContext('2d')!;\n          canvas.height = viewport.height;\n          canvas.width = viewport.width;\n\n          await page.render({\n            canvasContext: context,\n            viewport: viewport,\n          } as any).promise;\n\n          const url = canvas.toDataURL();\n          setPreviewUrl(url);\n        }\n      } catch (error) {\n        console.error('Failed to load PDF:', error);\n      }\n    } else if (selectedFile.type.startsWith('image/')) {\n      setTotalPages(1);\n      setPageRange({ start: 1, end: 1 });\n      const url = URL.createObjectURL(selectedFile);\n      setPreviewUrl(url);\n    }\n  };\n\n  const handleRemoveFile = () => {\n    setFile(null);\n    setResult(null);\n    setPreviewUrl(null);\n    setProgress(0);\n    setProgressMessage('');\n    setTotalPages(1);\n    setPageRange({ start: 1, end: 1 });\n    setLanguageDetection(null);\n    setIsAnalyzing(false);\n  };\n\n  const extractImageFromPDF = async (file: File, pageNum: number): Promise<HTMLCanvasElement> => {\n    const arrayBuffer = await file.arrayBuffer();\n    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\n    const page = await pdf.getPage(pageNum);\n    const viewport = page.getViewport({ scale: 2.0 }); // Higher scale for better OCR\n\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d')!;\n    canvas.height = viewport.height;\n    canvas.width = viewport.width;\n\n    await page.render({\n      canvasContext: context,\n      viewport: viewport,\n    } as any).promise;\n\n    return canvas;\n  };\n\n  const handleOCR = async () => {\n    if (!file) {\n      alert(t('ocr.errors.noFile'));\n      return;\n    }\n\n    setIsProcessing(true);\n    setProgress(0);\n    setResult(null);\n    setProgressMessage(t('ocr.initializing'));\n\n    try {\n      // Determine pages to process\n      let pagesToProcess: number[] = [];\n      if (file.type.startsWith('image/')) {\n        pagesToProcess = [1];\n      } else {\n        if (pageMode === 'first') {\n          pagesToProcess = [1];\n        } else if (pageMode === 'range') {\n          const start = Math.max(1, pageRange.start);\n          const end = Math.min(totalPages, pageRange.end);\n          for (let i = start; i <= end; i++) {\n            pagesToProcess.push(i);\n          }\n        } else { // 'all'\n          for (let i = 1; i <= totalPages; i++) {\n            pagesToProcess.push(i);\n          }\n        }\n      }\n\n      // If user wants searchable PDF, we'll skip text extraction and create it in handleDownload\n      if (outputFormat !== 'searchable-pdf') {\n        setProgressMessage(t('ocr.loadingModel'));\n        const worker = await OCRWorkerManager.getWorker(selectedLanguage);\n\n        let combinedText = '';\n        let combinedHOCR = '';\n        let combinedTSV = '';\n        let totalConfidence = 0;\n\n        // Header for HOCR\n        if (outputFormat === 'hocr') {\n          combinedHOCR = `<!DOCTYPE html><html><head><meta charset=\"utf-8\"/><title>OCR Results</title></head><body>`;\n        }\n        // Header for TSV\n        if (outputFormat === 'tsv') {\n          combinedTSV = 'level\\tpage_num\\tblock_num\\tpar_num\\tline_num\\tword_num\\tleft\\ttop\\twidth\\theight\\tconf\\ttext\\n';\n        }\n\n        // Process each page\n        for (let i = 0; i < pagesToProcess.length; i++) {\n          const pageNum = pagesToProcess[i];\n          const pageProgress = (i / pagesToProcess.length) * 100;\n          setProgressMessage(t('ocr.processingPage', { current: pageNum, total: pagesToProcess.length }));\n          setProgress(Math.round(pageProgress));\n\n          let imageToProcess: string | HTMLCanvasElement;\n\n          if (file.type.startsWith('image/')) {\n            imageToProcess = URL.createObjectURL(file);\n          } else {\n            const canvas = await extractImageFromPDF(file, pageNum);\n            imageToProcess = canvas;\n          }\n\n          const { data } = await worker.recognize(imageToProcess);\n\n          if (outputFormat === 'text') {\n            if (i > 0) {\n              combinedText += '\\n\\n' + '='.repeat(50) + '\\n';\n              combinedText += `Page ${pageNum}\\n`;\n              combinedText += '='.repeat(50) + '\\n\\n';\n            }\n            combinedText += data.text;\n          } else if (outputFormat === 'hocr') {\n            const hocrData = data.hocr;\n            if (hocrData) {\n              // Simplified extraction, usually just append body content\n              combinedHOCR += `\\n<div class=\"ocr_page\" id=\"page_${pageNum}\">\\n${hocrData}\\n</div>\\n`;\n            }\n          } else if (outputFormat === 'tsv') {\n            const tsvData = data.tsv;\n            if (tsvData) {\n              const lines = tsvData.split('\\n');\n              const contentLines = i === 0 ? lines.slice(1) : lines.slice(1); // skip header\n              combinedTSV += contentLines.join('\\n') + '\\n';\n            }\n          }\n\n          totalConfidence += data.confidence;\n        }\n\n        if (outputFormat === 'hocr') combinedHOCR += '</body></html>';\n\n        const avgConfidence = totalConfidence / pagesToProcess.length;\n\n        const ocrResult: OCRResult = {\n          text: outputFormat === 'text' ? combinedText : '',\n          confidence: avgConfidence,\n          language: selectedLanguage,\n          pagesProcessed: pagesToProcess.length,\n          hocr: outputFormat === 'hocr' ? combinedHOCR : undefined,\n          tsv: outputFormat === 'tsv' ? combinedTSV : undefined,\n        };\n\n        setResult(ocrResult);\n        setEditedText(combinedText);\n        setIsEditMode(false);\n        setProgress(100);\n        setProgressMessage(t('ocr.completed'));\n\n      } else {\n        // Searchable PDF placeholder result\n        setResult({\n          text: '',\n          confidence: 0,\n          language: selectedLanguage,\n          pagesProcessed: pagesToProcess.length,\n        });\n        setProgress(100);\n        setProgressMessage(t('ocr.download.searchablePdfReady'));\n      }\n    } catch (error) {\n      console.error('OCR error:', error);\n      alert(t('ocr.errors.processingFailed'));\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleCopyText = () => {\n    const textToCopy = editedText || result?.text;\n    if (textToCopy) {\n      navigator.clipboard.writeText(textToCopy);\n      alert(t('ocr.textCopied'));\n    }\n  };\n\n  const handleDownload = async () => {\n    if (!result || !file) return;\n\n    const baseName = file.name.replace(/\\.[^.]+$/, '');\n\n    try {\n      if (outputFormat === 'hocr') {\n        const blob = new Blob([result.hocr || ''], { type: 'text/html;charset=utf-8' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `${baseName}_ocr.html`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n      } else if (outputFormat === 'tsv') {\n        const blob = new Blob([result.tsv || ''], { type: 'text/tab-separated-values;charset=utf-8' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `${baseName}_ocr.tsv`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n      } else if (outputFormat === 'text') {\n        const textToDownload = editedText || result.text;\n        const blob = new Blob([textToDownload], { type: 'text/plain;charset=utf-8' });\n        const url = URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `${baseName}_ocr.txt`;\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n        URL.revokeObjectURL(url);\n      } else if (outputFormat === 'searchable-pdf') {\n        setIsProcessing(true);\n        setProgress(0);\n\n        try {\n          const { createSearchablePDF, createSearchablePDFFromImage } = await import('@/utils/searchablePDFGenerator');\n\n          // Logic to generate searchable PDF (reused from original)\n          let pagesToProcess: number[] = [];\n          // ... (simplified reconstruction of page logic for brevity, assuming 'range' or 'all')\n          if (file.type.startsWith('image/')) {\n            pagesToProcess = [1];\n          } else {\n            if (pageMode === 'first') pagesToProcess = [1];\n            else if (pageMode === 'range') {\n              const s = Math.max(1, pageRange.start);\n              const e = Math.min(totalPages, pageRange.end);\n              for (let i = s; i <= e; i++) pagesToProcess.push(i);\n            } else {\n              for (let i = 1; i <= totalPages; i++) pagesToProcess.push(i);\n            }\n          }\n\n          let pdfBlob: Blob;\n          if (file.type.startsWith('image/')) {\n            pdfBlob = await createSearchablePDFFromImage(file, selectedLanguage, (p, m) => { setProgress(p); setProgressMessage(m); });\n          } else {\n            pdfBlob = await createSearchablePDF(file, selectedLanguage, pagesToProcess, (p, m) => { setProgress(p); setProgressMessage(m); });\n          }\n\n          const url = URL.createObjectURL(pdfBlob);\n          const a = document.createElement('a');\n          a.href = url;\n          a.download = `${baseName}_searchable.pdf`;\n          document.body.appendChild(a);\n          a.click();\n          document.body.removeChild(a);\n          URL.revokeObjectURL(url);\n        } catch (e) {\n          console.error(e);\n          alert('Failed to generate PDF');\n        } finally {\n          setIsProcessing(false);\n        }\n      }\n    } catch (error) {\n      console.error('Download failed:', error);\n    }\n  };\n\n\n  return (\n    <ToolLayout\n      title={t('tools.ocr-pdf.name')}\n      description={t('tools.ocr-pdf.description')}\n      hasFiles={!!file}\n      isProcessing={isProcessing}\n      onUpload={handleFilesSelected}\n      uploadContent={\n        <FileUpload\n          onFilesSelected={handleFilesSelected}\n          accept=\".pdf,.jpg,.jpeg,.png\"\n          maxFiles={1}\n          maxSizeMB={50}\n          multiple={false}\n          title={t('common.selectFile')}\n          description={t('upload.singleFileAllowed')}\n        />\n      }\n      settings={\n        <div className=\"space-y-6\">\n          {/* Language Selection */}\n          <div className=\"space-y-3\">\n            <Label className=\"text-base font-semibold\">Language</Label>\n            {languageDetection && !isAnalyzing && (\n              <div className={`p-3 rounded-lg border text-xs ${languageDetection.confidence === 'high' ? 'bg-green-50 border-green-200 text-green-800' : 'bg-yellow-50 border-yellow-200 text-yellow-800'\n                }`}>\n                Detected: {languageDetection.language} ({languageDetection.confidence})\n              </div>\n            )}\n            <label className=\"flex items-center space-x-2 text-sm\">\n              <input type=\"checkbox\" checked={autoDetectLanguage} onChange={e => setAutoDetectLanguage(e.target.checked)} className=\"rounded text-ocean-600\" />\n              <span>Auto-detect</span>\n            </label>\n            <Select value={selectedLanguage} onValueChange={setSelectedLanguage} disabled={isProcessing || autoDetectLanguage}>\n              <SelectTrigger><SelectValue /></SelectTrigger>\n              <SelectContent>\n                {SUPPORTED_LANGUAGES.map(l => <SelectItem key={l.code} value={l.code}>{l.name}</SelectItem>)}\n              </SelectContent>\n            </Select>\n          </div>\n\n          {/* Page Range */}\n          {totalPages > 1 && (\n            <div className=\"space-y-3 pt-4 border-t border-gray-100 dark:border-gray-800\">\n              <Label className=\"text-base font-semibold\">Pages</Label>\n              <RadioGroup value={pageMode} onValueChange={(v) => setPageMode(v as any)}>\n                <div className=\"flex items-center space-x-2\"><RadioGroupItem value=\"all\" id=\"r-all\" /><Label htmlFor=\"r-all\">All ({totalPages})</Label></div>\n                <div className=\"flex items-center space-x-2\"><RadioGroupItem value=\"first\" id=\"r-first\" /><Label htmlFor=\"r-first\">First Page</Label></div>\n                <div className=\"flex items-center space-x-2\"><RadioGroupItem value=\"range\" id=\"r-range\" /><Label htmlFor=\"r-range\">Range</Label></div>\n              </RadioGroup>\n              {pageMode === 'range' && (\n                <div className=\"flex items-center gap-2\">\n                  <input type=\"number\" className=\"w-16 p-1 border rounded\" value={pageRange.start} onChange={e => setPageRange({ ...pageRange, start: +e.target.value })} />\n                  <span>-</span>\n                  <input type=\"number\" className=\"w-16 p-1 border rounded\" value={pageRange.end} onChange={e => setPageRange({ ...pageRange, end: +e.target.value })} />\n                </div>\n              )}\n            </div>\n          )}\n\n          {/* Output Format */}\n          <div className=\"space-y-3 pt-4 border-t border-gray-100 dark:border-gray-800\">\n            <Label className=\"text-base font-semibold\">Output Format</Label>\n            <Select value={outputFormat} onValueChange={(v) => setOutputFormat(v as any)}>\n              <SelectTrigger><SelectValue /></SelectTrigger>\n              <SelectContent>\n                <SelectItem value=\"text\">Text (Editable)</SelectItem>\n                <SelectItem value=\"searchable-pdf\">Searchable PDF</SelectItem>\n                <SelectItem value=\"hocr\">hOCR (HTML)</SelectItem>\n                <SelectItem value=\"tsv\">TSV (Data)</SelectItem>\n              </SelectContent>\n            </Select>\n          </div>\n        </div>\n      }\n      actions={\n        <div className=\"space-y-3\">\n          {!result ? (\n            <Button onClick={handleOCR} disabled={isProcessing || isAnalyzing} size=\"lg\" className=\"w-full bg-ocean-600 hover:bg-ocean-700 text-white shadow-lg shadow-ocean-500/20\">\n              {isProcessing ? 'Processing...' : 'Start OCR'}\n            </Button>\n          ) : (\n            <div className=\"space-y-3\">\n              <Button onClick={handleDownload} size=\"lg\" className=\"w-full bg-green-600 hover:bg-green-700 text-white shadow-lg shadow-green-500/20\">\n                <Download className=\"mr-2 h-4 w-4\" /> Download\n              </Button>\n              {outputFormat === 'text' && (\n                <Button onClick={handleCopyText} variant=\"outline\" className=\"w-full\">\n                  <Copy className=\"mr-2 h-4 w-4\" /> Copy Text\n                </Button>\n              )}\n              <Button onClick={() => setResult(null)} variant=\"ghost\" className=\"w-full\">\n                <RefreshCw className=\"mr-2 h-4 w-4\" /> Start Over\n              </Button>\n            </div>\n          )}\n          {file && !result && (\n            <Button onClick={handleRemoveFile} variant=\"ghost\" className=\"w-full text-red-500 hover:text-red-600 hover:bg-red-50\">\n              Remove File\n            </Button>\n          )}\n        </div>\n      }\n    >\n      {/* MAIN CONTENT AREA */}\n      <div className=\"min-h-[400px]\">\n        {/* Progress Bar included in layout via isProcessing prop? No, ToolLayout doesn't show bar automatically in main area, only loader in button. We can add one here. */}\n        {isProcessing && (\n          <div className=\"mb-6\">\n            <ProgressBar progress={progress} message={progressMessage} />\n          </div>\n        )}\n\n        {/* If NO Result: Show Preview */}\n        {!result && file && (\n          <Card className=\"h-full border-2 border-dashed border-gray-100 dark:border-gray-800 bg-gray-50/50 dark:bg-black/20\">\n            <CardContent className=\"p-8 flex items-center justify-center min-h-[400px]\">\n              {previewUrl ? (\n                <img src={previewUrl} alt=\"Preview\" className=\"max-w-full max-h-[500px] shadow-2xl rounded-lg transform transition-transform hover:scale-[1.01] duration-300\" />\n              ) : (\n                <div className=\"text-center text-gray-400\">\n                  <FileText className=\"w-24 h-24 mx-auto mb-4 opacity-50\" />\n                  <p>Loading Preview...</p>\n                </div>\n              )}\n            </CardContent>\n          </Card>\n        )}\n\n        {/* If Result: Show Result Editor/Viewer */}\n        {result && (\n          <Card className=\"h-full bg-white dark:bg-gray-900 shadow-sm border-ocean-100 dark:border-ocean-900/30\">\n            <CardContent className=\"p-0\">\n              {/* Result Header */}\n              <div className=\"p-4 border-b border-gray-100 dark:border-gray-800 flex justify-between items-center bg-gray-50/50 dark:bg-gray-800/50\">\n                <div className=\"flex items-center gap-2\">\n                  {outputFormat === 'text' && <FileText className=\"w-5 h-5 text-ocean-500\" />}\n                  {outputFormat === 'searchable-pdf' && <ImageIcon className=\"w-5 h-5 text-ocean-500\" />}\n                  <span className=\"font-semibold text-gray-700 dark:text-gray-200\">\n                    {outputFormat === 'text' ? 'Extracted Text' : 'Result Ready'}\n                  </span>\n                </div>\n                {outputFormat === 'text' && (\n                  <Button size=\"sm\" variant=\"ghost\" onClick={() => setIsEditMode(!isEditMode)}>\n                    {isEditMode ? <Eye className=\"w-4 h-4 mr-1\" /> : <Edit className=\"w-4 h-4 mr-1\" />}\n                    {isEditMode ? 'View' : 'Edit'}\n                  </Button>\n                )}\n              </div>\n\n              {/* Content */}\n              <div className=\"p-0\">\n                {outputFormat === 'text' ? (\n                  isEditMode ? (\n                    <Textarea\n                      value={editedText}\n                      onChange={e => setEditedText(e.target.value)}\n                      className=\"w-full h-[500px] border-0 focus:ring-0 rounded-none p-6 font-mono text-sm leading-relaxed resize-none\"\n                    />\n                  ) : (\n                    <div className=\"w-full h-[500px] overflow-auto p-6 bg-white dark:bg-gray-900\">\n                      <pre className=\"whitespace-pre-wrap font-sans text-sm leading-relaxed text-gray-700 dark:text-gray-300\">\n                        {editedText}\n                      </pre>\n                    </div>\n                  )\n                ) : (\n                  <div className=\"h-[400px] flex flex-col items-center justify-center text-center p-8\">\n                    <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/30 rounded-full flex items-center justify-center mb-6 text-green-600 dark:text-green-400 text-4xl animate-bounce\">\n                      ‚úì\n                    </div>\n                    <h3 className=\"text-2xl font-bold mb-2\">Processing Complete!</h3>\n                    <p className=\"text-gray-500 max-w-md mx-auto\">\n                      Your document has been processed successfully. You can now download the result from the sidebar.\n                    </p>\n                  </div>\n                )}\n              </div>\n            </CardContent>\n          </Card>\n        )}\n      </div>\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/PDFToImages.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'QUALITY_SETTINGS' is defined but never used.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1658,1661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1658,1661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":137,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":137,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":142,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4841,4844],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4841,4844],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":149,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":149,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'handleReset' is assigned a value but never used.","line":153,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":153,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":238,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":238,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8846,8849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8846,8849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":250,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9276,9279],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9276,9279],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":253,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":253,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9469,9472],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9469,9472],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":272,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":272,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10198,10201],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10198,10201],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { ProgressBar } from '@/components/common/ProgressBar';\nimport { useI18n } from '@/hooks/useI18n';\nimport pdfService from '@/services/pdfService';\nimport type {\n  ImageConversionOptions,\n  ImageConversionResult,\n  ImageFormat,\n  ImageQuality,\n  QUALITY_SETTINGS\n} from '@/types/image.types';\nimport { Button } from '@/components/ui/button';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Label } from '@/components/ui/label';\nimport { Input } from '@/components/ui/input';\nimport { CheckCircle2, FileText, Download, X } from 'lucide-react';\nimport { Badge } from '@/components/ui/badge';\n\ninterface FileWithResult {\n  file: File;\n  result: ImageConversionResult | null;\n  previews: string[];\n  progress: number;\n  progressMessage: string;\n  isProcessing: boolean;\n}\n\nexport const PDFToImages: React.FC = () => {\n  const { t } = useI18n();\n  const [files, setFiles] = useState<FileWithResult[]>([]);\n  const [isProcessing, setIsProcessing] = useState(false);\n\n  // Conversion options\n  const [format, setFormat] = useState<ImageFormat>('png');\n  const [quality, setQuality] = useState<ImageQuality>('medium');\n  const [pageSelection, setPageSelection] = useState<'all' | 'range' | 'specific'>('all');\n  const [pageRange, setPageRange] = useState({ start: 1, end: 1 });\n  const [specificPages, setSpecificPages] = useState('');\n  const [backgroundColor, setBackgroundColor] = useState('#ffffff');\n\n  // Dynamic quality settings\n  const [qualitySettings, setQualitySettings] = useState<any>(null);\n  React.useEffect(() => {\n    import('@/types/image.types').then(module => {\n      setQualitySettings(module.QUALITY_SETTINGS);\n    });\n  }, []);\n\n  const handleFileSelected = (selectedFiles: File[]) => {\n    const newFiles: FileWithResult[] = selectedFiles.map(file => ({\n      file,\n      result: null,\n      previews: [],\n      progress: 0,\n      progressMessage: '',\n      isProcessing: false\n    }));\n    setFiles(prev => [...prev, ...newFiles]);\n  };\n\n  const handleRemoveFile = (index: number) => {\n    setFiles(prev => prev.filter((_, i) => i !== index));\n  };\n\n  const handleConvert = async () => {\n    if (files.length === 0) return;\n    setIsProcessing(true);\n\n    const options: ImageConversionOptions = {\n      format,\n      quality,\n      pages: pageSelection,\n      backgroundColor: format === 'jpeg' ? backgroundColor : undefined\n    };\n\n    if (pageSelection === 'range') options.pageRange = pageRange;\n    else if (pageSelection === 'specific') {\n      const pageNumbers = specificPages.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p) && p > 0);\n      options.pageNumbers = pageNumbers;\n    }\n\n    for (let i = 0; i < files.length; i++) {\n      const fileItem = files[i];\n      if (fileItem.result) continue; // Skip if already done\n\n      setFiles(prev => prev.map((f, idx) => idx === i ? { ...f, isProcessing: true } : f));\n\n      try {\n        // Mock delay for UI if needed, but pdfToImages is async\n        const conversionResult = await pdfService.pdfToImages(\n          fileItem.file,\n          options,\n          (progressUpdate) => {\n            setFiles(prev => prev.map((f, idx) => idx === i ? {\n              ...f,\n              progress: progressUpdate.percentage,\n              progressMessage: progressUpdate.message || ''\n            } : f));\n          }\n        );\n\n        const previews = conversionResult.success && conversionResult.images.length > 0\n          ? conversionResult.images.slice(0, 5).map(img => img.dataUrl)\n          : [];\n\n        setFiles(prev => prev.map((f, idx) => idx === i ? {\n          ...f,\n          result: conversionResult,\n          previews,\n          isProcessing: false,\n          progress: 100\n        } : f));\n\n      } catch (error) {\n        console.error(error);\n        const errorResult: ImageConversionResult = {\n          success: false, images: [], totalPages: 0, originalSize: fileItem.file.size, convertedSize: 0,\n          error: error instanceof Error ? error.message : t('pdfToImages.errors.conversionFailed')\n        };\n        setFiles(prev => prev.map((f, idx) => idx === i ? {\n          ...f,\n          result: errorResult,\n          isProcessing: false\n        } : f));\n      }\n    }\n    setIsProcessing(false);\n  };\n\n  const handleDownloadZip = async (fileIndex: number) => {\n    const fileItem = files[fileIndex];\n    if (fileItem?.result?.success) {\n      try {\n        const zipFilename = `${fileItem.file.name.replace(/\\.pdf$/i, '')}_images.zip`;\n        await pdfService.downloadImagesAsZip(fileItem.result.images, zipFilename);\n      } catch (e) { alert('Failed to create ZIP'); }\n    }\n  };\n\n  const handleDownloadAllAsZip = async () => {\n    const allImages: any[] = [];\n    files.forEach(f => {\n      if (f.result?.success) allImages.push(...f.result.images);\n    });\n    if (allImages.length) {\n      try {\n        await pdfService.downloadImagesAsZip(allImages, 'all_converted_images.zip');\n      } catch (e) { alert('Failed to create ZIP'); }\n    }\n  };\n\n  const handleReset = () => {\n    setFiles([]);\n    setIsProcessing(false);\n  };\n\n  const formatFileSize = (bytes: number) => {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`;\n  };\n\n  const renderContent = () => {\n    if (files.length === 0) return null;\n\n    return (\n      <div className=\"space-y-4\">\n        {files.map((fileItem, index) => (\n          <div key={index} className=\"p-4 bg-white dark:bg-gray-800 rounded-xl border border-gray-200 dark:border-gray-700 shadow-sm relative overflow-hidden\">\n            <div className=\"flex items-start gap-4\">\n              <div className=\"h-12 w-12 bg-red-100 dark:bg-red-900/30 text-red-600 rounded-lg flex items-center justify-center flex-shrink-0\">\n                <FileText className=\"w-6 h-6\" />\n              </div>\n              <div className=\"flex-1 min-w-0\">\n                <div className=\"flex justify-between items-start\">\n                  <div>\n                    <p className=\"font-semibold text-gray-900 dark:text-white truncate pr-2\">{fileItem.file.name}</p>\n                    <p className=\"text-xs text-gray-500\">{formatFileSize(fileItem.file.size)}</p>\n                  </div>\n                  {!fileItem.result && !fileItem.isProcessing && (\n                    <Button onClick={() => handleRemoveFile(index)} variant=\"ghost\" size=\"icon\" className=\"h-6 w-6 -mt-1 -mr-1\">\n                      <X className=\"w-4 h-4\" />\n                    </Button>\n                  )}\n                </div>\n\n                {fileItem.isProcessing && (\n                  <div className=\"mt-2\">\n                    <ProgressBar progress={fileItem.progress} message={fileItem.progressMessage} />\n                  </div>\n                )}\n\n                {fileItem.result && (\n                  <div className=\"mt-3\">\n                    {fileItem.result.success ? (\n                      <div className=\"space-y-3\">\n                        <Badge variant=\"outline\" className=\"text-green-600 border-green-200 bg-green-50\">\n                          <CheckCircle2 className=\"w-3 h-3 mr-1\" /> {fileItem.result.totalPages} pages converted\n                        </Badge>\n                        <div className=\"flex gap-2 overflow-x-auto pb-2\">\n                          {fileItem.previews.map((src, i) => (\n                            <img key={i} src={src} className=\"h-16 w-auto rounded border shadow-sm\" alt=\"preview\" />\n                          ))}\n                        </div>\n                        <Button onClick={() => handleDownloadZip(index)} size=\"sm\" variant=\"outline\" className=\"w-full sm:w-auto\">\n                          <Download className=\"w-4 h-4 mr-2\" /> Download ZIP\n                        </Button>\n                      </div>\n                    ) : (\n                      <p className=\"text-sm text-red-500\">{fileItem.result.error}</p>\n                    )}\n                  </div>\n                )}\n              </div>\n            </div>\n          </div>\n        ))}\n\n        {files.some(f => f.result?.success) && (\n          <div className=\"pt-4 border-t\">\n            <Button onClick={handleDownloadAllAsZip} className=\"w-full bg-green-600 hover:bg-green-700\">\n              <Download className=\"w-4 h-4 mr-2\" /> Download Everything (ZIP)\n            </Button>\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  const renderSettings = () => (\n    <div className=\"space-y-6\">\n      {/* Format */}\n      <div className=\"space-y-2\">\n        <Label>{t('pdfToImages.format')}</Label>\n        <Select value={format} onValueChange={(v: any) => setFormat(v)}>\n          <SelectTrigger><SelectValue /></SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"png\">PNG</SelectItem>\n            <SelectItem value=\"jpeg\">JPEG</SelectItem>\n          </SelectContent>\n        </Select>\n      </div>\n\n      {/* Quality */}\n      <div className=\"space-y-2\">\n        <Label>{t('pdfToImages.quality')}</Label>\n        <Select value={quality} onValueChange={(v: any) => setQuality(v)}>\n          <SelectTrigger><SelectValue /></SelectTrigger>\n          <SelectContent>\n            {qualitySettings && Object.entries(qualitySettings).map(([key, settings]: any) => (\n              <SelectItem key={key} value={key}>\n                {key.charAt(0).toUpperCase() + key.slice(1)} ({settings.resolution} DPI)\n              </SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n      </div>\n\n      {/* Page Selection */}\n      <div className=\"space-y-3 border-t pt-4\">\n        <Label>{t('pdfToImages.pages')}</Label>\n        <div className=\"space-y-2\">\n          {['all', 'range', 'specific'].map((mode) => (\n            <div key={mode} className=\"flex items-center space-x-2\">\n              <input\n                type=\"radio\"\n                id={`page-${mode}`}\n                checked={pageSelection === mode}\n                onChange={() => setPageSelection(mode as any)}\n                className=\"text-ocean-600 focus:ring-ocean-500\"\n              />\n              <Label htmlFor={`page-${mode}`} className=\"cursor-pointer\">{t(`pdfToImages.${mode === 'range' ? 'pageRange' : mode === 'specific' ? 'specificPages' : 'allPages'}`)}</Label>\n            </div>\n          ))}\n        </div>\n\n        {pageSelection === 'range' && (\n          <div className=\"flex gap-2\">\n            <Input type=\"number\" min={1} value={pageRange.start} onChange={(e) => setPageRange(p => ({ ...p, start: parseInt(e.target.value) || 1 }))} placeholder=\"From\" />\n            <span className=\"self-center\">-</span>\n            <Input type=\"number\" min={1} value={pageRange.end} onChange={(e) => setPageRange(p => ({ ...p, end: parseInt(e.target.value) || 1 }))} placeholder=\"To\" />\n          </div>\n        )}\n        {pageSelection === 'specific' && (\n          <Input placeholder=\"e.g. 1, 3, 5-10\" value={specificPages} onChange={(e) => setSpecificPages(e.target.value)} />\n        )}\n      </div>\n\n      {/* JPEG Background */}\n      {format === 'jpeg' && (\n        <div className=\"space-y-2 border-t pt-4\">\n          <Label>{t('pdfToImages.backgroundColor')}</Label>\n          <div className=\"flex items-center gap-2\">\n            <Input type=\"color\" value={backgroundColor} onChange={(e) => setBackgroundColor(e.target.value)} className=\"w-10 h-10 p-1\" />\n            <span className=\"text-sm text-gray-500\">{backgroundColor}</span>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n\n  const renderActions = () => (\n    <Button\n      onClick={handleConvert}\n      disabled={isProcessing || !files.some(f => !f.result)}\n      className=\"w-full py-6 text-lg font-bold\"\n    >\n      {isProcessing ? t('common.processing') : t('common.convert')}\n    </Button>\n  );\n\n  return (\n    <ToolLayout\n      title={t('tools.pdf-to-images.name')}\n      description={t('tools.pdf-to-images.description')}\n      hasFiles={files.length > 0}\n      onUpload={handleFileSelected}\n      isProcessing={isProcessing}\n      maxFiles={20}\n      uploadTitle={t('common.selectFile')}\n      uploadDescription={t('upload.multipleFilesAllowed')}\n      accept=\".pdf\"\n      settings={files.length > 0 ? renderSettings() : null}\n      actions={files.length > 0 ? renderActions() : null}\n    >\n      {renderContent()}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/PDFToWord.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/PageEditorPDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'progress' is assigned a value but never used.","line":211,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":211,"endColumn":18}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'pages.length'. Either include it or remove the dependency array.","line":257,"column":6,"nodeType":"ArrayExpression","endLine":257,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [pages.length, thumbnails]","fix":{"range":[8888,8900],"text":"[pages.length, thumbnails]"}}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleFileUpload'. Either include it or remove the dependency array.","line":294,"column":6,"nodeType":"ArrayExpression","endLine":294,"endColumn":49,"suggestions":[{"desc":"Update the dependencies array to be: [sharedFile, file, result, clearSharedFile, handleFileUpload]","fix":{"range":[9983,10026],"text":"[sharedFile, file, result, clearSharedFile, handleFileUpload]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport {\n  DndContext,\n  closestCenter,\n  KeyboardSensor,\n  PointerSensor,\n  useSensor,\n  useSensors,\n  type DragEndEvent,\n} from '@dnd-kit/core';\nimport {\n  arrayMove,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  verticalListSortingStrategy,\n  useSortable,\n} from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { Button } from '@/components/ui/button';\nimport { Card } from '@/components/ui/card';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport { usePDFThumbnails, type PageThumbnail } from '@/hooks/usePDFThumbnails';\nimport pdfService from '@/services/pdfService';\nimport { SmartOrganizePanel } from '@/components/smart/SmartOrganizePanel';\nimport type { UploadedFile } from '@/types/pdf';\nimport type { Tool } from '@/types';\nimport { HASH_TOOL_MAP } from '@/types';\nimport { toast } from 'sonner';\nimport {\n  RotateCw,\n  Trash2,\n  Download,\n  RefreshCcw,\n  CheckCircle2,\n  Minimize2,\n  Shield,\n  ZoomIn,\n  X,\n  CheckSquare,\n  Square,\n  Square,\n  Plus\n} from 'lucide-react';\n\ninterface PageItem extends PageThumbnail {\n  id: string;\n  rotation: number; // 0, 90, 180, 270\n  isDeleted: boolean;\n  sourceFile?: File; // Optional: if provided, page comes from this file\n}\n\n// Sortable page thumbnail component\nconst SortablePage: React.FC<{\n  page: PageItem;\n  isSelected: boolean;\n  onToggleSelection: (id: string) => void;\n  onRotate: (id: string) => void;\n  onDelete: (id: string) => void;\n  onRestore: (id: string) => void;\n  onZoom: (pageNumber: number) => void;\n}> = ({ page, isSelected, onToggleSelection, onRotate, onDelete, onRestore, onZoom }) => {\n  const { t } = useI18n();\n  const {\n    attributes,\n    listeners,\n    setNodeRef,\n    transform,\n    transition,\n    isDragging,\n  } = useSortable({ id: page.id, disabled: page.isDeleted });\n\n  const style = {\n    transform: CSS.Transform.toString(transform),\n    transition,\n    opacity: isDragging ? 0.5 : page.isDeleted ? 0.4 : 1,\n  };\n\n  return (\n    <div\n      ref={setNodeRef}\n      style={style}\n      className={`relative group ${page.isDeleted ? 'grayscale' : ''}`}\n    >\n      <Card\n        className={`p-2 hover:shadow-lg transition-all bg-white dark:bg-gray-800 border-2 ${isSelected\n          ? 'border-ocean-500 shadow-md ring-1 ring-ocean-500/20'\n          : 'border-transparent hover:border-gray-200 dark:hover:border-gray-700'\n          }`}\n        onClick={(e) => {\n          // If clicking the card background, toggle selection\n          if (e.target === e.currentTarget || (e.target as HTMLElement).closest('.thumbnail-container')) {\n            onToggleSelection(page.id);\n          }\n        }}\n      >\n        {/* Selection Checkbox */}\n        {!page.isDeleted && (\n          <div className=\"absolute top-3 left-3 z-10\">\n            <Checkbox\n              checked={isSelected}\n              onCheckedChange={() => onToggleSelection(page.id)}\n              className={`bg-white/90 backdrop-blur-sm data-[state=checked]:bg-ocean-500 border-gray-300 dark:border-gray-600 ${isSelected ? 'opacity-100' : 'opacity-0 group-hover:opacity-100 transition-opacity'}`}\n            />\n          </div>\n        )}\n\n        {/* Drag handle */}\n        <div\n          {...attributes}\n          {...listeners}\n          className={`cursor-move mb-2 text-center text-xs font-medium text-gray-500 dark:text-gray-400 ${page.isDeleted ? 'cursor-not-allowed' : ''\n            }`}\n        >\n          {page.pageNumber}\n        </div>\n\n        {/* Thumbnail */}\n        <div\n          className=\"thumbnail-container relative aspect-[1/1.4] bg-gray-100 dark:bg-gray-900 rounded overflow-hidden flex items-center justify-center group/image cursor-pointer\"\n          onClick={() => !page.isDeleted && onToggleSelection(page.id)}\n        >\n          {page.dataUrl ? (\n            <>\n              <img\n                src={page.dataUrl}\n                alt={`Page ${page.pageNumber}`}\n                className=\"w-full h-full object-contain select-none\"\n                style={{\n                  transform: `rotate(${page.rotation}deg)`,\n                  transition: 'transform 0.3s ease',\n                }}\n              />\n\n              {/* Zoom Icon */}\n              {!page.isDeleted && (\n                <button\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    onZoom(page.pageNumber);\n                  }}\n                  className=\"absolute top-2 right-2 p-1.5 bg-black/50 hover:bg-black/70 rounded-full text-white opacity-0 group-hover/image:opacity-100 transition-opacity\"\n                  title={t('common.zoom')}\n                >\n                  <ZoomIn className=\"w-4 h-4\" />\n                </button>\n              )}\n            </>\n          ) : (\n            <div className=\"animate-pulse bg-gray-200 dark:bg-gray-800 w-full h-full\" />\n          )}\n\n          {page.isDeleted && (\n            <div className=\"absolute inset-0 flex items-center justify-center bg-black/50 backdrop-blur-[1px]\">\n              <span className=\"text-white text-xs font-bold uppercase tracking-wider\">{t('pageEditor.deleted')}</span>\n            </div>\n          )}\n        </div>\n\n        {/* Action buttons */}\n        <div className=\"flex gap-1 mt-2 opacity-0 group-hover:opacity-100 transition-opacity\">\n          {!page.isDeleted ? (\n            <>\n              <Button\n                size=\"sm\"\n                variant=\"outline\"\n                onClick={(e) => { e.stopPropagation(); onRotate(page.id); }}\n                className=\"flex-1 h-7 text-xs px-0\"\n                title={t('pageEditor.rotate90')}\n              >\n                <RotateCw className=\"w-3 h-3\" />\n              </Button>\n              <Button\n                size=\"sm\"\n                variant=\"outline\"\n                onClick={(e) => { e.stopPropagation(); onDelete(page.id); }}\n                className=\"flex-1 h-7 text-xs px-0 text-red-600 hover:text-red-700 hover:bg-red-50 dark:hover:bg-red-900/20\"\n                title={t('pageEditor.deletePage')}\n              >\n                <Trash2 className=\"w-3 h-3\" />\n              </Button>\n            </>\n          ) : (\n            <Button\n              size=\"sm\"\n              variant=\"outline\"\n              onClick={(e) => { e.stopPropagation(); onRestore(page.id); }}\n              className=\"flex-1 h-7 text-xs text-green-600 hover:text-green-700 hover:bg-green-50 dark:hover:bg-green-900/20\"\n              title={t('pageEditor.restorePage')}\n            >\n              <RefreshCcw className=\"w-3 h-3 mr-1\" />\n              {t('pageEditor.restore')}\n            </Button>\n          )}\n        </div>\n      </Card>\n    </div>\n  );\n};\n\nexport const PageEditorPDF: React.FC = () => {\n  const { t } = useI18n();\n  const { sharedFile, clearSharedFile, setSharedFile: saveSharedFile } = useSharedFile();\n  const [file, setFile] = useState<UploadedFile | null>(null);\n  const [pages, setPages] = useState<PageItem[]>([]);\n  const [selectedPages, setSelectedPages] = useState<Set<string>>(new Set());\n\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [progressMessage, setProgressMessage] = useState('');\n  const [result, setResult] = useState<{ blob: Blob; metadata: Record<string, unknown> } | null>(null);\n  const [resultSaved, setResultSaved] = useState(false);\n\n  const fileInputRef = React.useRef<HTMLInputElement>(null);\n\n  const [zoomedPageNumber, setZoomedPageNumber] = useState<number | null>(null);\n  const [zoomedImageSrc, setZoomedImageSrc] = useState<string | null>(null);\n  const [isZoomLoading, setIsZoomLoading] = useState(false);\n\n  // Generate thumbnails\n  const {\n    thumbnails,\n    isLoading: thumbnailsLoading,\n    isLoading: thumbnailsLoading,\n  } = usePDFThumbnails({\n    file: file?.file,\n    thumbnailWidth: 300,\n    thumbnailHeight: 400,\n    onProgress: (current, total) => {\n      const percentage = Math.round((current / total) * 100);\n      setProgress(percentage);\n      setProgressMessage(`${t('common.generatingThumbnails')} ${percentage}%`);\n    },\n  });\n\n  // Convert thumbnails to PageItems\n  useEffect(() => {\n    if (thumbnails.length > 0) {\n      if (pages.length === 0) {\n        const pageItems: PageItem[] = thumbnails.map((thumb) => ({\n          ...thumb,\n          id: `page-${thumb.pageNumber}`,\n          rotation: 0,\n          isDeleted: false,\n        }));\n        setPages(pageItems);\n      } else {\n        setPages(prev => prev.map(p => {\n          const thumb = thumbnails.find(t => t.pageNumber === p.pageNumber);\n          return thumb ? { ...p, dataUrl: thumb.dataUrl } : p;\n        }));\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [thumbnails]);\n\n  // Load zoomed image\n  useEffect(() => {\n    const loadZoomedImage = async () => {\n      if (zoomedPageNumber !== null && file?.file) {\n        setIsZoomLoading(true);\n        setZoomedImageSrc(null);\n        try {\n          // Use a scale of 2 or 3 for high quality zoom\n          const dataUrl = await pdfService.renderPageAsImage(file.file, zoomedPageNumber, 2.5);\n          setZoomedImageSrc(dataUrl);\n        } catch (err) {\n          console.error('Failed to load zoomed image', err);\n          toast.error(t('common.error'));\n        } finally {\n          setIsZoomLoading(false);\n        }\n      } else {\n        setZoomedImageSrc(null);\n      }\n    };\n\n    loadZoomedImage();\n  }, [zoomedPageNumber, file, t]);\n\n  // Auto-load file from shared state\n  useEffect(() => {\n    if (sharedFile && !file && !result) {\n      const sharedFileObj = new File([sharedFile.blob], sharedFile.name, {\n        type: 'application/pdf',\n      });\n\n      handleFileUpload([sharedFileObj]);\n      clearSharedFile();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [sharedFile, file, result, clearSharedFile]);\n\n  // Auto-save result\n  useEffect(() => {\n    if (result?.blob && !isProcessing && !resultSaved) {\n      const fileName = file?.name.replace(/\\.pdf$/i, '_organized.pdf') || 'organized.pdf';\n      saveSharedFile(result.blob, fileName, 'organize-pdf');\n      setResultSaved(true);\n    }\n  }, [result, isProcessing, resultSaved, file?.name, saveSharedFile]);\n\n  // Drag and drop sensors\n  const sensors = useSensors(\n    useSensor(PointerSensor, { activationConstraint: { distance: 5 } }),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    })\n  );\n\n  // Handle drag end\n  const handleDragEnd = (event: DragEndEvent) => {\n    const { active, over } = event;\n\n    if (over && active.id !== over.id) {\n      setPages((items) => {\n        const oldIndex = items.findIndex((item) => item.id === active.id);\n        const newIndex = items.findIndex((item) => item.id === over.id);\n        return arrayMove(items, oldIndex, newIndex);\n      });\n    }\n  };\n\n  // Handle file upload\n  const handleFileUpload = async (files: File[]) => {\n    if (files.length === 0) return;\n\n    const pdfFile = files[0];\n    const uploadedFile: UploadedFile = {\n      id: `${Date.now()}`,\n      file: pdfFile,\n      name: pdfFile.name,\n      size: pdfFile.size,\n      status: 'pending',\n    };\n\n    setFile(uploadedFile);\n    setResult(null);\n    setResultSaved(false);\n    setPages([]);\n    setSelectedPages(new Set());\n    setProgress(0);\n\n    try {\n      const info = await pdfService.getPDFInfo(pdfFile);\n      setFile((prev) => (prev ? { ...prev, info, status: 'completed' } : null));\n    } catch {\n      setFile((prev) =>\n        prev ? { ...prev, status: 'error', error: t('pageEditor.failedRead') } : null\n      );\n      toast.error(t('pageEditor.failedRead'));\n    }\n  };\n\n  // Selection Handlers\n  const handleToggleSelection = (id: string) => {\n    setSelectedPages(prev => {\n      const newSet = new Set(prev);\n      if (newSet.has(id)) {\n        newSet.delete(id);\n      } else {\n        newSet.add(id);\n      }\n      return newSet;\n    });\n  };\n\n  const handleSelectAll = () => {\n    if (selectedPages.size === pages.length) {\n      setSelectedPages(new Set());\n    } else {\n      setSelectedPages(new Set(pages.map(p => p.id)));\n    }\n  };\n\n  const handleSelectOdd = () => {\n    const oddPages = pages.filter(p => p.pageNumber % 2 !== 0).map(p => p.id);\n    setSelectedPages(new Set(oddPages));\n  };\n\n  const handleSelectEven = () => {\n    const evenPages = pages.filter(p => p.pageNumber % 2 === 0).map(p => p.id);\n    setSelectedPages(new Set(evenPages));\n  };\n\n  const handleRotate = (id: string) => {\n    setPages((items) =>\n      items.map((item) =>\n        item.id === id\n          ? { ...item, rotation: (item.rotation + 90) % 360 }\n          : item\n      )\n    );\n  };\n\n  const handleDelete = (id: string) => {\n    setPages((items) =>\n      items.map((item) =>\n        item.id === id ? { ...item, isDeleted: true } : item\n      )\n    );\n    // Remove from selection if deleted\n    setSelectedPages(prev => {\n      const newSet = new Set(prev);\n      newSet.delete(id);\n      return newSet;\n    });\n  };\n\n  const handleRestore = (id: string) => {\n    setPages((items) =>\n      items.map((item) =>\n        item.id === id ? { ...item, isDeleted: false } : item\n      )\n    );\n  };\n\n  const handleSmartDelete = (pageNumbers: number[]) => {\n    setPages((items) =>\n      items.map((item) =>\n        pageNumbers.includes(item.pageNumber) ? { ...item, isDeleted: true } : item\n      )\n    );\n    toast.success(`${pageNumbers.length} page(s) marked for deletion`);\n  };\n\n  const handleSmartRotate = (pageNumbers: number[], rotation: number) => {\n    setPages((items) =>\n      items.map((item) =>\n        pageNumbers.includes(item.pageNumber)\n          ? { ...item, rotation: (item.rotation + rotation) % 360 }\n          : item\n      )\n    );\n    toast.success(`${pageNumbers.length} page(s) rotated`);\n  };\n\n  const handleDeleteSelected = () => {\n    setPages((items) =>\n      items.map((item) =>\n        selectedPages.has(item.id) ? { ...item, isDeleted: true } : item\n      )\n    );\n    setSelectedPages(new Set());\n    toast.success(`${selectedPages.size} ${t('pageEditor.pagesDeleted') || 'pages deleted'}`);\n  };\n\n  const handleExtractSelected = async () => {\n    if (!file?.file || selectedPages.size === 0) return;\n\n    setIsProcessing(true);\n    setProgress(0);\n    setProgressMessage(t('pageEditor.extracting') || 'Extracting pages...');\n\n    try {\n      // Get page numbers from selected IDs\n      const pagesToExtract = pages\n        .filter(p => selectedPages.has(p.id))\n        .map(p => p.pageNumber)\n        .sort((a, b) => a - b);\n\n      const result = await pdfService.splitPDF(\n        file.file,\n        'custom',\n        { pages: pagesToExtract },\n        (prog, msg) => {\n          setProgress(prog);\n          setProgressMessage(msg);\n        }\n      );\n\n      if (result.success && result.data && result.data[0]) {\n        // Download immediately\n        const fileName = file.name.replace(/\\.pdf$/i, '_extracted.pdf');\n        pdfService.downloadFile(result.data[0], fileName);\n        toast.success(t('pageEditor.extractSuccess') || 'Pages extracted successfully');\n      } else {\n        toast.error(t('pageEditor.extractError') || 'Failed to extract pages');\n      }\n    } catch (error) {\n      console.error('Error extracting pages:', error);\n      toast.error(t('pageEditor.extractError') || 'Failed to extract pages');\n    } finally {\n      setIsProcessing(false);\n      setProgress(0);\n      setProgressMessage('');\n    }\n  };\n\n  const handleSmartReorder = (newOrder: number[]) => {\n    setPages((items) => {\n      const itemMap = new Map(items.map(item => [item.pageNumber, item]));\n      const reordered = newOrder\n        .map(pageNum => itemMap.get(pageNum))\n        .filter((item): item is PageItem => item !== undefined);\n      const remaining = items.filter(item => !newOrder.includes(item.pageNumber));\n      return [...reordered, ...remaining];\n    });\n    toast.success('Pages reordered');\n  };\n\n  const handleHighlightPages = (pageNumbers: number[]) => {\n    const idsToSelect = new Set<string>();\n    pages.forEach(p => {\n      if (pageNumbers.includes(p.pageNumber)) {\n        idsToSelect.add(p.id);\n      }\n    });\n    setSelectedPages(idsToSelect);\n    toast.info(`Selected ${pageNumbers.length} pages`);\n  };\n\n  const handleInsertFile = async (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newFile = e.target.files?.[0];\n    if (!newFile) return;\n\n    setIsProcessing(true);\n    setProgress(0);\n    setProgressMessage('Processing new file...');\n\n    try {\n      const pageCount = await pdfService.getPageCount(newFile);\n      // Use lower scale for thumbnails (0.5 is good for visualization)\n      const newThumbnails = await pdfService.getPreviews(newFile, 0.5);\n\n      const newPages: PageItem[] = newThumbnails.map((thumbnail, index) => ({\n        id: crypto.randomUUID(),\n        pageNumber: index + 1, // 1-based index from new file\n        thumbnail,\n        rotation: 0,\n        isDeleted: false,\n        sourceFile: newFile\n      }));\n\n      setPages((prev) => [...prev, ...newPages]);\n      toast.success(`Appended ${pageCount} pages`);\n    } catch (error) {\n      console.error('Error inserting file:', error);\n      toast.error('Failed to insert file');\n    } finally {\n      setIsProcessing(false);\n      setProgress(0);\n      setProgressMessage('');\n      if (fileInputRef.current) {\n        fileInputRef.current.value = '';\n      }\n    }\n  };\n\n  const handleProcess = async () => {\n    if (!file?.file) return;\n    const activePages = pages.filter((p) => !p.isDeleted);\n    if (activePages.length === 0) {\n      toast.error(t('pageEditor.noPages'));\n      return;\n    }\n    setIsProcessing(true);\n    setProgress(0);\n    setProgressMessage('Processing pages...');\n    try {\n      const pageOperations = activePages.map((page) => ({\n        originalPageNumber: page.pageNumber,\n        rotation: page.rotation,\n        sourceFile: page.sourceFile\n      }));\n      const result = await pdfService.organizePDF(\n        file.file,\n        pageOperations,\n        (prog, msg) => {\n          setProgress(prog);\n          setProgressMessage(msg);\n        }\n      );\n      if (result.success && result.data) {\n        setResult({ blob: result.data, metadata: result.metadata || { pageCount: activePages.length } });\n      } else {\n        toast.error(result.error?.message || t('pageEditor.failedOrganize'));\n      }\n    } catch (error) {\n      console.error('Error organizing PDF:', error);\n      toast.error(t('pageEditor.errorOrganize'));\n    } finally {\n      setIsProcessing(false);\n      setProgress(0);\n      setProgressMessage('');\n    }\n  };\n\n  const handleDownload = () => {\n    if (result?.blob) {\n      const fileName = file?.name.replace(/\\.pdf$/i, '_organized.pdf') || 'organized.pdf';\n      pdfService.downloadFile(result.blob, fileName);\n    }\n  };\n\n  const handleReset = () => {\n    setFile(null);\n    setResult(null);\n    setPages([]);\n    setSelectedPages(new Set());\n    setProgress(0);\n    setProgressMessage('');\n    setResultSaved(false);\n  };\n\n  const handleQuickAction = (toolId: Tool) => {\n    if (result?.blob) {\n      saveSharedFile(result.blob, 'organized.pdf', 'organize-pdf');\n    }\n    window.location.hash = HASH_TOOL_MAP[toolId];\n  };\n\n  const hasChanges =\n    pages.length > 0 &&\n    (pages.some((p) => p.rotation !== 0 || p.isDeleted) ||\n      pages.map((p) => p.pageNumber).join(',') !==\n      thumbnails.map((t) => t.pageNumber).join(','));\n\n  const renderContent = () => {\n    if (!file) return null;\n\n    if (thumbnailsLoading && pages.length === 0) {\n      return (\n        <div className=\"flex flex-col items-center justify-center min-h-[400px]\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-ocean-500 mb-4\"></div>\n          <p className=\"text-gray-500\">{progressMessage || t('common.generatingThumbnails')}</p>\n        </div>\n      );\n    }\n\n    if (result) {\n      return (\n        <div className=\"text-center space-y-6 max-w-2xl mx-auto pt-8\">\n          <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/30 rounded-full flex items-center justify-center mx-auto text-green-600\">\n            <CheckCircle2 className=\"w-10 h-10\" />\n          </div>\n          <h2 className=\"text-2xl font-bold\">{t('pageEditor.successOrganized')}</h2>\n          <div className=\"bg-gray-50 dark:bg-gray-800 rounded-lg p-6 max-w-md mx-auto\">\n            <div className=\"flex justify-between text-sm mb-2\">\n              <span className=\"text-gray-500\">{t('common.originalSize')}</span>\n              <span className=\"font-medium\">{pdfService.formatFileSize(file.size)}</span>\n            </div>\n            <div className=\"flex justify-between text-sm\">\n              <span className=\"text-gray-500\">{t('common.pages')}</span>\n              <span className=\"font-medium\">{result.metadata?.pageCount || pages.filter(p => !p.isDeleted).length}</span>\n            </div>\n          </div>\n          <div className=\"flex justify-center gap-4\">\n            <Button onClick={handleDownload} size=\"lg\" className=\"bg-green-600 hover:bg-green-700 shadow-lg shadow-green-500/20\">{t('common.download')}</Button>\n            <Button onClick={handleReset} variant=\"outline\" size=\"lg\">{t('common.convertAnother')}</Button>\n          </div>\n          <div className=\"grid grid-cols-2 gap-4 mt-8\">\n            <Button onClick={() => handleQuickAction('compress-pdf')} variant=\"ghost\" className=\"h-auto py-3 flex flex-col gap-1 border hover:border-ocean-300 hover:bg-ocean-50 dark:hover:bg-ocean-900/10\">\n              <Minimize2 className=\"h-5 w-5 text-ocean-500\" />\n              <span className=\"text-sm font-medium\">{t('tools.compress-pdf.name')}</span>\n            </Button>\n            <Button onClick={() => handleQuickAction('protect-pdf')} variant=\"ghost\" className=\"h-auto py-3 flex flex-col gap-1 border hover:border-ocean-300 hover:bg-ocean-50 dark:hover:bg-ocean-900/10\">\n              <Shield className=\"h-5 w-5 text-ocean-500\" />\n              <span className=\"text-sm font-medium\">{t('tools.protect-pdf.name')}</span>\n            </Button>\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"space-y-6\">\n        {/* Selection Toolbar */}\n        <div className=\"flex flex-wrap items-center justify-between text-sm text-gray-500 bg-white dark:bg-gray-800 p-2 rounded-lg border border-gray-100 dark:border-gray-700 sticky top-0 z-10 shadow-sm min-h-[52px]\">\n          <div className=\"flex items-center gap-2\">\n            <Button variant=\"ghost\" size=\"sm\" onClick={handleSelectAll} className=\"h-8 gap-2\">\n              {selectedPages.size === pages.length && pages.length > 0 ? <CheckSquare className=\"w-4 h-4\" /> : <Square className=\"w-4 h-4\" />}\n              {t('common.selectAll') || 'Select All'}\n            </Button>\n            <div className=\"h-4 w-px bg-gray-200 dark:bg-gray-700 mx-1\" />\n            <div className=\"flex gap-1\">\n              <Button variant=\"ghost\" size=\"sm\" onClick={handleSelectOdd} className=\"h-8 px-2 text-xs\">\n                {t('pageEditor.odd') || 'Odd'}\n              </Button>\n              <Button variant=\"ghost\" size=\"sm\" onClick={handleSelectEven} className=\"h-8 px-2 text-xs\">\n                {t('pageEditor.even') || 'Even'}\n              </Button>\n            </div>\n            {selectedPages.size > 0 && (\n              <span className=\"ml-2 px-2 py-0.5 bg-ocean-100 dark:bg-ocean-900/50 text-ocean-700 dark:text-ocean-300 rounded-full text-xs font-medium animate-in fade-in zoom-in\">\n                {selectedPages.size} selected\n              </span>\n            )}\n          </div>\n\n          <div className=\"flex gap-2 items-center\">\n            {selectedPages.size > 0 && (\n              <>\n                <Button\n                  size=\"sm\"\n                  onClick={handleExtractSelected}\n                  className=\"h-8 px-3 gap-2 bg-ocean-500 hover:bg-ocean-600 text-white shadow-sm animate-in fade-in slide-in-from-right-4\"\n                >\n                  <Download className=\"w-4 h-4\" />\n                  {t('pageEditor.extract') || 'Extract'}\n                </Button>\n                <Button\n                  size=\"sm\"\n                  variant=\"destructive\"\n                  onClick={handleDeleteSelected}\n                  className=\"h-8 px-3 gap-2 shadow-sm animate-in fade-in slide-in-from-right-4\"\n                >\n                  <Trash2 className=\"w-4 h-4\" />\n                  {t('pageEditor.delete') || 'Delete'}\n                </Button>\n                <div className=\"h-4 w-px bg-gray-200 dark:bg-gray-700 mx-1\" />\n              </>\n            )}\n\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={() => setPages(p => p.map(pg => ({ ...pg, rotation: 0, isDeleted: false })))}\n              disabled={!hasChanges}\n              className=\"h-8 px-3 text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20\"\n            >\n              {t('common.reset')}\n            </Button>\n          </div>\n        </div>\n\n        <DndContext\n          sensors={sensors}\n          collisionDetection={closestCenter}\n          onDragEnd={handleDragEnd}\n        >\n          <SortableContext\n            items={pages.map((p) => p.id)}\n            strategy={verticalListSortingStrategy}\n          >\n            <div className=\"h-[calc(100vh-16rem)] min-h-[500px] overflow-y-auto pr-4 -mr-4 scrollbar-thin scrollbar-thumb-gray-200 dark:scrollbar-thumb-gray-700 p-1\">\n              <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 pb-2\">\n                {pages.map((page) => (\n                  <SortablePage\n                    key={page.id}\n                    page={page}\n                    isSelected={selectedPages.has(page.id)}\n                    onToggleSelection={handleToggleSelection}\n                    onRotate={handleRotate}\n                    onDelete={handleDelete}\n                    onRestore={handleRestore}\n                    onZoom={setZoomedPageNumber}\n                  />\n                ))}\n\n                <Card\n                  className=\"aspect-[3/4] flex flex-col items-center justify-center border-dashed border-2 cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-800/50 transition-colors group relative overflow-hidden\"\n                  onClick={() => fileInputRef.current?.click()}\n                >\n                  <div className=\"w-12 h-12 rounded-full bg-gray-100 dark:bg-gray-800 flex items-center justify-center group-hover:scale-110 transition-transform mb-3 z-10\">\n                    <Plus className=\"w-6 h-6 text-gray-500 group-hover:text-ocean-500 transition-colors\" />\n                  </div>\n                  <span className=\"text-sm font-medium text-gray-500 group-hover:text-ocean-500 transition-colors z-10\">{t('pageEditor.addPDF')}</span>\n                  <span className=\"text-xs text-gray-400 mt-1 z-10\">{t('pageEditor.appendPages')}</span>\n                </Card>\n              </div>\n            </div>\n          </SortableContext>\n        </DndContext>\n\n        <input\n          type=\"file\"\n          ref={fileInputRef}\n          className=\"hidden\"\n          accept=\".pdf\"\n          onChange={handleInsertFile}\n        />\n\n\n      </div>\n    );\n  };\n\n  const renderSettings = () => (\n    <div className=\"space-y-6\">\n      <SmartOrganizePanel\n        file={file?.file || null}\n        onDeletePages={handleSmartDelete}\n        onRotatePages={handleSmartRotate}\n        onReorderPages={handleSmartReorder}\n        onHighlightPages={handleHighlightPages}\n      />\n      <div className=\"p-4 bg-gray-50 dark:bg-gray-800/50 rounded-lg border border-gray-100 dark:border-gray-700\">\n        <h4 className=\"font-medium text-sm mb-2 text-gray-900 dark:text-gray-100\">{t('pageEditor.tips.title')}</h4>\n        <ul className=\"text-xs text-gray-500 space-y-1 ml-4 list-disc\">\n          <li>{t('pageEditor.tips.drag')}</li>\n          <li>{t('pageEditor.tips.select')}</li>\n          <li>{t('pageEditor.tips.rotateDelete')}</li>\n          <li>{t('pageEditor.tips.extract')}</li>\n        </ul>\n      </div>\n    </div>\n  );\n\n  return (\n    <>\n      <ToolLayout\n        title={t('tools.organize-pdf.name')}\n        description={t('tools.organize-pdf.description')}\n        hasFiles={!!file}\n        onUpload={handleFileUpload}\n        isProcessing={isProcessing}\n        maxFiles={1}\n        uploadTitle={t('common.selectFile')}\n        uploadDescription={t('upload.singleFileAllowed')}\n        acceptedTypes=\".pdf\"\n        settings={!result && file ? renderSettings() : null}\n        actions={\n          !result && file ? (\n            <Button\n              onClick={handleProcess}\n              disabled={isProcessing || !hasChanges}\n              className=\"w-full py-6 text-lg font-bold shadow-lg shadow-ocean-500/20\"\n            >\n              {isProcessing ? t('common.processing') : t('pageEditor.downloadOrganized')}\n            </Button>\n          ) : null\n        }\n      >\n        {renderContent()}\n      </ToolLayout>\n\n      {/* Zoom Modal */}\n      {zoomedPageNumber !== null && (\n        <div\n          className=\"fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4 animate-in fade-in duration-200\"\n          onClick={() => setZoomedPageNumber(null)}\n        >\n          <div className=\"relative max-w-4xl max-h-[90vh] w-full h-full flex items-center justify-center\">\n            <button\n              onClick={() => setZoomedPageNumber(null)}\n              className=\"absolute -top-12 right-0 p-2 text-white hover:text-gray-300\"\n            >\n              <X className=\"w-8 h-8\" />\n            </button>\n\n            {isZoomLoading ? (\n              <div className=\"flex flex-col items-center gap-2\">\n                <div className=\"animate-spin rounded-full h-10 w-10 border-b-2 border-white\"></div>\n                <p className=\"text-white text-sm\">{t('common.loading')}</p>\n              </div>\n            ) : zoomedImageSrc ? (\n              <img\n                src={zoomedImageSrc}\n                alt={`Page ${zoomedPageNumber}`}\n                className=\"max-w-full max-h-full object-contain rounded shadow-2xl\"\n                onClick={(e) => e.stopPropagation()}\n              />\n            ) : null}\n          </div>\n        </div>\n      )}\n    </>\n  );\n};\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/ProtectPDF.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/RotatePDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Tool' is defined but never used.","line":13,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'HASH_TOOL_MAP' is defined but never used.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { ProgressBar } from '@/components/common/ProgressBar';\nimport { PDFPreview } from '@/components/common/PDFPreview';\nimport { Button } from '@/components/ui/button';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport pdfService from '@/services/pdfService';\nimport type { UploadedFile } from '@/types/pdf';\nimport type { Tool } from '@/types';\nimport { HASH_TOOL_MAP } from '@/types';\nimport { RotateCw, Repeat, FileStack, CheckCircle2 } from 'lucide-react';\n\ntype RotationAngle = 90 | 180 | 270;\ntype PageSelection = 'all' | 'specific';\n\nexport const RotatePDF: React.FC = () => {\n  const { t } = useI18n();\n  const { sharedFile, clearSharedFile, setSharedFile } = useSharedFile();\n  const [file, setFile] = useState<UploadedFile | null>(null);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [progressMessage, setProgressMessage] = useState('');\n  const [result, setResult] = useState<Blob | null>(null);\n  const [loadedFromShared, setLoadedFromShared] = useState(false);\n  const [resultSaved, setResultSaved] = useState(false);\n\n  // Rotation settings\n  const [rotationAngle, setRotationAngle] = useState<RotationAngle>(90);\n  const [pageSelection, setPageSelection] = useState<PageSelection>('all');\n  const [specificPages, setSpecificPages] = useState('');\n\n  // Auto-load file from shared state\n  useEffect(() => {\n    if (sharedFile && !file && !result) {\n      const sharedFileObj = new File([sharedFile.blob], sharedFile.name, {\n        type: 'application/pdf',\n      });\n\n      const uploadedFile: UploadedFile = {\n        id: `${Date.now()}`,\n        file: sharedFileObj,\n        name: sharedFile.name,\n        size: sharedFileObj.size,\n        status: 'pending',\n      };\n\n      setFile(uploadedFile);\n      setLoadedFromShared(true);\n\n      pdfService.getPDFInfo(sharedFileObj).then((info) => {\n        setFile((prev) => (prev ? { ...prev, info, status: 'completed' } : null));\n      }).catch(() => {\n        setFile((prev) =>\n          prev ? { ...prev, status: 'error', error: 'Failed to read PDF' } : null\n        );\n      });\n\n      clearSharedFile();\n    }\n  }, [sharedFile, file, result, clearSharedFile]);\n\n  // Auto-save result to sharedFile when processing is complete\n  useEffect(() => {\n    if (result && !isProcessing && !resultSaved) {\n      const fileName = file?.name.replace(/\\.pdf$/i, '_rotated.pdf') || 'rotated.pdf';\n      setSharedFile(result, fileName, 'rotate-pdf');\n      setResultSaved(true);\n    }\n  }, [result, isProcessing, resultSaved, file?.name, setSharedFile]);\n\n  const handleFileSelected = async (selectedFiles: File[]) => {\n    const selectedFile = selectedFiles[0];\n    if (!selectedFile) return;\n\n    const uploadedFile: UploadedFile = {\n      id: `${Date.now()}`,\n      file: selectedFile,\n      name: selectedFile.name,\n      size: selectedFile.size,\n      status: 'pending',\n    };\n\n    setFile(uploadedFile);\n\n    try {\n      const info = await pdfService.getPDFInfo(selectedFile);\n      setFile((prev) => (prev ? { ...prev, info, status: 'completed' } : null));\n    } catch {\n      setFile((prev) =>\n        prev ? { ...prev, status: 'error', error: 'Failed to read PDF' } : null\n      );\n    }\n  };\n\n  const handleRemoveFile = () => {\n    setFile(null);\n    setResult(null);\n    setResultSaved(false);\n  };\n\n  const parsePageNumbers = (input: string, maxPages: number): number[] => {\n    const pages = new Set<number>();\n    const parts = input.split(',').map(p => p.trim());\n\n    for (const part of parts) {\n      if (part.includes('-')) {\n        const [start, end] = part.split('-').map(n => parseInt(n.trim()));\n        if (!isNaN(start) && !isNaN(end)) {\n          for (let i = Math.max(1, start); i <= Math.min(maxPages, end); i++) {\n            pages.add(i);\n          }\n        }\n      } else {\n        const pageNum = parseInt(part);\n        if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= maxPages) {\n          pages.add(pageNum);\n        }\n      }\n    }\n\n    return Array.from(pages).sort((a, b) => a - b);\n  };\n\n  const handleRotate = async () => {\n    if (!file) return;\n\n    setIsProcessing(true);\n    setProgress(0);\n    setResult(null);\n    setResultSaved(false);\n\n    try {\n      const maxPages = file.info?.pages || 0;\n      let pagesToRotate: number[] = [];\n\n      if (pageSelection === 'all') {\n        pagesToRotate = Array.from({ length: maxPages }, (_, i) => i + 1);\n      } else {\n        pagesToRotate = parsePageNumbers(specificPages, maxPages);\n        if (pagesToRotate.length === 0) {\n          alert(t('rotate.invalidPages'));\n          setIsProcessing(false);\n          return;\n        }\n      }\n\n      const rotateResult = await pdfService.rotatePDF(\n        file.file,\n        rotationAngle,\n        pagesToRotate,\n        (prog, msg) => {\n          setProgress(prog);\n          setProgressMessage(msg);\n        }\n      );\n\n      if (rotateResult.success && rotateResult.data) {\n        setResult(rotateResult.data);\n      } else {\n        alert(t('rotate.failed'));\n      }\n    } catch (error) {\n      alert(t('rotate.failed'));\n      console.error(error);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleDownload = () => {\n    if (!result || !file) return;\n    const filename = file.name.replace('.pdf', '_rotated.pdf');\n    pdfService.downloadFile(result, filename);\n  };\n\n  const handleReset = () => {\n    setFile(null);\n    setResult(null);\n    setResultSaved(false);\n    setProgress(0);\n    setProgressMessage('');\n    setLoadedFromShared(false);\n    setSpecificPages('');\n  };\n\n\n\n  const maxPages = file?.info?.pages || 1;\n\n  const renderContent = () => {\n    if (!file) return null;\n\n    if (result) {\n      return (\n        <div className=\"space-y-6\">\n          <div className=\"bg-gradient-to-r from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20 border-2 border-green-200 dark:border-green-800 rounded-2xl p-8\">\n            <div className=\"text-center space-y-4\">\n              <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/50 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <CheckCircle2 className=\"w-10 h-10 text-green-600 dark:text-green-400\" />\n              </div>\n              <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white\">\n                {t('rotate.success')}\n              </h2>\n              <p className=\"text-gray-600 dark:text-gray-400\">\n                {t('rotate.successDescription')}\n              </p>\n            </div>\n          </div>\n\n          <div className=\"flex gap-3 justify-center\">\n            <Button\n              onClick={handleDownload}\n              size=\"lg\"\n              className=\"bg-green-600 hover:bg-green-700 text-white shadow-lg hover:shadow-xl transition-all\"\n            >\n              {t('common.download')}\n            </Button>\n            <Button\n              onClick={handleReset}\n              variant=\"outline\"\n              size=\"lg\"\n            >\n              {t('rotate.rotateAnother')}\n            </Button>\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"space-y-6\">\n        {/* Auto-loaded indicator */}\n        {loadedFromShared && (\n          <div className=\"bg-ocean-50 dark:bg-ocean-900/20 border border-ocean-200 dark:border-ocean-800 rounded-lg p-4 animate-in fade-in slide-in-from-top-2\">\n            <div className=\"flex items-center justify-between\">\n              <div className=\"flex items-center gap-3\">\n                <span className=\"text-2xl\">‚ú®</span>\n                <div>\n                  <p className=\"font-medium text-ocean-700 dark:text-ocean-300\">\n                    {t('common.autoLoaded')}\n                  </p>\n                  <p className=\"text-sm text-ocean-600 dark:text-ocean-400\">\n                    {t('common.autoLoadedDescription')}\n                  </p>\n                </div>\n              </div>\n              <Button\n                variant=\"ghost\"\n                onClick={handleRemoveFile}\n                className=\"text-ocean-600 dark:text-ocean-400 hover:text-ocean-800 dark:hover:text-ocean-200 font-semibold text-sm\"\n              >\n                ‚úï {t('common.close')}\n              </Button>\n            </div>\n          </div>\n        )}\n\n        {/* File Preview Card */}\n        <Card className=\"overflow-hidden border-ocean-100 dark:border-gray-700\">\n          <CardContent className=\"p-6\">\n            <div className=\"flex items-start gap-6\">\n              <div className=\"flex-shrink-0 relative group\">\n                <div className=\"absolute inset-0 bg-black/5 opacity-0 group-hover:opacity-100 transition-opacity rounded-lg\" />\n                <PDFPreview file={file.file} width={160} height={220} />\n              </div>\n              <div className=\"flex-1 space-y-4\">\n                <div>\n                  <h3 className=\"font-semibold text-lg text-gray-900 dark:text-white mb-1\">\n                    {file.name}\n                  </h3>\n                  <div className=\"flex flex-wrap gap-3 text-sm text-gray-500 dark:text-gray-400\">\n                    <span className=\"flex items-center gap-1\">\n                      <FileStack className=\"w-4 h-4\" />\n                      {file.info?.pages || 0} {t('common.pages')}\n                    </span>\n                    <span className=\"w-1 h-1 rounded-full bg-gray-300 dark:bg-gray-600 self-center\" />\n                    <span>{pdfService.formatFileSize(file.size)}</span>\n                  </div>\n                </div>\n\n                <div className=\"flex items-center gap-2\">\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    onClick={handleRemoveFile}\n                    disabled={isProcessing}\n                    className=\"text-error-500 hover:text-error-600 hover:bg-error-50 dark:hover:bg-error-900/20\"\n                  >\n                    {t('common.changeFile')}\n                  </Button>\n                </div>\n              </div>\n            </div>\n          </CardContent>\n        </Card>\n\n        {isProcessing && (\n          <div className=\"mt-8\">\n            <ProgressBar progress={progress} message={progressMessage} />\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  const renderSettings = () => {\n    return (\n      <div className=\"space-y-6\">\n        <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white flex items-center gap-2\">\n          <RotateCw className=\"w-5 h-5 text-ocean-500\" />\n          {t('rotate.settings')}\n        </h3>\n\n        {/* Rotation Angle */}\n        <div className=\"space-y-3\">\n          <Label className=\"text-sm font-medium text-gray-700 dark:text-gray-300\">\n            {t('rotate.selectAngle')}\n          </Label>\n          <div className=\"grid grid-cols-3 gap-2\">\n            {[90, 180, 270].map((angle) => (\n              <button\n                key={angle}\n                onClick={() => setRotationAngle(angle as RotationAngle)}\n                disabled={isProcessing}\n                className={`\n                  p-3 rounded-xl border-2 transition-all flex flex-col items-center justify-center gap-2\n                  ${rotationAngle === angle\n                    ? 'border-ocean-500 bg-ocean-50 dark:bg-ocean-900/20 text-ocean-700 dark:text-ocean-300'\n                    : 'border-gray-200 dark:border-gray-700 hover:border-ocean-200 dark:hover:border-ocean-800 text-gray-600 dark:text-gray-400'\n                  }\n                `}\n              >\n                <div className=\"text-xl font-bold\">{angle}¬∞</div>\n                <div className=\"text-[10px] uppercase tracking-wider font-medium opacity-70\">\n                  {angle === 90 ? 'CW' : angle === 180 ? 'FLIP' : 'CCW'}\n                </div>\n              </button>\n            ))}\n          </div>\n        </div>\n\n        {/* Page Selection */}\n        <div className=\"space-y-3\">\n          <Label className=\"text-sm font-medium text-gray-700 dark:text-gray-300\">\n            {t('rotate.selectPages')}\n          </Label>\n          <div className=\"grid grid-cols-1 gap-2\">\n            <button\n              onClick={() => setPageSelection('all')}\n              disabled={isProcessing}\n              className={`\n                p-3 rounded-xl border-2 transition-all flex items-center gap-3 text-left\n                ${pageSelection === 'all'\n                  ? 'border-ocean-500 bg-ocean-50 dark:bg-ocean-900/20'\n                  : 'border-gray-200 dark:border-gray-700 hover:border-ocean-200'\n                }\n              `}\n            >\n              <div className={`p-2 rounded-lg ${pageSelection === 'all' ? 'bg-ocean-100 dark:bg-ocean-800 text-ocean-600' : 'bg-gray-100 dark:bg-gray-800 text-gray-500'}`}>\n                <FileStack className=\"w-4 h-4\" />\n              </div>\n              <div>\n                <div className=\"font-medium text-sm text-gray-900 dark:text-white\">{t('rotate.allPages')}</div>\n                <div className=\"text-xs text-gray-500 dark:text-gray-400\">{t('rotate.rotateAllPages')}</div>\n              </div>\n            </button>\n\n            <button\n              onClick={() => setPageSelection('specific')}\n              disabled={isProcessing}\n              className={`\n                p-3 rounded-xl border-2 transition-all flex items-center gap-3 text-left\n                ${pageSelection === 'specific'\n                  ? 'border-ocean-500 bg-ocean-50 dark:bg-ocean-900/20'\n                  : 'border-gray-200 dark:border-gray-700 hover:border-ocean-200'\n                }\n              `}\n            >\n              <div className={`p-2 rounded-lg ${pageSelection === 'specific' ? 'bg-ocean-100 dark:bg-ocean-800 text-ocean-600' : 'bg-gray-100 dark:bg-gray-800 text-gray-500'}`}>\n                <Repeat className=\"w-4 h-4\" />\n              </div>\n              <div>\n                <div className=\"font-medium text-sm text-gray-900 dark:text-white\">{t('rotate.specificPages')}</div>\n                <div className=\"text-xs text-gray-500 dark:text-gray-400\">{t('rotate.choosePages')}</div>\n              </div>\n            </button>\n          </div>\n        </div>\n\n        {/* Specific Pages Input */}\n        {pageSelection === 'specific' && (\n          <div className=\"bg-gray-50 dark:bg-gray-800/50 rounded-xl p-4 animate-in slide-in-from-top-2\">\n            <Label className=\"text-xs font-semibold text-gray-500 uppercase tracking-wider mb-2 block\">\n              {t('rotate.pageNumbers')}\n            </Label>\n            <Input\n              type=\"text\"\n              value={specificPages}\n              onChange={(e) => setSpecificPages(e.target.value)}\n              placeholder=\"e.g. 1, 3, 5-10\"\n              disabled={isProcessing}\n              className=\"bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700\"\n            />\n            <p className=\"text-xs text-gray-500 mt-2\">\n              {t('rotate.pageNumbersHint', { total: String(maxPages) })}\n            </p>\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  const renderActions = () => {\n    return (\n      <Button\n        onClick={handleRotate}\n        disabled={isProcessing || !file}\n        className=\"w-full py-6 text-lg rounded-xl font-bold shadow-lg hover:shadow-xl transition-all\"\n      >\n        {isProcessing ? t('common.processing') : (\n          <span className=\"flex items-center gap-2\">\n            <RotateCw className=\"w-5 h-5\" />\n            {t('rotate.rotateButton')}\n          </span>\n        )}\n      </Button>\n    );\n  };\n\n  return (\n    <ToolLayout\n      title={t('tools.rotate-pdf.name')}\n      description={t('tools.rotate-pdf.description')}\n      hasFiles={!!file}\n      onUpload={handleFileSelected}\n      isProcessing={isProcessing}\n      maxFiles={1}\n      uploadTitle={t('common.selectFile')}\n      uploadDescription={t('upload.singleFileAllowed')}\n      settings={!result ? renderSettings() : null}\n      actions={!result ? renderActions() : null}\n    >\n      {renderContent()}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/SignPDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":129,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4458,4461],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4458,4461],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":370,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":370,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13640,13643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13640,13643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport { PDFDocument, rgb } from 'pdf-lib';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport type { UploadedFile, PDFFileInfo } from '@/types/pdf';\nimport { Button } from '@/components/ui/button';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { CheckCircle2 } from 'lucide-react';\n\ntype SignatureType = 'draw' | 'upload' | 'text';\ntype SignaturePosition = 'bottom-left' | 'bottom-right' | 'top-left' | 'top-right' | 'custom';\n\ninterface SignatureSettings {\n  type: SignatureType;\n  position: SignaturePosition;\n  pageNumber: number | 'all';\n  customX?: number;\n  customY?: number;\n  width: number;\n  height: number;\n  text?: string;\n  textSize?: number;\n}\n\nexport const SignPDF: React.FC = () => {\n  const { t } = useI18n();\n  const { sharedFile, setSharedFile, clearSharedFile } = useSharedFile();\n  const [file, setFile] = useState<UploadedFile | null>(null);\n  const [isProcessing, setIsProcessing] = useState(false);\n\n  const [result, setResult] = useState<{ blob: Blob; metadata: Record<string, unknown> } | null>(null);\n  const [previewUrl, setPreviewUrl] = useState<string | null>(null);\n  const [resultSaved, setResultSaved] = useState(false);\n  const [signatureImage, setSignatureImage] = useState<string | null>(null);\n  const [isDrawing, setIsDrawing] = useState(false);\n\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  const [settings, setSettings] = useState<SignatureSettings>({\n    type: 'draw',\n    position: 'bottom-right',\n    pageNumber: 'all',\n    width: 200,\n    height: 80,\n    text: '',\n    textSize: 12,\n  });\n\n  useEffect(() => {\n    return () => {\n      if (previewUrl) URL.revokeObjectURL(previewUrl);\n    };\n  }, [previewUrl]);\n\n  useEffect(() => {\n    if (sharedFile && !file) {\n      const sharedFileObj = new File([sharedFile.blob], sharedFile.name, { type: 'application/pdf' });\n      handleFilesSelected([sharedFileObj]);\n      clearSharedFile();\n    }\n  }, [sharedFile, file, clearSharedFile]);\n\n  useEffect(() => {\n    if (result?.blob && !isProcessing && !resultSaved) {\n      const fileName = file?.name.replace(/\\.pdf$/i, '_signed.pdf') || 'signed.pdf';\n      setSharedFile(result.blob, fileName, 'sign-pdf');\n      setResultSaved(true);\n    }\n  }, [result, isProcessing, resultSaved, file?.name, setSharedFile]);\n\n  // Canvas initialization\n  useEffect(() => {\n    if (settings.type === 'draw' && canvasRef.current) {\n      initCanvas();\n    }\n  }, [settings.type, file]); // Re-init when type changes or file is loaded (and settings panel appears)\n\n  const initCanvas = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      ctx.fillStyle = 'white';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      ctx.strokeStyle = '#000';\n      ctx.lineWidth = 2;\n      ctx.lineCap = 'round';\n      ctx.lineJoin = 'round';\n    }\n  };\n\n  const handleFilesSelected = async (selectedFiles: File[]) => {\n    const selectedFile = selectedFiles[0];\n    if (!selectedFile) return;\n\n    const uploadedFile: UploadedFile = {\n      id: `${Date.now()}`,\n      file: selectedFile,\n      name: selectedFile.name,\n      size: selectedFile.size,\n      status: 'pending',\n    };\n\n    setFile(uploadedFile);\n    setResult(null);\n    setResultSaved(false);\n\n    try {\n      const arrayBuffer = await selectedFile.arrayBuffer();\n      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\n\n      let dimensions = { width: 0, height: 0 };\n      if (pdf.numPages > 0) {\n        const page = await pdf.getPage(1);\n        const viewport = page.getViewport({ scale: 1.0 });\n        dimensions = { width: viewport.width, height: viewport.height };\n\n        // Render preview\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d')!;\n        canvas.height = viewport.height;\n        canvas.width = viewport.width;\n        // @ts-expect-error - type mismatch in pdfjs-dist definition\n        await page.render({ canvasContext: context, viewport } as any).promise;\n        setPreviewUrl(canvas.toDataURL());\n      }\n\n      const info: PDFFileInfo = {\n        pages: pdf.numPages,\n        originalSize: selectedFile.size,\n        dimensions,\n      };\n      setFile({ ...uploadedFile, info, status: 'completed' });\n    } catch (error) {\n      console.error('Failed to load PDF:', error);\n      setFile({ ...uploadedFile, status: 'error', error: 'Failed to read PDF' });\n    }\n  };\n\n  // Drawing Logic\n  const startDrawing = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    setIsDrawing(true);\n    ctx.beginPath();\n    ctx.moveTo(e.clientX - rect.left, e.clientY - rect.top);\n  };\n\n  const draw = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!isDrawing) return;\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    ctx.lineTo(e.clientX - rect.left, e.clientY - rect.top);\n    ctx.stroke();\n  };\n\n  const stopDrawing = () => {\n    if (!isDrawing) return;\n    setIsDrawing(false);\n    const canvas = canvasRef.current;\n    if (canvas) setSignatureImage(canvas.toDataURL('image/png'));\n  };\n\n  const clearCanvas = () => {\n    initCanvas();\n    setSignatureImage(null);\n  };\n\n  const handleImageUpload = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n    if (!file) return;\n    const reader = new FileReader();\n    reader.onload = (event) => setSignatureImage(event.target?.result as string);\n    reader.readAsDataURL(file);\n  };\n\n  const calculatePosition = (position: SignaturePosition, pageWidth: number, pageHeight: number, sigWidth: number, sigHeight: number) => {\n    const margin = 30;\n    switch (position) {\n      case 'bottom-left': return { x: margin, y: margin };\n      case 'bottom-right': return { x: pageWidth - margin - sigWidth, y: margin };\n      case 'top-left': return { x: margin, y: pageHeight - margin - sigHeight };\n      case 'top-right': return { x: pageWidth - margin - sigWidth, y: pageHeight - margin - sigHeight };\n      case 'custom': return { x: settings.customX || pageWidth / 2 - sigWidth / 2, y: settings.customY || pageHeight / 2 - sigHeight / 2 };\n      default: return { x: pageWidth - margin - sigWidth, y: margin };\n    }\n  };\n\n  const handleApplySignature = async () => {\n    if (!file) return;\n    if (settings.type === 'text' && !settings.text?.trim()) { alert(t('sign.enterText')); return; }\n    if ((settings.type === 'draw' || settings.type === 'upload') && !signatureImage) { alert(t('sign.provideSignature')); return; }\n\n    setIsProcessing(true);\n    setIsProcessing(true);\n\n    try {\n      const arrayBuffer = await file.file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer);\n\n\n\n      let signatureImageBytes: Uint8Array | null = null;\n      if (settings.type !== 'text' && signatureImage) {\n        const base64Data = signatureImage.split(',')[1];\n        const binaryString = atob(base64Data);\n        signatureImageBytes = new Uint8Array(binaryString.length);\n        for (let i = 0; i < binaryString.length; i++) signatureImageBytes[i] = binaryString.charCodeAt(i);\n      }\n\n      const pages = pdfDoc.getPages();\n      const pagesToSign: number[] = settings.pageNumber === 'all'\n        ? pages.map((_, i) => i)\n        : [(settings.pageNumber as number) - 1].filter(p => p >= 0 && p < pages.length);\n\n      for (let i = 0; i < pagesToSign.length; i++) {\n        const page = pages[pagesToSign[i]];\n        const { width, height } = page.getSize();\n        const pos = calculatePosition(settings.position, width, height, settings.width, settings.height);\n\n        if (settings.type === 'text') {\n          page.drawText(settings.text || '', { x: pos.x, y: pos.y, size: settings.textSize || 12, color: rgb(0, 0, 0) });\n        } else if (signatureImageBytes) {\n          const signatureImg = await pdfDoc.embedPng(signatureImageBytes);\n          page.drawImage(signatureImg, { x: pos.x, y: pos.y, width: settings.width, height: settings.height });\n        }\n\n      }\n\n      const pdfBytes = await pdfDoc.save();\n      const blob = new Blob([pdfBytes as BlobPart], { type: 'application/pdf' });\n\n      setResult({\n        blob,\n        metadata: {\n          originalSize: file.size,\n          finalSize: blob.size,\n          pageCount: pages.length,\n          pagesSigned: pagesToSign.length,\n        }\n      });\n    } catch (e) {\n      console.error(e);\n      alert('Failed to sign PDF');\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleDownload = () => {\n    if (result?.blob) pdfService.downloadFile(result.blob, file?.name.replace('.pdf', '_signed.pdf') || 'signed.pdf');\n  };\n\n  const handleReset = () => {\n    setFile(null);\n    setResult(null);\n    setPreviewUrl(null);\n    setSignatureImage(null);\n    clearSharedFile();\n  };\n\n  const renderSignaturePreviewOverlay = () => {\n    if (!signatureImage && (!settings.text || settings.type !== 'text')) return null;\n    if (!file?.info?.dimensions) return null; // Need original dims\n\n    // const dims = file.info.dimensions;\n    // We need to scale the overlay position to the current display size of the image\n    // But for simplicity in this preview, let's assume valid CSS positioning using % or simply corners.\n    // Since 'custom' isn't interactive here yet, corner logic is enough.\n\n    const style: React.CSSProperties = {\n      position: 'absolute',\n      zIndex: 10,\n      width: '20%', // Rough approximation for preview\n      height: 'auto',\n      border: '1px dashed #3b82f6',\n      backgroundColor: 'rgba(255, 255, 255, 0.5)'\n    };\n\n    if (settings.position === 'bottom-right') { style.bottom = '5%'; style.right = '5%'; }\n    else if (settings.position === 'bottom-left') { style.bottom = '5%'; style.left = '5%'; }\n    else if (settings.position === 'top-right') { style.top = '5%'; style.right = '5%'; }\n    else if (settings.position === 'top-left') { style.top = '5%'; style.left = '5%'; }\n    else { style.top = '50%'; style.left = '50%'; style.transform = 'translate(-50%, -50%)'; }\n\n    return (\n      <div style={style} className=\"p-1\">\n        {settings.type === 'text' ? (\n          <div style={{ fontSize: '10px', fontFamily: 'sans-serif' }}>{settings.text}</div>\n        ) : (\n          <img src={signatureImage!} alt=\"sig\" className=\"w-full h-auto\" />\n        )}\n      </div>\n    );\n  };\n\n  const renderSettings = () => (\n    <div className=\"space-y-6\">\n      <Tabs value={settings.type} onValueChange={(v) => {\n        setSettings({ ...settings, type: v as SignatureType });\n        // Need a timeout to let canvas render before init\n        if (v === 'draw') setTimeout(initCanvas, 50);\n      }}>\n        <TabsList className=\"grid w-full grid-cols-3\">\n          <TabsTrigger value=\"draw\">{t('sign.modeDraw')}</TabsTrigger>\n          <TabsTrigger value=\"upload\">{t('sign.modeUpload')}</TabsTrigger>\n          <TabsTrigger value=\"text\">{t('sign.modeText')}</TabsTrigger>\n        </TabsList>\n      </Tabs>\n\n      {settings.type === 'draw' && (\n        <div className=\"space-y-2\">\n          <Label>{t('sign.drawSignature')}</Label>\n          <div className=\"border rounded-md overflow-hidden bg-white shadow-sm\">\n            <canvas\n              ref={canvasRef}\n              width={300} // Smaller for sidebar\n              height={120}\n              onMouseDown={startDrawing}\n              onMouseMove={draw}\n              onMouseUp={stopDrawing}\n              onMouseLeave={stopDrawing}\n              className=\"w-full cursor-crosshair touch-none\"\n            />\n          </div>\n          <Button variant=\"ghost\" size=\"sm\" onClick={clearCanvas} className=\"text-xs w-full text-red-500 hover:text-red-600\">\n            {t('sign.clearSignature')}\n          </Button>\n        </div>\n      )}\n\n      {settings.type === 'upload' && (\n        <div className=\"space-y-2\">\n          <Label>{t('sign.uploadImage')}</Label>\n          <Input type=\"file\" accept=\"image/*\" onChange={handleImageUpload} />\n          {signatureImage && (\n            <div className=\"border rounded p-2 bg-white\">\n              <img src={signatureImage} className=\"max-h-20 mx-auto\" alt=\"preview\" />\n            </div>\n          )}\n        </div>\n      )}\n\n      {settings.type === 'text' && (\n        <div className=\"space-y-3\">\n          <div className=\"space-y-1\">\n            <Label>{t('sign.signatureText')}</Label>\n            <Input value={settings.text} onChange={e => setSettings({ ...settings, text: e.target.value })} placeholder=\"Your Name\" />\n          </div>\n          <div className=\"space-y-1\">\n            <Label>{t('sign.textSize')}: {settings.textSize}pt</Label>\n            <Input type=\"range\" min=\"8\" max=\"72\" value={settings.textSize} onChange={e => setSettings({ ...settings, textSize: parseInt(e.target.value) })} />\n          </div>\n        </div>\n      )}\n\n      <div className=\"space-y-3 pt-4 border-t\">\n        <Label>{t('sign.position')}</Label>\n        <Select value={settings.position} onValueChange={(v: any) => setSettings({ ...settings, position: v })}>\n          <SelectTrigger><SelectValue /></SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"bottom-right\">{t('sign.positions.bottomRight')}</SelectItem>\n            <SelectItem value=\"bottom-left\">{t('sign.positions.bottomLeft')}</SelectItem>\n            <SelectItem value=\"top-right\">{t('sign.positions.topRight')}</SelectItem>\n            <SelectItem value=\"top-left\">{t('sign.positions.topLeft')}</SelectItem>\n          </SelectContent>\n        </Select>\n      </div>\n\n      <div className=\"space-y-3\">\n        <Label>{t('sign.applyToPages')}</Label>\n        <Select value={String(settings.pageNumber)} onValueChange={(v) => setSettings({ ...settings, pageNumber: v === 'all' ? 'all' : parseInt(v) })}>\n          <SelectTrigger><SelectValue /></SelectTrigger>\n          <SelectContent>\n            <SelectItem value=\"all\">{t('sign.allPages')}</SelectItem>\n            {file?.info?.pages && Array.from({ length: file.info.pages }).map((_, i) => (\n              <SelectItem key={i} value={String(i + 1)}>{t('sign.pageNumber', { number: i + 1 })}</SelectItem>\n            ))}\n          </SelectContent>\n        </Select>\n      </div>\n    </div>\n  );\n\n  const renderContent = () => {\n    if (!file) return null;\n    if (result) {\n      return (\n        <div className=\"text-center space-y-6\">\n          <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/30 rounded-full flex items-center justify-center mx-auto text-green-600\">\n            <CheckCircle2 className=\"w-10 h-10\" />\n          </div>\n          <h2 className=\"text-2xl font-bold\">{t('sign.successTitle')}</h2>\n\n          <div className=\"flex justify-center gap-4\">\n            <Button onClick={handleDownload} size=\"lg\" className=\"bg-green-600 hover:bg-green-700\">{t('common.download')}</Button>\n            <Button onClick={handleReset} variant=\"outline\" size=\"lg\">{t('common.convertAnother')}</Button>\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"flex flex-col items-center justify-center bg-gray-100 dark:bg-gray-800 rounded-lg p-4 min-h-[400px] relative overflow-hidden\">\n        {previewUrl ? (\n          <div className=\"relative shadow-lg max-w-full\">\n            <img src={previewUrl} alt=\"PDF Preview\" className=\"max-h-[60vh] object-contain\" />\n            {renderSignaturePreviewOverlay()}\n          </div>\n        ) : (\n          <p className=\"text-gray-500\">{t('sign.generatingPreview')}</p>\n        )}\n      </div>\n    );\n  };\n\n  const renderActions = () => (\n    <Button onClick={handleApplySignature} disabled={isProcessing || (!signatureImage && settings.type !== 'text') || (settings.type === 'text' && !settings.text)} className=\"w-full py-6 text-lg font-bold\">\n      {isProcessing ? t('common.processing') : t('sign.addSignature')}\n    </Button>\n  );\n\n  return (\n    <ToolLayout\n      title={t('tools.sign-pdf.name')}\n      description={t('tools.sign-pdf.description')}\n      hasFiles={!!file}\n      onUpload={handleFilesSelected}\n      isProcessing={isProcessing}\n      maxFiles={1}\n      uploadTitle={t('common.selectFile')}\n      uploadDescription={t('upload.singleFileAllowed')}\n      acceptedTypes=\".pdf\"\n      settings={!result ? renderSettings() : null}\n      actions={!result ? renderActions() : null}\n      sidebarWidth=\"w-80\" // Slightly wider for signature canvas\n    >\n      {renderContent()}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/SplitPDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'idx' is defined but never used.","line":689,"column":55,"nodeType":null,"messageId":"unusedVar","endLine":689,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'index' is defined but never used.","line":905,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":905,"endColumn":47}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { FileUpload } from '@/components/common/FileUpload';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { PDFPreview } from '@/components/common/PDFPreview';\nimport { Button } from '@/components/ui/button';\nimport { Card } from '@/components/ui/card';\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\n// Kept as it might be used or remove if confirmed unused globally\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport pdfService from '@/services/pdfService';\nimport smartOrganizeService from '@/services/smartOrganizeService';\nimport type { ChapterInfo } from '@/services/smartOrganizeService';\nimport type { UploadedFile } from '@/types/pdf';\nimport type { Tool } from '@/types';\nimport { HASH_TOOL_MAP } from '@/types';\nimport { toast } from 'sonner';\n\ntype SplitMode = 'all' | 'range' | 'intervals' | 'custom' | 'by-structure';\n\ninterface SplitResult {\n  blob: Blob;\n  pageNumbers: number[];\n  index: number;\n  chapterTitle?: string; // Optional chapter title for by-structure mode\n}\n\nexport const SplitPDF: React.FC = () => {\n  const { t } = useI18n();\n  const { sharedFile, clearSharedFile, setSharedFile } = useSharedFile();\n  const [file, setFile] = useState<UploadedFile | null>(null);\n  const [splitMode, setSplitMode] = useState<SplitMode>('all');\n  const [isProcessing, setIsProcessing] = useState(false);\n\n  const [results, setResults] = useState<SplitResult[]>([]);\n  const [loadedFromShared, setLoadedFromShared] = useState(false);\n  const [isCreatingArchive, setIsCreatingArchive] = useState(false);\n\n  // Range mode settings\n  const [rangeStart, setRangeStart] = useState(1);\n  const [rangeEnd, setRangeEnd] = useState(1);\n\n  // Intervals mode settings\n  const [intervalSize, setIntervalSize] = useState(1);\n\n  // Custom pages mode settings\n  const [customPagesInput, setCustomPagesInput] = useState('');\n\n  // By-structure mode settings\n  const [detectedChapters, setDetectedChapters] = useState<ChapterInfo[]>([]);\n  const [isAnalyzing, setIsAnalyzing] = useState(false);\n  const [selectedChapters, setSelectedChapters] = useState<Set<number>>(new Set());\n\n  // Preview Zoom state\n  const [previewResult, setPreviewResult] = useState<SplitResult | null>(null);\n\n  // Selection for continuing to other tools\n  const [selectedResults, setSelectedResults] = useState<Set<number>>(new Set());\n\n  // Auto-load file from shared state\n  useEffect(() => {\n    if (sharedFile && !file && results.length === 0) {\n      const sharedFileObj = new File([sharedFile.blob], sharedFile.name, {\n        type: 'application/pdf',\n      });\n\n      const uploadedFile: UploadedFile = {\n        id: `${Date.now()}`,\n        file: sharedFileObj,\n        name: sharedFile.name,\n        size: sharedFileObj.size,\n        status: 'pending',\n      };\n\n      setFile(uploadedFile);\n      setLoadedFromShared(true);\n\n      pdfService.getPDFInfo(sharedFileObj).then((info) => {\n        setFile((prev) => (prev ? { ...prev, info, status: 'completed' } : null));\n        setRangeEnd(info.pages);\n      }).catch(() => {\n        setFile((prev) =>\n          prev ? { ...prev, status: 'error', error: 'Failed to read PDF' } : null\n        );\n      });\n\n      clearSharedFile();\n    }\n  }, [sharedFile, file, results, clearSharedFile]);\n\n  const handleFileSelected = async (selectedFiles: File[]) => {\n    const selectedFile = selectedFiles[0];\n    if (!selectedFile) return;\n\n    const uploadedFile: UploadedFile = {\n      id: `${Date.now()}`,\n      file: selectedFile,\n      name: selectedFile.name,\n      size: selectedFile.size,\n      status: 'pending',\n      // Reset state for new file\n    };\n\n    setFile(uploadedFile);\n    setResults([]);\n    setDetectedChapters([]);\n    setSelectedChapters(new Set());\n    setSelectedResults(new Set());\n\n    try {\n      const info = await pdfService.getPDFInfo(selectedFile);\n      setFile((prev) => (prev ? { ...prev, info, status: 'completed' } : null));\n      setRangeEnd(info.pages);\n    } catch {\n      setFile((prev) =>\n        prev ? { ...prev, status: 'error', error: 'Failed to read PDF' } : null\n      );\n    }\n  };\n\n  const handleRemoveFile = () => {\n    setFile(null);\n    setResults([]);\n    setDetectedChapters([]);\n    setSelectedChapters(new Set());\n  };\n\n  // Analyze document structure for chapter detection\n  const handleAnalyzeStructure = async () => {\n    if (!file) return;\n\n    setIsAnalyzing(true);\n    setProgress(0);\n    setProgressMessage('');\n\n    try {\n      const analysis = await smartOrganizeService.analyzeDocument(\n        file.file,\n        (prog, msg) => {\n          setProgress(prog);\n          setProgressMessage(msg);\n        }\n      );\n\n      if (analysis.chapters.length > 0) {\n        setDetectedChapters(analysis.chapters);\n        // Auto-select all chapters by default\n        setSelectedChapters(new Set(analysis.chapters.map((_, idx) => idx)));\n        toast.success(\n          `${analysis.chapters.length} ${analysis.chapters.length === 1 ? 'chapter' : 'chapters'} detected!`\n        );\n      } else {\n        toast.info('No chapters detected. Try another split mode.');\n        setDetectedChapters([]);\n      }\n    } catch (error) {\n      toast.error('Failed to analyze document structure');\n      console.error(error);\n    } finally {\n      setIsAnalyzing(false);\n      setProgress(0);\n      setProgressMessage('');\n    }\n  };\n\n  // Parse custom pages input (e.g., \"1,3,5-7,10\")\n  const parseCustomPages = (input: string, maxPages: number): number[] => {\n    const pages = new Set<number>();\n    const parts = input.split(',').map(p => p.trim());\n\n    for (const part of parts) {\n      if (part.includes('-')) {\n        // Range: \"5-7\"\n        const [start, end] = part.split('-').map(n => parseInt(n.trim()));\n        if (!isNaN(start) && !isNaN(end)) {\n          for (let i = Math.max(1, start); i <= Math.min(maxPages, end); i++) {\n            pages.add(i);\n          }\n        }\n      } else {\n        // Single page: \"3\"\n        const pageNum = parseInt(part);\n        if (!isNaN(pageNum) && pageNum >= 1 && pageNum <= maxPages) {\n          pages.add(pageNum);\n        }\n      }\n    }\n\n    return Array.from(pages).sort((a, b) => a - b);\n  };\n\n  const handleSplit = async () => {\n    if (!file) return;\n\n    setIsProcessing(true);\n    setProgress(0);\n    setResults([]);\n\n    try {\n      let splitResults: SplitResult[] = [];\n\n      if (splitMode === 'all') {\n        // Split into individual pages\n        const result = await pdfService.splitPDF(\n          file.file,\n          'pages',\n          { pages: [] }, // Will split all pages\n          (prog, msg) => {\n            setProgress(prog);\n            setProgressMessage(msg);\n          }\n        );\n\n        if (result.success && result.data) {\n          splitResults = result.data.map((blob, index) => ({\n            blob,\n            pageNumbers: [index + 1],\n            index,\n          }));\n        }\n      } else if (splitMode === 'range') {\n        // Split by range\n        const result = await pdfService.splitPDF(\n          file.file,\n          'range',\n          { start: rangeStart, end: rangeEnd },\n          (prog, msg) => {\n            setProgress(prog);\n            setProgressMessage(msg);\n          }\n        );\n\n        if (result.success && result.data) {\n          splitResults = [{\n            blob: result.data[0],\n            pageNumbers: Array.from(\n              { length: rangeEnd - rangeStart + 1 },\n              (_, i) => rangeStart + i\n            ),\n            index: 0,\n          }];\n        }\n      } else if (splitMode === 'intervals') {\n        // Split by intervals\n        const result = await pdfService.splitPDF(\n          file.file,\n          'intervals',\n          { interval: intervalSize },\n          (prog, msg) => {\n            setProgress(prog);\n            setProgressMessage(msg);\n          }\n        );\n\n        if (result.success && result.data) {\n          const totalPages = file.info?.pages || 0;\n          splitResults = result.data.map((blob, index) => {\n            const startPage = index * intervalSize + 1;\n            const endPage = Math.min((index + 1) * intervalSize, totalPages);\n            return {\n              blob,\n              pageNumbers: Array.from(\n                { length: endPage - startPage + 1 },\n                (_, i) => startPage + i\n              ),\n              index,\n            };\n          });\n        }\n      } else if (splitMode === 'custom') {\n        // Extract specific pages\n        const maxPages = file.info?.pages || 0;\n        const pagesToExtract = parseCustomPages(customPagesInput, maxPages);\n\n        if (pagesToExtract.length === 0) {\n          toast.error('Please enter valid page numbers');\n          setIsProcessing(false);\n          return;\n        }\n\n        setProgress(20);\n        setProgressMessage(`Extracting ${pagesToExtract.length} pages...`);\n\n        const result = await pdfService.splitPDF(\n          file.file,\n          'custom',\n          { pages: pagesToExtract },\n          (prog, msg) => {\n            setProgress(prog);\n            setProgressMessage(msg);\n          }\n        );\n\n        if (result.success && result.data) {\n          splitResults = result.data.map((blob, index) => ({\n            blob,\n            pageNumbers: [pagesToExtract[index]],\n            index,\n          }));\n        }\n      } else if (splitMode === 'by-structure') {\n        // Split by detected chapters\n        if (selectedChapters.size === 0) {\n          toast.error('Please select at least one chapter to split');\n          setIsProcessing(false);\n          return;\n        }\n\n        const selectedChaptersList = Array.from(selectedChapters)\n          .sort((a, b) => a - b)\n          .map(idx => detectedChapters[idx]);\n\n        setProgress(10);\n        setProgressMessage('Splitting by chapters...');\n\n        // Process each selected chapter\n        for (let i = 0; i < selectedChaptersList.length; i++) {\n          const chapter = selectedChaptersList[i];\n          const endPage = chapter.endPage || (file.info?.pages || 0);\n\n          setProgress(10 + (i / selectedChaptersList.length) * 80);\n          setProgressMessage(`Processing: ${chapter.title}`);\n\n          // Extract pages for this chapter\n          const chapterPages = Array.from(\n            { length: endPage - chapter.startPage + 1 },\n            (_, idx) => chapter.startPage + idx\n          );\n\n          const result = await pdfService.splitPDF(\n            file.file,\n            'custom',\n            { pages: chapterPages },\n            () => { } // No progress callback for individual chapters\n          );\n\n          if (result.success && result.data && result.data[0]) {\n            splitResults.push({\n              blob: result.data[0],\n              pageNumbers: chapterPages,\n              index: i,\n              chapterTitle: chapter.title, // Store chapter title for filename\n            });\n          }\n        }\n\n        setProgress(95);\n      }\n\n      setResults(splitResults);\n      toast.success('PDF split successfully!');\n    } catch (error) {\n      toast.error('An error occurred during split');\n      console.error(error);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleDownload = (result: SplitResult) => {\n    let filename: string;\n\n    if (result.chapterTitle) {\n      // Use chapter title for by-structure mode\n      const sanitizedTitle = result.chapterTitle\n        .replace(/[^a-zA-Z0-9–∞-—è–ê-–Ø—ë–Å\\s-]/g, '')\n        .replace(/\\s+/g, '_')\n        .slice(0, 50); // Limit filename length\n      filename = file?.name.replace('.pdf', `_${sanitizedTitle}.pdf`) || `${sanitizedTitle}.pdf`;\n    } else {\n      // Use page numbers for other modes\n      const pageRange = result.pageNumbers.length === 1\n        ? `page-${result.pageNumbers[0]}`\n        : `pages-${result.pageNumbers[0]}-${result.pageNumbers[result.pageNumbers.length - 1]}`;\n      filename = file?.name.replace('.pdf', `_${pageRange}.pdf`) || `split_${pageRange}.pdf`;\n    }\n\n    pdfService.downloadFile(result.blob, filename);\n  };\n\n  const handleDownloadAll = () => {\n    results.forEach((result, index) => {\n      setTimeout(() => {\n        handleDownload(result);\n      }, index * 200); // Stagger downloads\n    });\n  };\n\n  const handleDownloadAsZip = async () => {\n    if (results.length === 0 || !file) return;\n\n    setIsCreatingArchive(true);\n    setProgress(0);\n\n    try {\n      // Prepare files for archiving\n      const files = results.map((result) => {\n        const pageRange = result.pageNumbers.length === 1\n          ? `page-${result.pageNumbers[0]}`\n          : `pages-${result.pageNumbers[0]}-${result.pageNumbers[result.pageNumbers.length - 1]}`;\n\n        const filename = file.name.replace('.pdf', `_${pageRange}.pdf`) || `split_${pageRange}.pdf`;\n\n        return {\n          blob: result.blob,\n          filename\n        };\n      });\n\n      // Create and download ZIP\n      const baseFilename = file.name.replace('.pdf', '') || 'split-pdf';\n      const archiveName = `${baseFilename}_split.zip`;\n\n      await pdfService.downloadAsZip(files, archiveName, (prog, msg) => {\n        setProgress(prog);\n        setProgressMessage(msg);\n      });\n      toast.success('Archive downloaded successfully!');\n    } catch (error) {\n      toast.error('Failed to create archive');\n      console.error(error);\n    } finally {\n      setIsCreatingArchive(false);\n      setProgress(0);\n      setProgressMessage('');\n    }\n  };\n\n  const handleReset = () => {\n    setFile(null);\n    setResults([]);\n    setProgress(0);\n    setProgressMessage('');\n    setLoadedFromShared(false);\n    setSelectedResults(new Set());\n  };\n\n  const toggleResultSelection = (index: number) => {\n    const newSelection = new Set(selectedResults);\n    if (newSelection.has(index)) {\n      newSelection.delete(index);\n    } else {\n      newSelection.add(index);\n    }\n    setSelectedResults(newSelection);\n  };\n\n  const toggleSelectAll = () => {\n    if (selectedResults.size === results.length) {\n      setSelectedResults(new Set());\n    } else {\n      setSelectedResults(new Set(results.map((_, index) => index)));\n    }\n  };\n\n  const handleQuickAction = async (toolId: Tool) => {\n    // Determine which results to share\n    let resultsToShare: SplitResult[];\n\n    if (selectedResults.size === 0) {\n      // No selection - use all results\n      resultsToShare = results;\n    } else {\n      // Use selected results\n      const selectedIndices = Array.from(selectedResults).sort((a, b) => a - b);\n      resultsToShare = selectedIndices.map(index => results[index]);\n    }\n\n    // If only one result, share it directly\n    if (resultsToShare.length === 1) {\n      const result = resultsToShare[0];\n      const filename = file?.name.replace('.pdf', `_page-${result.pageNumbers[0]}.pdf`) || 'split-page.pdf';\n      setSharedFile(result.blob, filename, 'split-pdf');\n\n      // Small delay to ensure state is updated before navigation\n      await new Promise(resolve => setTimeout(resolve, 100));\n      window.location.hash = HASH_TOOL_MAP[toolId];\n      return;\n    }\n\n    // If multiple results, merge them first\n    setIsProcessing(true);\n    setProgress(0);\n    setProgressMessage(t('split.mergingSelected'));\n\n    try {\n      const selectedBlobs = resultsToShare.map(r => r.blob);\n\n      // Convert blobs to files for merging\n      const filesToMerge = selectedBlobs.map((blob, i) =>\n        new File([blob], `page-${i + 1}.pdf`, { type: 'application/pdf' })\n      );\n\n      // Merge pages\n      const mergeResult = await pdfService.mergePDFs(filesToMerge, (prog, msg) => {\n        setProgress(prog);\n        setProgressMessage(msg);\n      });\n\n      if (mergeResult.success && mergeResult.data) {\n        const filename = selectedResults.size === 0\n          ? file?.name.replace('.pdf', '_all-pages.pdf') || 'all-pages.pdf'\n          : file?.name.replace('.pdf', '_selected-pages.pdf') || 'selected-pages.pdf';\n        setSharedFile(mergeResult.data, filename, 'split-pdf');\n\n        // Small delay to ensure state is updated before navigation\n        await new Promise(resolve => setTimeout(resolve, 100));\n        window.location.hash = HASH_TOOL_MAP[toolId];\n      } else {\n        toast.error(t('split.mergeFailed'));\n      }\n    } catch (error) {\n      console.error('Failed to merge pages:', error);\n      toast.error(t('split.mergeFailed'));\n    } finally {\n      setIsProcessing(false);\n      setProgress(0);\n      setProgressMessage('');\n    }\n  };\n\n  const maxPages = file?.info?.pages || 1;\n\n  // Pagination settings\n  const ITEMS_PER_PAGE = 12;\n  const [currentPage, setCurrentPage] = useState(1);\n  const totalPages = Math.ceil(results.length / ITEMS_PER_PAGE);\n\n  const currentResults = results.slice(\n    (currentPage - 1) * ITEMS_PER_PAGE,\n    currentPage * ITEMS_PER_PAGE\n  );\n\n  // Reset pagination when results change\n  useEffect(() => {\n    setCurrentPage(1);\n  }, [results.length]);\n\n  return (\n    <ToolLayout\n      title={t('tools.split-pdf.name')}\n      description={t('tools.split-pdf.description')}\n      hasFiles={!!file}\n      isProcessing={isProcessing}\n      onUpload={(files) => handleFileSelected(files)}\n      uploadContent={\n        <FileUpload\n          accept=\".pdf\"\n          multiple={false}\n          onFilesSelected={handleFileSelected}\n          maxSizeMB={100}\n          disabled={isProcessing}\n          title={t('common.selectFile')}\n          description={t('upload.singleFileAllowed')}\n        />\n      }\n      settings={\n        file && results.length === 0 ? (\n          <div className=\"space-y-6 animate-slide-up\">\n            {/* Range Mode Settings */}\n            {splitMode === 'range' && (\n              <div className=\"space-y-4\">\n                <h3 className=\"font-semibold text-gray-900 dark:text-white flex items-center gap-2\">\n                  <span className=\"text-xl\">üìë</span> {t('split.rangeSettings')}\n                </h3>\n                <div className=\"grid grid-cols-2 gap-4\">\n                  <div className=\"space-y-2\">\n                    <Label>{t('split.startPage')}</Label>\n                    <Input\n                      type=\"number\"\n                      min={1}\n                      max={maxPages}\n                      value={rangeStart}\n                      onChange={(e) => setRangeStart(Math.max(1, Math.min(maxPages, parseInt(e.target.value) || 1)))}\n                      disabled={isProcessing}\n                    />\n                  </div>\n                  <div className=\"space-y-2\">\n                    <Label>{t('split.endPage')}</Label>\n                    <Input\n                      type=\"number\"\n                      min={1}\n                      max={maxPages}\n                      value={rangeEnd}\n                      onChange={(e) => setRangeEnd(Math.max(1, Math.min(maxPages, parseInt(e.target.value) || 1)))}\n                      disabled={isProcessing}\n                    />\n                  </div>\n                </div>\n                <p className=\"text-xs text-gray-500 dark:text-gray-400\">\n                  {t('split.rangeHint', { total: String(maxPages) })}\n                </p>\n              </div>\n            )}\n\n            {/* Intervals Mode Settings */}\n            {splitMode === 'intervals' && (\n              <div className=\"space-y-4\">\n                <h3 className=\"font-semibold text-gray-900 dark:text-white flex items-center gap-2\">\n                  <span className=\"text-xl\">üìö</span> {t('split.intervalSettings')}\n                </h3>\n                <div className=\"space-y-2\">\n                  <Label>{t('split.pagesPerFile')}</Label>\n                  <Input\n                    type=\"number\"\n                    min={1}\n                    max={maxPages}\n                    value={intervalSize}\n                    onChange={(e) => setIntervalSize(Math.max(1, Math.min(maxPages, parseInt(e.target.value) || 1)))}\n                    disabled={isProcessing}\n                  />\n                </div>\n                <p className=\"text-xs text-gray-500 dark:text-gray-400\">\n                  {t('split.intervalHint', {\n                    files: Math.ceil(maxPages / intervalSize),\n                    total: maxPages\n                  })}\n                </p>\n              </div>\n            )}\n\n            {/* Custom Mode Settings */}\n            {splitMode === 'custom' && (\n              <div className=\"space-y-4\">\n                <h3 className=\"font-semibold text-gray-900 dark:text-white flex items-center gap-2\">\n                  <span className=\"text-xl\">üéØ</span> {t('split.customSettings')}\n                </h3>\n                <div className=\"space-y-2\">\n                  <Label>{t('split.pageNumbers')}</Label>\n                  <Input\n                    type=\"text\"\n                    placeholder=\"e.g., 1,3,5-7,10\"\n                    value={customPagesInput}\n                    onChange={(e) => setCustomPagesInput(e.target.value)}\n                    disabled={isProcessing}\n                  />\n                </div>\n                <p className=\"text-xs text-gray-500 dark:text-gray-400\">\n                  {t('split.customHint')}\n                </p>\n              </div>\n            )}\n\n            {/* By Structure Mode Settings */}\n            {splitMode === 'by-structure' && (\n              <div className=\"space-y-4\">\n                <h3 className=\"font-semibold text-gray-900 dark:text-white flex items-center gap-2\">\n                  <span className=\"text-xl\">‚ú®</span> {t('split.structureSettings')}\n                </h3>\n\n                {detectedChapters.length === 0 ? (\n                  <div className=\"text-center p-4 bg-gray-50 dark:bg-gray-800 rounded-lg border border-dashed border-gray-300 dark:border-gray-700\">\n                    <p className=\"text-sm text-gray-600 dark:text-gray-400 mb-4\">\n                      {t('split.analyzeFirst')}\n                    </p>\n                    <Button\n                      onClick={handleAnalyzeStructure}\n                      disabled={isAnalyzing}\n                      variant=\"outline\"\n                      className=\"w-full\"\n                    >\n                      {isAnalyzing ? t('split.analyzing') : t('split.analyzeButton')}\n                    </Button>\n                  </div>\n                ) : (\n                  <div className=\"space-y-3\">\n                    <div className=\"flex items-center justify-between\">\n                      <span className=\"text-sm font-medium\">\n                        {t('split.chaptersDetected', { count: detectedChapters.length })}\n                      </span>\n                      <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        onClick={handleAnalyzeStructure}\n                        className=\"h-auto p-0 text-ocean-600\"\n                      >\n                        {t('split.reanalyze')}\n                      </Button>\n                    </div>\n                    <div className=\"max-h-[300px] overflow-y-auto space-y-2 pr-2\">\n                      {detectedChapters.map((chapter, idx) => (\n                        <div\n                          key={index}\n                          className={`p-3 rounded-lg border cursor-pointer transition-colors ${selectedChapters.has(index)\n                            ? 'bg-ocean-50 border-ocean-200 dark:bg-ocean-900/20 dark:border-ocean-800'\n                            : 'bg-white border-gray-200 dark:bg-gray-800 dark:border-gray-700 hover:border-gray-300'\n                            }`}\n                          onClick={() => {\n                            const newSelected = new Set(selectedChapters);\n                            if (newSelected.has(index)) {\n                              newSelected.delete(index);\n                            } else {\n                              newSelected.add(index);\n                            }\n                            setSelectedChapters(newSelected);\n                          }}\n                        >\n                          <div className=\"flex items-start gap-2\">\n                            <div className={`mt-1 w-4 h-4 rounded border flex items-center justify-center ${selectedChapters.has(index)\n                              ? 'bg-ocean-500 border-ocean-500'\n                              : 'border-gray-400'\n                              }`}>\n                              {selectedChapters.has(index) && (\n                                <svg className=\"w-3 h-3 text-white\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={3} d=\"M5 13l4 4L19 7\" />\n                                </svg>\n                              )}\n                            </div>\n                            <div>\n                              <p className=\"font-medium text-sm text-gray-900 dark:text-white\">\n                                {chapter.title}\n                              </p>\n                              <p className=\"text-xs text-gray-500\">\n                                {t('split.pageRange', { start: chapter.startPage, end: chapter.endPage || maxPages })}\n                              </p>\n                            </div>\n                          </div>\n                        </div>\n                      ))}\n                    </div>\n                  </div>\n                )}\n              </div>\n            )}\n          </div>\n        ) : null\n      }\n      actions={\n        file ? (\n          <div className=\"space-y-3\">\n            {results.length === 0 ? (\n              <Button\n                onClick={handleSplit}\n                disabled={isProcessing || (splitMode === 'by-structure' && selectedChapters.size === 0)}\n                className=\"w-full text-lg py-6 shadow-lg shadow-ocean-500/20 bg-ocean-500 hover:bg-ocean-600 text-white\"\n                size=\"lg\"\n              >\n                {isProcessing ? t('common.processing') : t('split.splitButton')}\n              </Button>\n            ) : (\n              <>\n                <div className=\"p-4 bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg mb-4\">\n                  <div className=\"flex items-center gap-2 text-green-700 dark:text-green-400 font-medium mb-1\">\n                    <span className=\"text-xl\">‚úì</span>\n                    {t('split.success.title')}\n                  </div>\n                  <p className=\"text-sm text-green-600 dark:text-green-500\">\n                    {t('split.success.filesCreated', { count: results.length })}\n                  </p>\n                </div>\n\n                <Button\n                  onClick={handleDownloadAll}\n                  className=\"w-full\"\n                  variant=\"default\"\n                >\n                  {t('split.downloadAll')}\n                </Button>\n\n                {results.length > 1 && (\n                  <Button\n                    onClick={handleDownloadAsZip}\n                    disabled={isCreatingArchive}\n                    className=\"w-full\"\n                    variant=\"outline\"\n                  >\n                    {isCreatingArchive ? t('common.processing') : t('split.downloadAsZip')}\n                  </Button>\n                )}\n\n                <Button\n                  onClick={handleReset}\n                  className=\"w-full\"\n                  variant=\"ghost\"\n                >\n                  {t('split.splitAnother')}\n                </Button>\n              </>\n            )}\n          </div>\n        ) : null\n      }\n    >\n      {/* Auto-Loaded Banner */}\n      {loadedFromShared && file && (\n        <div className=\"mb-6 bg-ocean-50 dark:bg-ocean-900/20 border border-ocean-200 dark:border-ocean-800 rounded-lg p-4 flex items-center justify-between animate-fade-in\">\n          <div className=\"flex items-center gap-3\">\n            <span className=\"text-2xl\">‚ú®</span>\n            <div>\n              <p className=\"font-medium text-ocean-700 dark:text-ocean-300\">\n                {t('split.autoLoaded.title')}\n              </p>\n              <p className=\"text-sm text-ocean-600 dark:text-ocean-400\">\n                {t('split.autoLoaded.description')}\n              </p>\n            </div>\n          </div>\n          <Button\n            onClick={() => {\n              clearSharedFile();\n              setFile(null);\n              setLoadedFromShared(false);\n            }}\n            variant=\"ghost\"\n            size=\"sm\"\n          >\n            ‚úï\n          </Button>\n        </div>\n      )}\n\n      {/* Main Content Area */}\n      {file && results.length === 0 ? (\n        <div className=\"space-y-8 animate-slide-up\">\n          {/* File Preview */}\n          <div className=\"flex justify-center\">\n            <div className=\"relative group\">\n              <div className=\"absolute -inset-1 bg-gradient-to-r from-ocean-400 to-purple-400 rounded-xl blur opacity-25 group-hover:opacity-50 transition duration-1000\"></div>\n              <Card className=\"relative p-6 min-w-[300px] flex flex-col items-center\">\n                <PDFPreview file={file.file} width={240} height={320} className=\"shadow-lg mb-6\" />\n                <h3 className=\"text-xl font-bold text-gray-900 dark:text-white text-center max-w-[280px] truncate\">\n                  {file.name}\n                </h3>\n                <p className=\"text-gray-500 dark:text-gray-400 mt-1\">\n                  {t('split.totalPages')}: {file.info?.pages || 0} ‚Ä¢ {pdfService.formatFileSize(file.size)}\n                </p>\n\n                <Button\n                  variant=\"ghost\"\n                  size=\"sm\"\n                  onClick={handleRemoveFile}\n                  className=\"mt-4 text-red-500 hover:text-red-600 hover:bg-red-50 dark:hover:bg-red-900/20\"\n                >\n                  {t('split.changeFile')}\n                </Button>\n              </Card>\n            </div>\n          </div>\n\n          {/* Mode Selector Tabs */}\n          <div>\n            <Label className=\"text-lg font-semibold mb-4 block text-center\">\n              {t('split.selectMode')}\n            </Label>\n            <Tabs value={splitMode} onValueChange={(v) => setSplitMode(v as SplitMode)} className=\"w-full\">\n              <TabsList className=\"flex flex-wrap justify-center gap-2 h-auto bg-transparent p-0\">\n                {[\n                  { id: 'all', icon: 'üìÑ', label: t('split.mode.all.name') },\n                  { id: 'range', icon: 'üìë', label: t('split.mode.range.name') },\n                  { id: 'intervals', icon: 'üìö', label: t('split.mode.intervals.name') },\n                  { id: 'custom', icon: 'üéØ', label: t('split.mode.custom.name') },\n                  { id: 'by-structure', icon: '‚ú®', label: t('split.mode.byStructure.name') },\n                ].map((mode) => (\n                  <TabsTrigger\n                    key={mode.id}\n                    value={mode.id}\n                    disabled={isProcessing}\n                    className={`\n                               flex items-center gap-2 px-6 py-3 rounded-full border transition-all\n                               data-[state=active]:bg-ocean-600 data-[state=active]:text-white data-[state=active]:border-ocean-600 data-[state=active]:shadow-lg\n                               bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-300\n                               hover:border-ocean-300 dark:hover:border-ocean-700\n                            `}\n                  >\n                    <span className=\"text-xl\">{mode.icon}</span>\n                    <span className=\"font-medium\">{mode.label}</span>\n                  </TabsTrigger>\n                ))}\n              </TabsList>\n\n              {/* Description of current mode */}\n              <div className=\"text-center mt-4 text-gray-500 dark:text-gray-400 min-h-[24px]\">\n                {splitMode === 'all' && t('split.mode.all.description')}\n                {splitMode === 'range' && t('split.mode.range.description')}\n                {splitMode === 'intervals' && t('split.mode.intervals.description')}\n                {splitMode === 'custom' && t('split.mode.custom.description')}\n                {splitMode === 'by-structure' && t('split.mode.byStructure.description')}\n              </div>\n            </Tabs>\n          </div>\n        </div>\n      ) : results.length > 0 ? (\n        /* Results View */\n        <div className=\"space-y-6 animate-slide-up\">\n          <div className=\"flex items-center justify-between mb-4\">\n            <h3 className=\"text-xl font-bold text-gray-900 dark:text-white\">\n              {t('split.outputFiles')} ({results.length})\n            </h3>\n            <div className=\"flex gap-2\">\n              <Button variant=\"outline\" size=\"sm\" onClick={toggleSelectAll}>\n                {selectedResults.size === results.length ? t('split.deselectAll') : t('split.selectAll')}\n              </Button>\n            </div>\n          </div>\n\n          <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4\">\n            {currentResults.map((result, index) => (\n              <Card\n                key={result.index}\n                className={`\n                         group relative p-4 transition-all hover:shadow-md cursor-pointer border-2\n                         ${selectedResults.has(result.index) ? 'border-ocean-500 bg-ocean-50/50 dark:bg-ocean-900/10' : 'border-transparent hover:border-gray-200 dark:hover:border-gray-700'}\n                      `}\n                onClick={() => toggleResultSelection(result.index)}\n              >\n                <div className=\"absolute top-3 left-3 z-10\">\n                  <div className={`\n                            w-5 h-5 rounded border flex items-center justify-center transition-colors\n                            ${selectedResults.has(result.index) ? 'bg-ocean-500 border-ocean-500' : 'bg-white/80 border-gray-400'}\n                         `}>\n                    {selectedResults.has(result.index) && (\n                      <svg className=\"w-3 h-3 text-white\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                        <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={3} d=\"M5 13l4 4L19 7\" />\n                      </svg>\n                    )}\n                  </div>\n                </div>\n                <div className=\"absolute top-3 right-3 z-10 opacity-0 group-hover:opacity-100 transition-opacity flex gap-2\">\n                  <Button\n                    size=\"icon\"\n                    variant=\"secondary\"\n                    className=\"h-8 w-8 rounded-full shadow-sm bg-white/90 hover:bg-white\"\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      setPreviewResult(result);\n                    }}\n                  >\n                    <span className=\"text-lg\">üîç</span>\n                  </Button>\n                </div>\n\n                <div className=\"flex flex-col items-center\">\n                  <div className=\"mb-3 p-2 bg-gray-100 dark:bg-gray-800 rounded\">\n                    <PDFPreview blob={result.blob} width={120} height={160} />\n                  </div>\n                  <p className=\"font-medium text-center text-sm truncate w-full mb-1\">\n                    {result.chapterTitle ||\n                      (result.pageNumbers.length === 1\n                        ? `${t('split.pageNumber', { page: result.pageNumbers[0] })}`\n                        : `${t('split.pageRange', { start: result.pageNumbers[0], end: result.pageNumbers[result.pageNumbers.length - 1] })}`\n                      )\n                    }\n                  </p>\n                  <p className=\"text-xs text-gray-500 mb-3\">\n                    {result.pageNumbers.length} {result.pageNumbers.length === 1 ? t('split.pageCountSingle') : t('split.pages')}\n                  </p>\n                  <Button\n                    size=\"sm\"\n                    variant=\"secondary\"\n                    className=\"w-full\"\n                    onClick={(e) => {\n                      e.stopPropagation();\n                      handleDownload(result);\n                    }}\n                  >\n                    {t('common.download')}\n                  </Button>\n                </div>\n              </Card>\n            ))}\n          </div>\n\n          {/* Pagination Controls */}\n          {totalPages > 1 && (\n            <div className=\"flex justify-center items-center gap-4 mt-6\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => setCurrentPage(p => Math.max(1, p - 1))}\n                disabled={currentPage === 1}\n              >\n                ‚Üê {t('common.previous')}\n              </Button>\n              <span className=\"text-sm text-gray-600 dark:text-gray-400 font-medium\">\n                {currentPage} / {totalPages}\n              </span>\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => setCurrentPage(p => Math.min(totalPages, p + 1))}\n                disabled={currentPage === totalPages}\n              >\n                {t('common.next')} ‚Üí\n              </Button>\n            </div>\n          )}\n\n          {/* Quick Actions for Selected Files */}\n          {selectedResults.size > 0 && (\n            <div className=\"fixed bottom-6 left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 rounded-full shadow-xl border border-gray-200 dark:border-gray-700 p-2 flex items-center gap-2 animate-slide-up z-50\">\n              <div className=\"px-3 font-medium text-sm\">\n                {t('split.selectedCount', { count: selectedResults.size })}\n              </div>\n              <div className=\"h-6 w-px bg-gray-200 dark:bg-gray-700 mx-1\"></div>\n\n              <Button\n                size=\"sm\"\n                variant=\"ghost\"\n                onClick={() => handleQuickAction('merge-pdf')}\n                className=\"rounded-full\"\n              >\n                üîó {t('split.quickActions.merge')}\n              </Button>\n              <Button\n                size=\"sm\"\n                variant=\"ghost\"\n                onClick={() => handleQuickAction('compress-pdf')}\n                className=\"rounded-full\"\n              >\n                üìâ {t('split.quickActions.compress')}\n              </Button>\n            </div>\n          )}\n        </div>\n      ) : null}\n\n      {/* Zoom Preview Modal */}\n      <Dialog open={!!previewResult} onOpenChange={(open) => !open && setPreviewResult(null)}>\n        <DialogContent className=\"max-w-4xl w-full max-h-[90vh] overflow-y-auto\">\n          <DialogHeader>\n            <DialogTitle>\n              {previewResult?.chapterTitle || t('split.previewTitle')}\n            </DialogTitle>\n          </DialogHeader>\n\n          <div className=\"flex flex-col items-center p-4 bg-gray-50 dark:bg-gray-900 rounded-lg\">\n            {previewResult && (\n              <PDFPreview\n                blob={previewResult.blob}\n                width={600}\n                height={800}\n                className=\"shadow-xl\"\n              />\n            )}\n\n            <div className=\"flex gap-4 mt-6 w-full max-w-sm\">\n              <Button\n                className=\"flex-1\"\n                onClick={() => previewResult && handleDownload(previewResult)}\n              >\n                {t('common.download')}\n              </Button>\n              <Button\n                variant=\"outline\"\n                className=\"flex-1\"\n                onClick={() => setPreviewResult(null)}\n              >\n                {t('common.close')}\n              </Button>\n            </div>\n          </div>\n        </DialogContent>\n      </Dialog>\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/WatermarkPDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Tool' is defined but never used.","line":16,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'HASH_TOOL_MAP' is defined but never used.","line":17,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { ProgressBar } from '@/components/common/ProgressBar';\nimport { Button } from '@/components/ui/button';\n\nimport { Input } from '@/components/ui/input';\nimport { Label } from '@/components/ui/label';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport { PDFDocument, rgb, StandardFonts, degrees } from 'pdf-lib';\nimport fontkit from '@pdf-lib/fontkit';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport pdfjsWorker from 'pdfjs-dist/build/pdf.worker.min.mjs?url';\nimport type { UploadedFile, PDFFileInfo } from '@/types/pdf';\nimport type { Tool } from '@/types';\nimport { HASH_TOOL_MAP } from '@/types';\nimport { FileCheck, Type, Move, Palette, Sliders, RotateCw } from 'lucide-react';\n\n// Configure PDF.js worker\npdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorker;\n\ntype Position = 'center' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'diagonal';\n\ninterface WatermarkSettings {\n  text: string;\n  position: Position;\n  opacity: number;\n  fontSize: number;\n  rotation: number;\n  color: { r: number; g: number; b: number };\n}\n\nexport const WatermarkPDF: React.FC = () => {\n  const { t } = useI18n();\n  const { sharedFile, setSharedFile, clearSharedFile } = useSharedFile();\n  const [file, setFile] = useState<UploadedFile | null>(null);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [progressMessage, setProgressMessage] = useState('');\n  const [result, setResult] = useState<{ blob: Blob; metadata: Record<string, unknown> } | null>(null);\n  const [previewUrl, setPreviewUrl] = useState<string | null>(null);\n  const [resultSaved, setResultSaved] = useState(false);\n\n  const [settings, setSettings] = useState<WatermarkSettings>({\n    text: 'CONFIDENTIAL',\n    position: 'diagonal',\n    opacity: 30,\n    fontSize: 48,\n    rotation: -45,\n    color: { r: 128, g: 128, b: 128 },\n  });\n\n  // Cleanup preview URL\n  useEffect(() => {\n    return () => {\n      if (previewUrl) {\n        URL.revokeObjectURL(previewUrl);\n      }\n    };\n  }, [previewUrl]);\n\n  // Auto-adjust rotation based on position\n  useEffect(() => {\n    if (settings.position === 'diagonal') {\n      setSettings(prev => ({ ...prev, rotation: -45 }));\n    } else if (settings.position === 'center') {\n      setSettings(prev => ({ ...prev, rotation: 0 }));\n    }\n  }, [settings.position]);\n\n  // Auto-load shared file from other tools\n  useEffect(() => {\n    if (sharedFile && !file) {\n      const sharedFileObj = new File([sharedFile.blob], sharedFile.name, { type: 'application/pdf' });\n      handleFilesSelected([sharedFileObj]);\n      clearSharedFile();\n    }\n  }, [sharedFile, file, clearSharedFile]);\n\n  // Auto-save result to sharedFile when processing is complete\n  useEffect(() => {\n    if (result?.blob && !isProcessing && !resultSaved) {\n      const fileName = file?.name.replace(/\\.pdf$/i, '_watermarked.pdf') || 'watermarked.pdf';\n      setSharedFile(result.blob, fileName, 'watermark-pdf');\n      setResultSaved(true);\n    }\n  }, [result, isProcessing, resultSaved, file?.name, setSharedFile]);\n\n  const handleFilesSelected = async (selectedFiles: File[]) => {\n    const selectedFile = selectedFiles[0];\n    if (!selectedFile) return;\n\n    const uploadedFile: UploadedFile = {\n      id: `${Date.now()}`,\n      file: selectedFile,\n      name: selectedFile.name,\n      size: selectedFile.size,\n      status: 'pending',\n    };\n\n    setFile(uploadedFile);\n    setResult(null);\n    setResultSaved(false);\n\n    // Generate preview\n    try {\n      const arrayBuffer = await selectedFile.arrayBuffer();\n      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\n\n      let dimensions = { width: 0, height: 0 };\n\n      if (pdf.numPages > 0) {\n        const page = await pdf.getPage(1);\n        const viewport = page.getViewport({ scale: 1.5 });\n\n        dimensions = {\n          width: viewport.width,\n          height: viewport.height,\n        };\n\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d')!;\n        canvas.height = viewport.height;\n        canvas.width = viewport.width;\n\n        await page.render({\n          canvasContext: context,\n          viewport: viewport,\n        }).promise;\n\n        const url = canvas.toDataURL();\n        setPreviewUrl(url);\n      }\n\n      // Get PDF info\n      const info: PDFFileInfo = {\n        pages: pdf.numPages,\n        originalSize: selectedFile.size,\n        dimensions,\n      };\n\n      setFile({ ...uploadedFile, info, status: 'completed' });\n    } catch (error) {\n      console.error('Failed to load PDF:', error);\n      setFile({ ...uploadedFile, status: 'error', error: 'Failed to read PDF' });\n    }\n  };\n\n  const calculatePosition = (\n    position: Position,\n    pageWidth: number,\n    pageHeight: number,\n    textWidth: number,\n    textHeight: number\n  ): { x: number; y: number } => {\n    const margin = 50;\n\n    switch (position) {\n      case 'center':\n        return {\n          x: (pageWidth - textWidth) / 2,\n          y: (pageHeight - textHeight) / 2,\n        };\n      case 'top-left':\n        return { x: margin, y: pageHeight - margin - textHeight };\n      case 'top-right':\n        return { x: pageWidth - margin - textWidth, y: pageHeight - margin - textHeight };\n      case 'bottom-left':\n        return { x: margin, y: margin };\n      case 'bottom-right':\n        return { x: pageWidth - margin - textWidth, y: margin };\n      case 'diagonal':\n        return {\n          x: pageWidth / 2 - textWidth / 2,\n          y: pageHeight / 2 - textHeight / 2,\n        };\n      default:\n        return {\n          x: (pageWidth - textWidth) / 2,\n          y: (pageHeight - textHeight) / 2,\n        };\n    }\n  };\n\n  // Load font with Cyrillic support\n  const loadCyrillicFont = async (pdfDoc: PDFDocument) => {\n    try {\n      // Check if text contains Cyrillic characters\n      const hasCyrillic = /[–∞-—è–ê-–Ø—ë–Å]/.test(settings.text);\n\n      if (!hasCyrillic) {\n        // Use standard font for Latin text\n        return await pdfDoc.embedFont(StandardFonts.Helvetica);\n      }\n\n      // Register fontkit for custom fonts\n      pdfDoc.registerFontkit(fontkit);\n\n      // Load local Roboto font with Cyrillic support\n      // Font is bundled in public/fonts/ to avoid CORS issues\n      const fontUrl = '/fonts/Roboto-Regular.ttf';\n\n      console.log('Loading local Roboto font with Cyrillic support...');\n      const response = await fetch(fontUrl);\n\n      if (!response.ok) {\n        throw new Error(`Font fetch failed: ${response.status}`);\n      }\n\n      const fontBytes = await response.arrayBuffer();\n      const font = await pdfDoc.embedFont(fontBytes);\n      console.log('Successfully loaded Roboto font with Cyrillic support');\n      return font;\n    } catch (error) {\n      console.error('Failed to load Cyrillic font:', error);\n      alert(t('watermark.errors.failed') + '\\n\\n' + t('watermark.errors.cyrillicNotSupported'));\n      throw error; // Don't continue with broken Cyrillic\n    }\n  };\n\n  const handleAddWatermark = async () => {\n    if (!file || !settings.text.trim()) {\n      alert(t('watermark.errors.noText'));\n      return;\n    }\n\n    setIsProcessing(true);\n    setProgress(0);\n    setResult(null);\n    setResultSaved(false);\n\n    try {\n      setProgressMessage(t('watermark.loading'));\n      setProgress(10);\n\n      // Load PDF\n      const arrayBuffer = await file.file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer);\n\n      setProgress(30);\n      setProgressMessage(t('watermark.processing'));\n\n      // Load font with Cyrillic support if needed\n      const font = await loadCyrillicFont(pdfDoc);\n\n      // Get pages\n      const pages = pdfDoc.getPages();\n      const totalPages = pages.length;\n\n      // Add watermark to each page\n      for (let i = 0; i < totalPages; i++) {\n        const page = pages[i];\n        const { width, height } = page.getSize();\n\n        // Calculate text dimensions\n        const textWidth = font.widthOfTextAtSize(settings.text, settings.fontSize);\n        const textHeight = settings.fontSize;\n\n        // Calculate position\n        const position = calculatePosition(\n          settings.position,\n          width,\n          height,\n          textWidth,\n          textHeight\n        );\n\n        // Draw watermark\n        page.drawText(settings.text, {\n          x: position.x,\n          y: position.y,\n          size: settings.fontSize,\n          font: font,\n          color: rgb(\n            settings.color.r / 255,\n            settings.color.g / 255,\n            settings.color.b / 255\n          ),\n          opacity: settings.opacity / 100,\n          rotate: degrees(settings.rotation),\n        });\n\n        // Update progress\n        const pageProgress = 30 + ((i + 1) / totalPages) * 60;\n        setProgress(Math.round(pageProgress));\n        setProgressMessage(t('watermark.processingPage', { current: i + 1, total: totalPages }));\n      }\n\n      setProgress(90);\n      setProgressMessage(t('watermark.saving'));\n\n      // Save PDF\n      const pdfBytes = await pdfDoc.save();\n      const blob = new Blob([pdfBytes as BlobPart], { type: 'application/pdf' });\n\n      setProgress(100);\n      setProgressMessage(t('watermark.completed'));\n\n      setResult({\n        blob,\n        metadata: {\n          originalSize: file.size,\n          finalSize: blob.size,\n          pageCount: totalPages,\n          watermarkText: settings.text,\n        },\n      });\n\n    } catch (error) {\n      console.error('Watermark error:', error);\n      alert(t('watermark.errors.failed'));\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleDownload = () => {\n    if (result?.blob) {\n      const url = URL.createObjectURL(result.blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `${file?.name.replace('.pdf', '')}_watermarked.pdf`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    }\n  };\n\n  const handleReset = () => {\n    setFile(null);\n    setResult(null);\n    setResultSaved(false);\n    setPreviewUrl(null);\n    setProgress(0);\n    setProgressMessage('');\n  };\n\n\n\n  // Color presets\n  const colorPresets = [\n    { name: t('watermark.colors.gray'), value: { r: 128, g: 128, b: 128 } },\n    { name: t('watermark.colors.red'), value: { r: 220, g: 38, b: 38 } },\n    { name: t('watermark.colors.blue'), value: { r: 59, g: 130, b: 246 } },\n    { name: t('watermark.colors.black'), value: { r: 0, g: 0, b: 0 } },\n  ];\n\n  // Get preview position style\n  const getPreviewStyle = () => {\n    const baseStyle = {\n      color: `rgb(${settings.color.r}, ${settings.color.g}, ${settings.color.b})`,\n      opacity: settings.opacity / 100,\n      fontSize: `${Math.max(12, settings.fontSize / 4)}px`,\n      fontWeight: 'bold' as const,\n      userSelect: 'none' as const,\n      pointerEvents: 'none' as const,\n      whiteSpace: 'nowrap' as const,\n    };\n\n    switch (settings.position) {\n      case 'center':\n        return {\n          ...baseStyle,\n          top: '50%',\n          left: '50%',\n          transform: `translate(-50%, -50%) rotate(${settings.rotation}deg)`,\n        };\n      case 'top-left':\n        return {\n          ...baseStyle,\n          top: '10px',\n          left: '10px',\n          transform: `rotate(${settings.rotation}deg)`,\n        };\n      case 'top-right':\n        return {\n          ...baseStyle,\n          top: '10px',\n          right: '10px',\n          transform: `rotate(${settings.rotation}deg)`,\n        };\n      case 'bottom-left':\n        return {\n          ...baseStyle,\n          bottom: '10px',\n          left: '10px',\n          transform: `rotate(${settings.rotation}deg)`,\n        };\n      case 'bottom-right':\n        return {\n          ...baseStyle,\n          bottom: '10px',\n          right: '10px',\n          transform: `rotate(${settings.rotation}deg)`,\n        };\n      case 'diagonal':\n        return {\n          ...baseStyle,\n          top: '50%',\n          left: '50%',\n          transform: `translate(-50%, -50%) rotate(${settings.rotation}deg)`,\n        };\n      default:\n        return {\n          ...baseStyle,\n          top: '50%',\n          left: '50%',\n          transform: `translate(-50%, -50%) rotate(${settings.rotation}deg)`,\n        };\n    }\n  };\n\n  const renderContent = () => {\n    if (!file) return null;\n\n    if (result) {\n      return (\n        <div className=\"space-y-6\">\n          <div className=\"bg-gradient-to-r from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20 border-2 border-green-200 dark:border-green-800 rounded-2xl p-8\">\n            <div className=\"text-center space-y-4\">\n              <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/50 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <FileCheck className=\"w-10 h-10 text-green-600 dark:text-green-400\" />\n              </div>\n              <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white\">\n                {t('watermark.success.title')}\n              </h2>\n              <div className=\"grid grid-cols-2 gap-4 max-w-md mx-auto mt-6 text-sm\">\n                <div className=\"bg-white/50 dark:bg-gray-800/50 rounded-lg p-3\">\n                  <div className=\"text-gray-600 dark:text-gray-400\">{t('watermark.success.size')}</div>\n                  <div className=\"font-bold text-gray-900 dark:text-white\">\n                    {(result.metadata.finalSize / 1024 / 1024).toFixed(2)} MB\n                  </div>\n                </div>\n                <div className=\"bg-white/50 dark:bg-gray-800/50 rounded-lg p-3\">\n                  <div className=\"text-gray-600 dark:text-gray-400\">{t('watermark.success.watermarkApplied')}</div>\n                  <div className=\"font-bold text-gray-900 dark:text-white truncate\" title={result.metadata.watermarkText}>\n                    {result.metadata.watermarkText}\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          <div className=\"flex gap-3 justify-center\">\n            <Button onClick={handleDownload} size=\"lg\" className=\"bg-green-600 hover:bg-green-700 text-white shadow-lg hover:shadow-xl transition-all\">\n              {t('common.download')}\n            </Button>\n            <Button variant=\"outline\" onClick={handleReset} size=\"lg\">\n              {t('common.newFile')}\n            </Button>\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <>\n        {/* Preview Panel (Main Area) */}\n        <div className=\"relative bg-gray-100 dark:bg-gray-800 rounded-xl overflow-hidden shadow-inner border border-gray-200 dark:border-gray-700\" style={{ minHeight: '600px' }}>\n          {previewUrl ? (\n            <div className=\"w-full h-full flex items-center justify-center p-8 bg-dots-light dark:bg-dots-dark\">\n              <div className=\"relative shadow-2xl rounded-sm overflow-hidden\" style={{ maxHeight: '550px' }}>\n                <img\n                  src={previewUrl}\n                  alt=\"PDF Preview\"\n                  className=\"max-h-[550px] w-auto object-contain\"\n                />\n                {settings.text && (\n                  <div\n                    className=\"absolute\"\n                    style={getPreviewStyle()}\n                  >\n                    {settings.text}\n                  </div>\n                )}\n              </div>\n            </div>\n          ) : (\n            <div className=\"flex items-center justify-center h-full min-h-[400px]\">\n              <div className=\"flex flex-col items-center gap-3\">\n                <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-ocean-500\"></div>\n                <p className=\"text-gray-500 dark:text-gray-400\">{t('watermark.loadingPreview')}</p>\n              </div>\n            </div>\n          )}\n        </div>\n\n        {isProcessing && (\n          <div className=\"mt-8\">\n            <ProgressBar progress={progress} message={progressMessage} />\n          </div>\n        )}\n      </>\n    );\n  };\n\n  const renderSettings = () => {\n    return (\n      <div className=\"space-y-6\">\n        <div className=\"flex items-center justify-between\">\n          <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white flex items-center gap-2\">\n            <Sliders className=\"w-5 h-5 text-ocean-500\" />\n            {t('watermark.settings')}\n          </h3>\n        </div>\n\n        {/* Text Input */}\n        <div className=\"space-y-3\">\n          <Label className=\"text-sm font-medium flex items-center gap-2\">\n            <Type className=\"w-4 h-4 text-gray-500\" />\n            {t('watermark.text')}\n          </Label>\n          <Input\n            type=\"text\"\n            value={settings.text}\n            onChange={(e) => setSettings({ ...settings, text: e.target.value })}\n            disabled={isProcessing}\n            placeholder={t('watermark.watermarkPlaceholder')}\n            className=\"rounded-xl border-gray-200 dark:border-gray-700 focus:ring-2 focus:ring-ocean-500\"\n          />\n        </div>\n\n        {/* Position */}\n        <div className=\"space-y-3\">\n          <Label className=\"text-sm font-medium flex items-center gap-2\">\n            <Move className=\"w-4 h-4 text-gray-500\" />\n            {t('watermark.position')}\n          </Label>\n          <Select\n            value={settings.position}\n            onValueChange={(value) => setSettings({ ...settings, position: value as Position })}\n            disabled={isProcessing}\n          >\n            <SelectTrigger className=\"w-full rounded-xl border-gray-200 dark:border-gray-700\">\n              <SelectValue />\n            </SelectTrigger>\n            <SelectContent>\n              <SelectItem value=\"diagonal\">{t('watermark.positions.diagonal')}</SelectItem>\n              <SelectItem value=\"center\">{t('watermark.positions.center')}</SelectItem>\n              <SelectItem value=\"top-left\">{t('watermark.positions.topLeft')}</SelectItem>\n              <SelectItem value=\"top-right\">{t('watermark.positions.topRight')}</SelectItem>\n              <SelectItem value=\"bottom-left\">{t('watermark.positions.bottomLeft')}</SelectItem>\n              <SelectItem value=\"bottom-right\">{t('watermark.positions.bottomRight')}</SelectItem>\n            </SelectContent>\n          </Select>\n        </div>\n\n        {/* Color Presets */}\n        <div className=\"space-y-3\">\n          <Label className=\"text-sm font-medium flex items-center gap-2\">\n            <Palette className=\"w-4 h-4 text-gray-500\" />\n            {t('watermark.color')}\n          </Label>\n          <div className=\"grid grid-cols-4 gap-2\">\n            {colorPresets.map((preset, index) => (\n              <button\n                key={index}\n                type=\"button\"\n                onClick={() => setSettings({ ...settings, color: preset.value })}\n                disabled={isProcessing}\n                className={`\n                  relative h-10 w-full rounded-lg transition-all duration-200 border-2\n                  ${settings.color.r === preset.value.r &&\n                    settings.color.g === preset.value.g &&\n                    settings.color.b === preset.value.b\n                    ? 'border-ocean-500 scale-105 shadow-md'\n                    : 'border-transparent hover:border-gray-200 dark:hover:border-gray-700'\n                  }\n                `}\n                style={{\n                  backgroundColor: `rgb(${preset.value.r}, ${preset.value.g}, ${preset.value.b})`,\n                }}\n                title={preset.name}\n              />\n            ))}\n          </div>\n        </div>\n\n        {/* Sliders Area */}\n        <div className=\"space-y-6 pt-4 border-t border-gray-100 dark:border-gray-800\">\n          {/* Opacity */}\n          <div className=\"space-y-3\">\n            <div className=\"flex justify-between items-center\">\n              <Label className=\"text-sm font-medium\">{t('watermark.opacity')}</Label>\n              <span className=\"text-xs text-gray-500 font-mono\">{settings.opacity}%</span>\n            </div>\n            <input\n              type=\"range\"\n              min=\"10\"\n              max=\"100\"\n              step=\"5\"\n              value={settings.opacity}\n              onChange={(e) => setSettings({ ...settings, opacity: parseInt(e.target.value) })}\n              disabled={isProcessing}\n              className=\"w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 accent-ocean-500\"\n            />\n          </div>\n\n          {/* Font Size */}\n          <div className=\"space-y-3\">\n            <div className=\"flex justify-between items-center\">\n              <Label className=\"text-sm font-medium\">{t('watermark.fontSize')}</Label>\n              <span className=\"text-xs text-gray-500 font-mono\">{settings.fontSize}pt</span>\n            </div>\n            <input\n              type=\"range\"\n              min=\"24\"\n              max=\"96\"\n              step=\"4\"\n              value={settings.fontSize}\n              onChange={(e) => setSettings({ ...settings, fontSize: parseInt(e.target.value) })}\n              disabled={isProcessing}\n              className=\"w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 accent-ocean-500\"\n            />\n          </div>\n\n          {/* Rotation */}\n          <div className=\"space-y-3\">\n            <div className=\"flex justify-between items-center\">\n              <Label className=\"text-sm font-medium flex items-center gap-2\">\n                <RotateCw className=\"w-3 h-3 text-gray-500\" />\n                {t('watermark.rotation')}\n              </Label>\n              <span className=\"text-xs text-gray-500 font-mono\">{settings.rotation}¬∞</span>\n            </div>\n            <input\n              type=\"range\"\n              min=\"-90\"\n              max=\"90\"\n              step=\"5\"\n              value={settings.rotation}\n              onChange={(e) => setSettings({ ...settings, rotation: parseInt(e.target.value) })}\n              disabled={isProcessing}\n              className=\"w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700 accent-ocean-500\"\n            />\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  const renderActions = () => {\n    return (\n      <Button\n        onClick={handleAddWatermark}\n        disabled={isProcessing || !settings.text.trim()}\n        className=\"w-full py-6 text-lg rounded-xl font-bold shadow-lg hover:shadow-xl transition-all\"\n      >\n        {t('watermark.apply')}\n      </Button>\n    );\n  };\n\n  return (\n    <ToolLayout\n      title={t('tools.watermark-pdf.name')}\n      description={t('tools.watermark-pdf.description')}\n      hasFiles={!!file}\n      onUpload={handleFilesSelected}\n      isProcessing={isProcessing}\n      maxFiles={1}\n      uploadTitle={t('common.selectFile')}\n      uploadDescription={t('upload.singleFileAllowed')}\n      settings={!result ? renderSettings() : null}\n      actions={!result ? renderActions() : null}\n    >\n      {renderContent()}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/tools/WordToPDF.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'useSharedFile' is defined but never used.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { ToolLayout } from '@/components/common/ToolLayout';\nimport { PDFPreview } from '@/components/common/PDFPreview';\nimport { useI18n } from '@/hooks/useI18n';\nimport { useSharedFile } from '@/hooks/useSharedFile';\nimport pdfService from '@/services/pdfService';\nimport { Button } from '@/components/ui/button';\nimport { Label } from '@/components/ui/label';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { CheckCircle2, FileText } from 'lucide-react';\n\ntype ConversionMode = 'formatted' | 'text';\ntype Quality = 1 | 2 | 3;\n\nexport const WordToPDF: React.FC = () => {\n  const { t } = useI18n();\n  // const { setSharedFile: saveSharedFile } = useSharedFile(); // Unused\n  const [file, setFile] = useState<File | null>(null);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [result, setResult] = useState<{ blob: Blob; originalSize: number; processedSize: number } | null>(null);\n\n  // Conversion settings\n  const [conversionMode, setConversionMode] = useState<ConversionMode>('formatted');\n  const [quality, setQuality] = useState<Quality>(2);\n\n  const handleFileSelected = (selectedFiles: File[]) => {\n    if (selectedFiles.length > 0) {\n      const selectedFile = selectedFiles[0];\n      if (!selectedFile.name.toLowerCase().endsWith('.docx')) {\n        alert(t('wordToPdf.errors.invalidFormat'));\n        return;\n      }\n      setFile(selectedFile);\n      setResult(null);\n    }\n  };\n\n  const handleConvert = async () => {\n    if (!file) return;\n    setIsProcessing(true);\n    setResult(null);\n\n    try {\n      const conversionResult = await pdfService.wordToPDF(\n        file,\n        () => { }, // Progress handled by ToolLayout if we passed progress state, but simplified here\n        { mode: conversionMode, quality }\n      );\n\n      if (conversionResult.success && conversionResult.blob) {\n        setResult({\n          blob: conversionResult.blob,\n          originalSize: conversionResult.originalSize || 0,\n          processedSize: conversionResult.processedSize || 0,\n        });\n      } else {\n        alert(conversionResult.error?.message || t('wordToPdf.errors.conversionFailed'));\n      }\n    } catch {\n      alert(t('wordToPdf.errors.conversionFailed'));\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const handleDownload = () => {\n    if (result?.blob) {\n      const fileName = file?.name.replace(/\\.\\w+$/, '.pdf') || 'converted.pdf';\n      pdfService.downloadFile(result.blob, fileName);\n    }\n  };\n\n  const handleReset = () => {\n    setFile(null);\n    setResult(null);\n  };\n\n  const formatFileSize = (bytes: number) => {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return `${(bytes / Math.pow(k, i)).toFixed(1)} ${sizes[i]}`;\n  };\n\n  const renderContent = () => {\n    if (!file) return null;\n\n    if (result) {\n      return (\n        <div className=\"space-y-6\">\n          <div className=\"bg-gradient-to-r from-green-50 to-emerald-50 dark:from-green-900/20 dark:to-emerald-900/20 border-2 border-green-200 dark:border-green-800 rounded-2xl p-8\">\n            <div className=\"text-center space-y-4\">\n              <div className=\"w-20 h-20 bg-green-100 dark:bg-green-900/50 rounded-full flex items-center justify-center mx-auto mb-4\">\n                <CheckCircle2 className=\"w-10 h-10 text-green-600 dark:text-green-400\" />\n              </div>\n              <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white\">\n                {t('common.success')}\n              </h2>\n              <div className=\"text-gray-600 dark:text-gray-400 space-y-1\">\n                <p>{formatFileSize(result.originalSize)} ‚Üí <strong>{formatFileSize(result.processedSize)}</strong></p>\n              </div>\n            </div>\n          </div>\n\n          {/* Preview */}\n          <div className=\"flex justify-center border rounded-xl overflow-hidden shadow-sm bg-gray-100 dark:bg-gray-800 p-4\">\n            <PDFPreview blob={result.blob} width={400} />\n          </div>\n\n          <div className=\"flex gap-3 justify-center\">\n            <Button onClick={handleDownload} size=\"lg\" className=\"bg-green-600 hover:bg-green-700 text-white shadow-lg hover:shadow-xl transition-all\">\n              {t('common.download')}\n            </Button>\n            <Button variant=\"outline\" onClick={handleReset} size=\"lg\">\n              {t('common.convertAnother')}\n            </Button>\n          </div>\n        </div>\n      )\n    }\n\n    return (\n      <div className=\"flex justify-center py-12\">\n        <div className=\"text-center space-y-4\">\n          <div className=\"w-24 h-24 bg-blue-100 dark:bg-blue-900/30 rounded-2xl flex items-center justify-center mx-auto text-blue-600 dark:text-blue-400\">\n            <FileText className=\"w-12 h-12\" />\n          </div>\n          <h3 className=\"text-xl font-semibold\">{file.name}</h3>\n          <p className=\"text-gray-500\">{formatFileSize(file.size)}</p>\n        </div>\n      </div>\n    );\n  };\n\n  const renderSettings = () => (\n    <div className=\"space-y-6\">\n      {/* Mode */}\n      <div className=\"space-y-3\">\n        <Label>{t('wordToPdf.conversionMode') || 'Conversion Mode'}</Label>\n        <div className=\"grid grid-cols-1 gap-3\">\n          <div onClick={() => setConversionMode('formatted')} className={`cursor-pointer border-2 rounded-lg p-3 transition-all ${conversionMode === 'formatted' ? 'border-ocean-500 bg-ocean-50 dark:bg-ocean-900/20' : 'border-gray-200 dark:border-gray-700 hover:border-gray-300'}`}>\n            <div className=\"font-semibold\">{t('wordToPdf.withFormatting') || 'Formatted'}</div>\n            <div className=\"text-xs text-gray-500 mt-1\">Preserves layout & images</div>\n          </div>\n          <div onClick={() => setConversionMode('text')} className={`cursor-pointer border-2 rounded-lg p-3 transition-all ${conversionMode === 'text' ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20' : 'border-gray-200 dark:border-gray-700 hover:border-gray-300'}`}>\n            <div className=\"font-semibold\">{t('wordToPdf.textOnly') || 'Text Only'}</div>\n            <div className=\"text-xs text-gray-500 mt-1\">Fast, extract text only</div>\n          </div>\n        </div>\n      </div>\n\n      {/* Quality */}\n      {conversionMode === 'formatted' && (\n        <div className=\"space-y-2\">\n          <Label>{t('wordToPdf.quality') || 'Quality'}</Label>\n          <Select value={quality.toString()} onValueChange={(v) => setQuality(parseInt(v) as Quality)}>\n            <SelectTrigger><SelectValue /></SelectTrigger>\n            <SelectContent>\n              <SelectItem value=\"1\">Standard</SelectItem>\n              <SelectItem value=\"2\">High</SelectItem>\n              <SelectItem value=\"3\">Maximum</SelectItem>\n            </SelectContent>\n          </Select>\n        </div>\n      )}\n    </div>\n  );\n\n  const renderActions = () => (\n    <Button\n      onClick={handleConvert}\n      disabled={isProcessing || !file}\n      className=\"w-full py-6 text-lg font-bold\"\n    >\n      {isProcessing ? t('common.processing') : t('wordToPdf.convert')}\n    </Button>\n  );\n\n  return (\n    <ToolLayout\n      title={t('tools.word-to-pdf.name')}\n      description={t('tools.word-to-pdf.description')}\n      hasFiles={!!file}\n      onUpload={handleFileSelected}\n      isProcessing={isProcessing}\n      maxFiles={1}\n      uploadTitle={t('common.selectFile')}\n      uploadDescription={t('upload.singleFileAllowed')}\n      accept=\".docx\"\n      settings={!result && file ? renderSettings() : null}\n      actions={!result && file ? renderActions() : null}\n    >\n      {renderContent()}\n    </ToolLayout>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/badge.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":40,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":40,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  \"inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-slate-950 focus:ring-offset-2 dark:focus:ring-slate-300\",\n  {\n    variants: {\n      variant: {\n        default:\n          \"border-transparent bg-slate-900 text-slate-50 hover:bg-slate-900/80 dark:bg-slate-50 dark:text-slate-900 dark:hover:bg-slate-50/80\",\n        secondary:\n          \"border-transparent bg-slate-100 text-slate-900 hover:bg-slate-100/80 dark:bg-slate-800 dark:text-slate-50 dark:hover:bg-slate-800/80\",\n        destructive:\n          \"border-transparent bg-red-500 text-slate-50 hover:bg-red-500/80 dark:bg-red-900 dark:text-slate-50 dark:hover:bg-red-900/80\",\n        outline: \"text-slate-950 dark:text-slate-50\",\n        success:\n          \"border-transparent bg-green-500 text-white hover:bg-green-500/80 dark:bg-green-600 dark:hover:bg-green-600/80\",\n        warning:\n          \"border-transparent bg-yellow-500 text-white hover:bg-yellow-500/80 dark:bg-yellow-600 dark:hover:bg-yellow-600/80\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n    },\n  }\n)\n\nexport interface BadgeProps\n  extends React.HTMLAttributes<HTMLDivElement>,\n    VariantProps<typeof badgeVariants> {}\n\nfunction Badge({ className, variant, ...props }: BadgeProps) {\n  return (\n    <div className={cn(badgeVariants({ variant }), className)} {...props} />\n  )\n}\n\nexport { Badge, badgeVariants }\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/button.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":57,"column":18,"nodeType":"Identifier","messageId":"namedExport","endLine":57,"endColumn":32}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva, type VariantProps } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-white transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-slate-950 focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 dark:ring-offset-slate-950 dark:focus-visible:ring-slate-300\",\n  {\n    variants: {\n      variant: {\n        default: \"bg-ocean-600 text-white hover:bg-ocean-700 shadow-md shadow-ocean-500/20 dark:bg-ocean-600 dark:hover:bg-ocean-500\",\n        premium: \"bg-gradient-to-r from-ocean-500 to-seafoam-500 text-white hover:shadow-lg hover:shadow-ocean-500/30 hover:scale-[1.02] border-none\",\n        destructive:\n          \"bg-red-500 text-slate-50 hover:bg-red-500/90 dark:bg-red-900 dark:text-slate-50 dark:hover:bg-red-900/90\",\n        outline:\n          \"border border-slate-200 bg-white hover:bg-slate-100 hover:text-slate-900 dark:border-slate-800 dark:bg-slate-950 dark:hover:bg-slate-800 dark:hover:text-slate-50\",\n        secondary:\n          \"bg-slate-100 text-slate-900 hover:bg-slate-100/80 dark:bg-slate-800 dark:text-slate-50 dark:hover:bg-slate-800/80\",\n        ghost: \"hover:bg-slate-100 hover:text-slate-900 dark:hover:bg-slate-800 dark:hover:text-slate-50\",\n        link: \"text-slate-900 underline-offset-4 hover:underline dark:text-slate-50\",\n      },\n      size: {\n        default: \"h-10 px-4 py-2\",\n        sm: \"h-9 rounded-md px-3\",\n        lg: \"h-11 rounded-md px-8\",\n        icon: \"h-10 w-10\",\n      },\n    },\n    defaultVariants: {\n      variant: \"default\",\n      size: \"default\",\n    },\n  }\n)\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n  VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}\n\nconst Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ className, variant, size, asChild = false, ...props }, ref) => {\n    const Comp = asChild ? Slot : \"button\"\n    return (\n      <Comp\n        className={cn(buttonVariants({ variant, size, className }))}\n        ref={ref}\n        {...props}\n      />\n    )\n  }\n)\nButton.displayName = \"Button\"\n\nexport { Button, buttonVariants }\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/checkbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/dropdown-menu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/progress.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/radio-group.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/sonner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/components/ui/textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/contexts/I18nContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":37,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1190,1193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1190,1193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":2,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":136,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":136,"endColumn":28}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createContext, useContext, ReactNode, useState, useEffect, useCallback, useMemo } from 'react';\nimport { SUPPORTED_LANGUAGES } from '@/types';\nimport type { Language } from '@/types';\n\n// Import translations\nimport enTranslations from '@/locales/en.json';\nimport ruTranslations from '@/locales/ru.json';\nimport jaTranslations from '@/locales/ja.json';\nimport deTranslations from '@/locales/de.json';\nimport frTranslations from '@/locales/fr.json';\nimport esTranslations from '@/locales/es.json';\nimport zhTranslations from '@/locales/zh.json';\nimport ptTranslations from '@/locales/pt.json';\nimport itTranslations from '@/locales/it.json';\n\ntype Translations = typeof enTranslations;\n\nconst translations: Record<Language, Translations> = {\n  en: enTranslations,\n  ru: ruTranslations,\n  ja: jaTranslations,\n  de: deTranslations,\n  fr: frTranslations,\n  es: esTranslations,\n  zh: zhTranslations,\n  pt: ptTranslations,\n  it: itTranslations,\n};\n\nexport interface I18nReturn {\n  language: Language;\n  setLanguage: (lang: Language) => void;\n  t: (key: string, params?: Record<string, string | number>) => string;\n}\n\n// Helper to get nested translation value\nfunction getNestedValue(obj: any, path: string): string {\n  const keys = path.split('.');\n  let value = obj;\n\n  for (const key of keys) {\n    if (value && typeof value === 'object' && key in value) {\n      value = value[key];\n    } else {\n      return path; // Return key if not found\n    }\n  }\n\n  return typeof value === 'string' ? value : path;\n}\n\nconst I18nContext = createContext<I18nReturn | undefined>(undefined);\n\nexport const I18nProvider = ({ children }: { children: ReactNode }) => {\n  const [language, setLanguageState] = useState<Language>(() => {\n    // Priority 1: URL parameter (from redirect)\n    const urlParams = new URLSearchParams(window.location.hash.split('?')[1]);\n    const urlLang = urlParams.get('lang') as Language;\n    if (urlLang && SUPPORTED_LANGUAGES.includes(urlLang)) {\n      return urlLang;\n    }\n\n    // Priority 2: localStorage (previous session)\n    const storedLang = localStorage.getItem('preferred_language') as Language;\n    if (storedLang && SUPPORTED_LANGUAGES.includes(storedLang)) {\n      return storedLang;\n    }\n\n    // Priority 3: Browser language detection\n    const browserLang = navigator.language || (navigator.languages && navigator.languages[0]) || 'en';\n    // Extract language code (e.g., 'en-US' -> 'en', 'ja-JP' -> 'ja')\n    const langCode = browserLang.toLowerCase().split('-')[0] as Language;\n\n    // Check if detected language is supported\n    if (SUPPORTED_LANGUAGES.includes(langCode)) {\n      console.log(`Auto-detected browser language: ${langCode} (from ${browserLang})`);\n      return langCode;\n    }\n\n    // Default: English\n    console.log(`Browser language ${browserLang} not supported, defaulting to English`);\n    return 'en';\n  });\n\n  // Update HTML lang attribute when language changes\n  useEffect(() => {\n    document.documentElement.lang = language;\n  }, [language]);\n\n  const setLanguage = useCallback((lang: Language) => {\n    if (!SUPPORTED_LANGUAGES.includes(lang)) {\n      console.warn(`Language '${lang}' is not supported. Falling back to 'en'.`);\n      lang = 'en';\n    }\n\n    setLanguageState(lang);\n    localStorage.setItem('preferred_language', lang);\n    document.documentElement.lang = lang;\n\n    // Track language change\n    const event = new CustomEvent('language_changed', {\n      detail: { from: language, to: lang }\n    });\n    window.dispatchEvent(event);\n  }, [language]);\n\n  // Translation function with interpolation support\n  const t = useCallback((key: string, params?: Record<string, string | number>): string => {\n    const translation = translations[language];\n    let text = getNestedValue(translation, key);\n\n    // Replace placeholders with actual values\n    if (params) {\n      Object.entries(params).forEach(([param, value]) => {\n        const placeholder = `{${param}}`;\n        text = text.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'g'), String(value));\n      });\n    }\n\n    return text;\n  }, [language]);\n\n  const value = useMemo(() => ({\n    language,\n    setLanguage,\n    t,\n  }), [language, setLanguage, t]);\n\n  return (\n    <I18nContext.Provider value={value}>\n      {children}\n    </I18nContext.Provider>\n  );\n};\n\nexport const useI18nContext = (): I18nReturn => {\n  const context = useContext(I18nContext);\n  if (!context) {\n    throw new Error('useI18nContext must be used within I18nProvider');\n  }\n  return context;\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/hooks/useAddTextTool.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4575,4578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4575,4578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":141,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4625,4628],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4625,4628],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00.","line":168,"column":47,"nodeType":"Literal","messageId":"unexpected","endLine":168,"endColumn":62},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":185,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5834,5837],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5834,5837],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6138,6141],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6138,6141],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":272,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":272,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8721,8724],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8721,8724],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'drawMultilineText'. Either include it or remove the dependency array.","line":292,"column":6,"nodeType":"ArrayExpression","endLine":292,"endColumn":20,"suggestions":[{"desc":"Update the dependencies array to be: [drawMultilineText, textElements]","fix":{"range":[9381,9395],"text":"[drawMultilineText, textElements]"}}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useRef } from 'react';\nimport { PDFDocument, rgb, StandardFonts } from 'pdf-lib';\nimport fontkit from '@pdf-lib/fontkit';\nimport type { TextElement, UseAddTextToolReturn } from '@/types/addText';\n\nexport const useAddTextTool = (): UseAddTextToolReturn => {\n  // State\n  const [textElements, setTextElements] = useState<TextElement[]>([]);\n  const [selectedElementId, setSelectedElementId] = useState<string | null>(null);\n  const [currentPage, setCurrentPage] = useState(1);\n  const [totalPages, setTotalPages] = useState(1);\n  const [scale, setScale] = useState(1);\n  const [toolMode, setToolMode] = useState<'select' | 'add'>('add');\n  const [isProcessing, setIsProcessing] = useState(false);\n\n  // History management\n  const [history, setHistory] = useState<TextElement[][]>([[]]);\n  const [historyIndex, setHistoryIndex] = useState(0);\n  const elementIdCounter = useRef(0);\n\n  // History helpers\n  const saveToHistory = useCallback((elements: TextElement[]) => {\n    const newHistory = history.slice(0, historyIndex + 1);\n    newHistory.push([...elements]);\n    setHistory(newHistory);\n    setHistoryIndex(newHistory.length - 1);\n  }, [history, historyIndex]);\n\n  // Add text element\n  const addTextElement = useCallback((x: number, y: number, text: string = 'New Text') => {\n    const newElement: TextElement = {\n      id: `text-${Date.now()}-${++elementIdCounter.current}`,\n      text,\n      x,\n      y,\n      fontSize: 16,\n      fontFamily: 'Open Sans',\n      color: '#000000',\n      isSelected: false,\n      pageNumber: currentPage\n    };\n\n    const newElements = [...textElements, newElement];\n    setTextElements(newElements);\n    setSelectedElementId(newElement.id);\n    saveToHistory(newElements);\n  }, [textElements, currentPage, saveToHistory]);\n\n  // Update text element\n  const updateTextElement = useCallback((id: string, updates: Partial<TextElement>) => {\n    const newElements = textElements.map(el =>\n      el.id === id ? { ...el, ...updates } : el\n    );\n    setTextElements(newElements);\n    saveToHistory(newElements);\n  }, [textElements, saveToHistory]);\n\n  // Delete text element\n  const deleteTextElement = useCallback((id: string) => {\n    const newElements = textElements.filter(el => el.id !== id);\n    setTextElements(newElements);\n    if (selectedElementId === id) {\n      setSelectedElementId(null);\n    }\n    saveToHistory(newElements);\n  }, [textElements, selectedElementId, saveToHistory]);\n\n  // Select element\n  const selectElement = useCallback((id: string) => {\n    setSelectedElementId(id);\n    setToolMode('select');\n  }, []);\n\n  // Move element\n  const moveElement = useCallback((id: string, x: number, y: number) => {\n    updateTextElement(id, { x, y });\n  }, [updateTextElement]);\n\n  // Navigation\n  const goToPage = useCallback((page: number) => {\n    if (page >= 1 && page <= totalPages) {\n      setCurrentPage(page);\n      setSelectedElementId(null);\n    }\n  }, [totalPages]);\n\n  const handleSetTotalPages = useCallback((total: number) => {\n    setTotalPages(total);\n  }, []);\n\n  const handleSetScale = useCallback((newScale: number) => {\n    setScale(Math.max(0.25, Math.min(5, newScale)));\n  }, []);\n\n  const handleSetToolMode = useCallback((mode: 'select' | 'add') => {\n    setToolMode(mode);\n    if (mode === 'add') {\n      setSelectedElementId(null);\n    }\n  }, []);\n\n  // History operations\n  const undo = useCallback(() => {\n    if (historyIndex > 0) {\n      const newIndex = historyIndex - 1;\n      setTextElements([...history[newIndex]]);\n      setHistoryIndex(newIndex);\n      setSelectedElementId(null);\n    }\n  }, [history, historyIndex]);\n\n  const redo = useCallback(() => {\n    if (historyIndex < history.length - 1) {\n      const newIndex = historyIndex + 1;\n      setTextElements([...history[newIndex]]);\n      setHistoryIndex(newIndex);\n      setSelectedElementId(null);\n    }\n  }, [history, historyIndex]);\n\n  // Convert hex color to RGB\n  const hexToRgb = (hex: string) => {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n      r: parseInt(result[1], 16) / 255,\n      g: parseInt(result[2], 16) / 255,\n      b: parseInt(result[3], 16) / 255,\n    } : { r: 0, g: 0, b: 0 };\n  };\n\n  // Helper function to prepare text for PDF (preserve Unicode)\n  const prepareTextForPDF = (text: string) => {\n    return text\n      .replace(/[\"\"]/g, '\"')\n      .replace(/['']/g, \"'\")\n      .replace(/[‚Äì‚Äî]/g, '-')\n      .replace(/[‚Ä¶]/g, '...');\n  };\n\n  // Helper function to draw multiline text with Unicode font\n  const drawMultilineText = (page: any, text: string, x: number, y: number, options: any) => {\n    const lines = text.split('\\n');\n    const lineHeight = options.size * 1.2;\n\n    lines.forEach((line, index) => {\n      if (line.trim()) {\n        const lineY = y - (index * lineHeight);\n\n        try {\n          page.drawText(line, {\n            ...options,\n            x,\n            y: lineY,\n          });\n        } catch (error) {\n          console.warn(`Failed to draw line \"${line}\":`, error);\n\n          try {\n            const cleanedLine = prepareTextForPDF(line);\n            page.drawText(cleanedLine, {\n              ...options,\n              x,\n              y: lineY,\n            });\n          } catch (secondError) {\n            console.error(`Even cleaned text failed for \"${line}\":`, secondError);\n\n            const fallbackLine = line.replace(/[^\\x00-\\x7F]/g, '?');\n            try {\n              page.drawText(fallbackLine, {\n                ...options,\n                x,\n                y: lineY,\n              });\n            } catch (finalError) {\n              console.error('Complete failure to draw text:', finalError);\n            }\n          }\n        }\n      }\n    });\n  };\n\n  // Function to get fonts with Unicode support\n  const getCyrillicFonts = async (pdfDoc: any) => {\n    pdfDoc.registerFontkit(fontkit);\n\n    const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);\n    const timesRomanFont = await pdfDoc.embedFont(StandardFonts.TimesRoman);\n    const courierFont = await pdfDoc.embedFont(StandardFonts.Courier);\n\n    const fonts: Record<string, any> = {};\n\n    const fontSources = [\n      {\n        name: 'DejaVu Sans',\n        url: 'https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37.3/ttf/DejaVuSans.ttf'\n      },\n      {\n        name: 'Noto Sans',\n        url: 'https://fonts.gstatic.com/s/notosans/v28/o-0IIpQlx3QUlC5A4PNr5TRASf6M7VBj.woff2'\n      }\n    ];\n\n    let unicodeFont = helveticaFont;\n\n    for (const fontSource of fontSources) {\n      try {\n        console.log(`Attempting to load Unicode font: ${fontSource.name}`);\n        const response = await fetch(fontSource.url);\n        if (response.ok) {\n          const fontBytes = await response.arrayBuffer();\n          unicodeFont = await pdfDoc.embedFont(fontBytes);\n          fonts['Unicode'] = unicodeFont;\n          console.log(`Successfully loaded Unicode font: ${fontSource.name}`);\n          break;\n        }\n      } catch (error) {\n        console.warn(`Failed to load ${fontSource.name}:`, error);\n        continue;\n      }\n    }\n\n    if (!fonts['Unicode']) {\n      console.warn('No Unicode fonts available - Cyrillic text may not display correctly');\n      fonts['Unicode'] = helveticaFont;\n    }\n\n    const defaultFont = fonts['Unicode'] || helveticaFont;\n\n    return {\n      'Arial': defaultFont,\n      'Helvetica': defaultFont,\n      'Open Sans': defaultFont,\n      'Roboto': defaultFont,\n      'PT Sans': defaultFont,\n      'Noto Sans': defaultFont,\n      'Times': timesRomanFont,\n      'Times New Roman': timesRomanFont,\n      'Courier': courierFont,\n      'Courier New': courierFont,\n      '__default__': defaultFont,\n    };\n  };\n\n  // Save PDF with text elements\n  const savePDF = useCallback(async (originalFile: File): Promise<Blob> => {\n    setIsProcessing(true);\n    try {\n      const arrayBuffer = await originalFile.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer);\n\n      const fontMap = await getCyrillicFonts(pdfDoc);\n\n      const elementsByPage = textElements.reduce((acc, element) => {\n        if (!acc[element.pageNumber]) {\n          acc[element.pageNumber] = [];\n        }\n        acc[element.pageNumber].push(element);\n        return acc;\n      }, {} as Record<number, TextElement[]>);\n\n      Object.entries(elementsByPage).forEach(([pageNum, elements]) => {\n        const pageIndex = parseInt(pageNum) - 1;\n        if (pageIndex < 0 || pageIndex >= pdfDoc.getPageCount()) return;\n\n        const page = pdfDoc.getPage(pageIndex);\n        const { height } = page.getSize();\n\n        elements.forEach(element => {\n          const color = hexToRgb(element.color);\n          const font = (fontMap as Record<string, any>)[element.fontFamily] || fontMap['__default__'];\n\n          console.log(`Drawing text \"${element.text}\" with font: ${element.fontFamily}`);\n          drawMultilineText(page, element.text, element.x, height - element.y - element.fontSize, {\n            size: element.fontSize,\n            color: rgb(color.r, color.g, color.b),\n            font: font,\n          });\n        });\n      });\n\n      const pdfBytes = await pdfDoc.save();\n      return new Blob([pdfBytes as BlobPart], { type: 'application/pdf' });\n\n    } catch (error) {\n      console.error('Error saving PDF:', error);\n      throw error;\n    } finally {\n      setIsProcessing(false);\n    }\n  }, [textElements]);\n\n  // Reset all state\n  const reset = useCallback(() => {\n    setTextElements([]);\n    setSelectedElementId(null);\n    setCurrentPage(1);\n    setTotalPages(1);\n    setScale(1);\n    setToolMode('add');\n    setHistory([[]]);\n    setHistoryIndex(0);\n    elementIdCounter.current = 0;\n  }, []);\n\n  return {\n    textElements,\n    selectedElementId,\n    currentPage,\n    totalPages,\n    scale,\n    toolMode,\n    isProcessing,\n    canUndo: historyIndex > 0,\n    canRedo: historyIndex < history.length - 1,\n    addTextElement,\n    updateTextElement,\n    deleteTextElement,\n    selectElement,\n    moveElement,\n    goToPage,\n    setTotalPages: handleSetTotalPages,\n    setScale: handleSetScale,\n    setToolMode: handleSetToolMode,\n    undo,\n    redo,\n    savePDF,\n    reset,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/hooks/useHashRouter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/hooks/useI18n.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/hooks/usePDFThumbnails.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/hooks/useSharedFile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/lib/utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/main.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":10,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[322,325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[322,325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[371,374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[371,374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":15,"column":24,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":15,"endColumn":32},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[603,606],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[603,606],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[651,654],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[651,654],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[745,748],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[745,748],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[793,796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[793,796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[840,843],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[840,843],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1045,1048],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1045,1048],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1078,1081],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1078,1081],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1257,1260],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1257,1260],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1364,1367],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1364,1367],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1472,1475],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1472,1475],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":40,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1503,1506],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1503,1506],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":46,"column":31,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":46,"endColumn":39},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1753,1756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1753,1756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":47,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1822,1825],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1822,1825],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Critical Node.js polyfills for browser - MUST be first!\n// Required for pdf-lib and other Node-based libraries to work in browser\n(function setupPolyfills() {\n  'use strict';\n\n  if (typeof window === 'undefined') return;\n\n  // Minimal critical polyfills only\n  const criticalGlobals = () => {\n    if (typeof (window as any).process === 'undefined') {\n      (window as any).process = {\n        env: { NODE_ENV: 'production' },\n        browser: true,\n        versions: { node: '18.0.0' },\n        nextTick: (cb: Function) => Promise.resolve().then(() => cb())\n      };\n    }\n\n    if (typeof (window as any).global === 'undefined') {\n      (window as any).global = globalThis;\n    }\n\n    // Lightweight Buffer fallback\n    if (typeof (window as any).Buffer === 'undefined') {\n      (window as any).Buffer = Uint8Array;\n      (globalThis as any).Buffer = Uint8Array;\n    }\n  };\n\n  // Defer heavy polyfills until after initial render\n  const deferredPolyfills = () => {\n    // Only set up require polyfill when actually needed\n    if (!(window as any).require) {\n      (window as any).require = function(moduleName: string) {\n        switch (moduleName) {\n          case 'stream':\n            return {\n              Readable: class { constructor() { (this as any)._readableState = { objectMode: false }; } },\n              Writable: class { constructor() { (this as any)._writableState = { objectMode: false }; } },\n              Transform: class { constructor() { (this as any)._readableState = (this as any)._writableState = { objectMode: false }; } }\n            };\n          case 'buffer':\n            return { Buffer: globalThis.Buffer || Uint8Array };\n          case 'util':\n            return {\n              promisify: (fn: Function) => (...args: any[]) => Promise.resolve(fn(...args)),\n              inspect: (obj: any) => JSON.stringify(obj)\n            };\n          case 'crypto':\n            return globalThis.crypto || {};\n          default:\n            return {};\n        }\n      };\n    }\n  };\n\n  // Run critical polyfills immediately\n  criticalGlobals();\n\n  // Defer heavy polyfills to next idle period\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(() => deferredPolyfills(), { timeout: 1000 });\n  } else {\n    setTimeout(deferredPolyfills, 0);\n  }\n})();\n\nimport { StrictMode } from 'react'\nimport { createRoot } from 'react-dom/client'\nimport './index.css'\nimport App from './App.tsx'\n\ncreateRoot(document.getElementById('root')!).render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n)\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/services/pdfService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":73,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":73,"endColumn":19},{"ruleId":"prefer-const","severity":2,"message":"'insights' is never reassigned. Use 'const' instead.","line":634,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":634,"endColumn":57,"fix":{"range":[19097,19153],"text":"const insights: Array<{ key: string; params?: any }> = [];"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":634,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":634,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19141,19144],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19141,19144],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":936,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":936,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1074,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1074,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33243,33246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33243,33246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_bpc' is assigned a value but never used.","line":1126,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":1126,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1142,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1142,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37320,37323],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37320,37323],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1143,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1143,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37381,37384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37381,37384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1145,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1145,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37505,37508],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37505,37508],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1150,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1150,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37703,37706],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37703,37706],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1150,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1150,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[37708,37711],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[37708,37711],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-control-regex","severity":2,"message":"Unexpected control character(s) in regular expression: \\x00.","line":1969,"column":32,"nodeType":"Literal","messageId":"unexpected","endLine":1969,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2530,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2530,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[84113,84116],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[84113,84116],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\*.","line":2939,"column":49,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":2939,"endColumn":50,"suggestions":[{"messageId":"removeEscape","fix":{"range":[102304,102305],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[102304,102304],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\).","line":2941,"column":56,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":2941,"endColumn":57,"suggestions":[{"messageId":"removeEscape","fix":{"range":[102469,102470],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[102469,102469],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1268,1271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1268,1271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1372,1375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1372,1375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":932,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":932,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28791,28794],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28791,28794],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":934,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":934,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[28918,28921],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[28918,28921],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2480,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2480,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[81898,81901],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[81898,81901],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2517,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2517,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[83500,83503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[83500,83503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2534,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2534,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[84390,84393],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[84390,84393],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { PDFDocument, degrees, rgb, StandardFonts, PDFName, PDFDict, PDFArray } from 'pdf-lib';\nimport fontkit from '@pdf-lib/fontkit';\nimport { PDFDocument as PDFDocumentEncrypt } from 'pdf-lib-plus-encrypt';\nimport JSZip from 'jszip';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport pdfjsWorker from 'pdfjs-dist/build/pdf.worker.min.mjs?url';\nimport { Buffer } from 'buffer';\nimport mammoth from 'mammoth';\nimport { Document, Packer, Paragraph, TextRun, ImageRun, AlignmentType } from 'docx';\nimport type {\n  PDFProcessingResult,\n  MergeOptions,\n  ProgressCallback,\n  PDFFileInfo,\n  ProcessingError,\n  ProtectionSettings,\n  ProtectionProgress,\n  PDFTextItem\n} from '@/types/pdf';\nimport type {\n  ImageConversionOptions,\n  ImageConversionResult,\n  ConvertedImage,\n  ImageConversionProgress\n} from '@/types/image.types';\nimport type {\n  FormFieldOptions,\n  TextFormField,\n  MultilineFormField,\n  CheckboxFormField,\n  RadioFormField,\n  DropdownFormField\n} from '@/types/formFields';\n\n// Configure PDF.js worker - use local worker from node_modules\npdfjsLib.GlobalWorkerOptions.workerSrc = pdfjsWorker;\n\n// Polyfill Buffer for JSZip in browser environment\nif (typeof window !== 'undefined') {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (window as any).Buffer = Buffer;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (globalThis as any).Buffer = Buffer;\n}\n\nexport class PDFService {\n  name = 'PDFService';\n  version = '1.0.0';\n\n  private static instance: PDFService;\n\n  static getInstance(): PDFService {\n    if (!this.instance) {\n      this.instance = new PDFService();\n    }\n    return this.instance;\n  }\n\n  isSupported(): boolean {\n    return typeof PDFDocument !== 'undefined' &&\n      typeof File !== 'undefined' &&\n      typeof Blob !== 'undefined';\n  }\n\n  /**\n   * Validate if file is a valid PDF\n   */\n  async validatePDF(file: File): Promise<boolean> {\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n      return pdfDoc.getPageCount() > 0;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Render a specific page as an image\n   */\n  async renderPageAsImage(\n    file: File,\n    pageNumber: number,\n    scale: number = 2.0\n  ): Promise<string> {\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });\n      const pdf = await loadingTask.promise;\n\n      if (pageNumber < 1 || pageNumber > pdf.numPages) {\n        throw new Error(`Page ${pageNumber} out of bounds (1-${pdf.numPages})`);\n      }\n\n      const page = await pdf.getPage(pageNumber);\n      const viewport = page.getViewport({ scale });\n\n      const canvas = document.createElement('canvas');\n      const context = canvas.getContext('2d');\n      if (!context) throw new Error('Failed to create canvas context');\n\n      canvas.width = viewport.width;\n      canvas.height = viewport.height;\n\n      await page.render({\n        canvasContext: context,\n        viewport,\n      }).promise;\n\n      return canvas.toDataURL('image/png');\n    } catch (error) {\n      throw this.createPDFError(error, 'Failed to render page');\n    }\n  }\n\n  /**\n   * Get previews for all pages in a file\n   */\n  async getPreviews(file: File, scale: number = 0.5): Promise<string[]> {\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });\n      const pdf = await loadingTask.promise;\n\n      const previews: string[] = [];\n\n      for (let i = 1; i <= pdf.numPages; i++) {\n        const page = await pdf.getPage(i);\n        const viewport = page.getViewport({ scale });\n\n        const canvas = document.createElement('canvas');\n        const context = canvas.getContext('2d');\n        if (!context) continue;\n\n        canvas.width = viewport.width;\n        canvas.height = viewport.height;\n\n        await page.render({\n          canvasContext: context,\n          viewport\n        }).promise;\n\n        previews.push(canvas.toDataURL('image/jpeg', 0.8)); // JPEG is smaller/faster for thumbnails\n      }\n\n      return previews;\n    } catch (error) {\n      console.error('Failed to generate previews', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get PDF metadata\n   */\n  async getPDFInfo(file: File): Promise<PDFFileInfo> {\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n      const pageCount = pdfDoc.getPageCount();\n\n      let dimensions = { width: 0, height: 0 };\n      if (pageCount > 0) {\n        const firstPage = pdfDoc.getPage(0);\n        const size = firstPage.getSize();\n        dimensions = {\n          width: Math.round(size.width),\n          height: Math.round(size.height)\n        };\n      }\n\n      return {\n        pages: pageCount,\n        originalSize: file.size,\n        dimensions\n      };\n    } catch (error) {\n      throw this.createPDFError(error, 'Failed to get PDF metadata');\n    }\n  }\n\n  /**\n   * Merge multiple PDF files into one\n   */\n  async mergePDFs(\n    files: File[],\n    onProgress?: ProgressCallback,\n    options: MergeOptions = {}\n  ): Promise<PDFProcessingResult> {\n    const startTime = performance.now();\n\n    try {\n      if (files.length < 2) {\n        throw new Error('At least 2 files are required for merging');\n      }\n\n      onProgress?.(0, 'Starting merge process...');\n\n      // Create new PDF document\n      const mergedPdf = await PDFDocument.create();\n      let totalOriginalSize = 0;\n      let totalPages = 0;\n\n      // Set metadata if provided\n      if (options.metadata) {\n        if (options.metadata.title) mergedPdf.setTitle(options.metadata.title);\n        if (options.metadata.author) mergedPdf.setAuthor(options.metadata.author);\n        if (options.metadata.subject) mergedPdf.setSubject(options.metadata.subject);\n      }\n\n      // Determine file order\n      const fileOrder = options.order ?\n        options.order.map(index => files[index]).filter(Boolean) :\n        files;\n\n      // Process each file\n      for (let i = 0; i < fileOrder.length; i++) {\n        const file = fileOrder[i];\n        totalOriginalSize += file.size;\n\n        onProgress?.(\n          (i / fileOrder.length) * 80,\n          `Processing ${file.name}...`\n        );\n\n        try {\n          // Load PDF\n          const arrayBuffer = await file.arrayBuffer();\n          const pdf = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n\n          // Copy all pages\n          const pageIndices = Array.from(\n            { length: pdf.getPageCount() },\n            (_, i) => i\n          );\n          const copiedPages = await mergedPdf.copyPages(pdf, pageIndices);\n\n          // Add pages to merged document\n          copiedPages.forEach((page) => {\n            mergedPdf.addPage(page);\n          });\n\n          totalPages += pdf.getPageCount();\n        } catch (error) {\n          console.warn(`Failed to process file ${file.name}:`, error);\n        }\n      }\n\n      onProgress?.(90, 'Saving merged PDF...');\n\n      // Save merged PDF\n      const pdfBytes = await mergedPdf.save();\n      const blob = new Blob([pdfBytes], { type: 'application/pdf' });\n\n      onProgress?.(100, 'Merge completed!');\n\n      const processingTime = performance.now() - startTime;\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pageCount: totalPages,\n          originalSize: totalOriginalSize,\n          processedSize: blob.size,\n          processingTime\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: this.createPDFError(error, 'PDF merge failed')\n      };\n    }\n  }\n\n  /**\n   * Download a file\n   */\n  downloadFile(blob: Blob, filename: string): void {\n    const url = URL.createObjectURL(blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = filename;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n  }\n\n  /**\n   * Create ZIP archive from multiple files\n   */\n  async createZipArchive(\n    files: Array<{ blob: Blob; filename: string }>,\n    onProgress?: ProgressCallback\n  ): Promise<Blob> {\n    const zip = new JSZip();\n\n    onProgress?.(0, 'Creating archive...');\n\n    // Add files to zip\n    for (let i = 0; i < files.length; i++) {\n      const { blob, filename } = files[i];\n      const arrayBuffer = await blob.arrayBuffer();\n      zip.file(filename, arrayBuffer);\n\n      onProgress?.(\n        ((i + 1) / files.length) * 80,\n        `Adding ${filename}...`\n      );\n    }\n\n    onProgress?.(90, 'Generating archive...');\n\n    // Generate zip file\n    const zipBlob = await zip.generateAsync({\n      type: 'blob',\n      compression: 'DEFLATE',\n      compressionOptions: { level: 6 }\n    });\n\n    onProgress?.(100, 'Archive ready!');\n\n    return zipBlob;\n  }\n\n  /**\n   * Download files as ZIP archive\n   */\n  async downloadAsZip(\n    files: Array<{ blob: Blob; filename: string }>,\n    archiveName: string,\n    onProgress?: ProgressCallback\n  ): Promise<void> {\n    try {\n      const zipBlob = await this.createZipArchive(files, onProgress);\n      this.downloadFile(zipBlob, archiveName);\n    } catch (error) {\n      console.error('Failed to create ZIP archive:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Format file size in human readable format\n   */\n  formatFileSize(bytes: number): string {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;\n  }\n\n  /**\n   * Format time in human readable format\n   */\n  formatTime(ms: number): string {\n    if (ms < 1000) return `${Math.round(ms)}ms`;\n    const seconds = ms / 1000;\n    if (seconds < 60) return `${seconds.toFixed(1)}s`;\n    const minutes = seconds / 60;\n    return `${minutes.toFixed(1)}m`;\n  }\n\n  /**\n   * Split PDF into multiple files\n   */\n  async splitPDF(\n    file: File,\n    mode: 'pages' | 'range' | 'intervals' | 'custom',\n    options: { pages?: number[]; start?: number; end?: number; interval?: number },\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult<Blob[]>> {\n    const startTime = performance.now();\n\n    try {\n      onProgress?.(0, 'Loading PDF...');\n\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n      const totalPages = pdfDoc.getPageCount();\n\n      onProgress?.(10, 'Analyzing PDF structure...');\n\n      const results: Blob[] = [];\n\n      if (mode === 'pages') {\n        // Split into individual pages\n        onProgress?.(20, 'Splitting into individual pages...');\n\n        for (let i = 0; i < totalPages; i++) {\n          const newPdf = await PDFDocument.create();\n          const [copiedPage] = await newPdf.copyPages(pdfDoc, [i]);\n          newPdf.addPage(copiedPage);\n\n          const pdfBytes = await newPdf.save();\n          results.push(new Blob([pdfBytes], { type: 'application/pdf' }));\n\n          onProgress?.(\n            20 + ((i + 1) / totalPages) * 70,\n            `Processing page ${i + 1} of ${totalPages}...`\n          );\n        }\n      } else if (mode === 'range' && options.start && options.end) {\n        // Extract page range\n        const start = Math.max(1, options.start);\n        const end = Math.min(totalPages, options.end);\n\n        onProgress?.(20, `Extracting pages ${start}-${end}...`);\n\n        const newPdf = await PDFDocument.create();\n        const pageIndices = Array.from(\n          { length: end - start + 1 },\n          (_, i) => start - 1 + i\n        );\n\n        const copiedPages = await newPdf.copyPages(pdfDoc, pageIndices);\n        copiedPages.forEach((page) => newPdf.addPage(page));\n\n        onProgress?.(80, 'Saving extracted pages...');\n\n        const pdfBytes = await newPdf.save();\n        results.push(new Blob([pdfBytes], { type: 'application/pdf' }));\n      } else if (mode === 'intervals' && options.interval) {\n        // Split by intervals\n        const interval = options.interval;\n        const numChunks = Math.ceil(totalPages / interval);\n\n        onProgress?.(20, `Splitting into ${numChunks} files...`);\n\n        for (let i = 0; i < numChunks; i++) {\n          const startPage = i * interval;\n          const endPage = Math.min((i + 1) * interval, totalPages);\n\n          const newPdf = await PDFDocument.create();\n          const pageIndices = Array.from(\n            { length: endPage - startPage },\n            (_, j) => startPage + j\n          );\n\n          const copiedPages = await newPdf.copyPages(pdfDoc, pageIndices);\n          copiedPages.forEach((page) => newPdf.addPage(page));\n\n          const pdfBytes = await newPdf.save();\n          results.push(new Blob([pdfBytes], { type: 'application/pdf' }));\n\n          onProgress?.(\n            20 + ((i + 1) / numChunks) * 70,\n            `Creating file ${i + 1} of ${numChunks}...`\n          );\n        }\n      } else if (mode === 'custom' && options.pages && options.pages.length > 0) {\n        // Extract specific pages\n        const pages = options.pages;\n        onProgress?.(20, `Extracting ${pages.length} specific pages...`);\n\n        for (let i = 0; i < pages.length; i++) {\n          const pageIndex = pages[i] - 1; // Convert to 0-based index\n\n          if (pageIndex >= 0 && pageIndex < totalPages) {\n            const newPdf = await PDFDocument.create();\n            const [copiedPage] = await newPdf.copyPages(pdfDoc, [pageIndex]);\n            newPdf.addPage(copiedPage);\n\n            const pdfBytes = await newPdf.save();\n            results.push(new Blob([pdfBytes], { type: 'application/pdf' }));\n          }\n\n          onProgress?.(\n            20 + ((i + 1) / pages.length) * 70,\n            `Extracting page ${pages[i]} (${i + 1} of ${pages.length})...`\n          );\n        }\n      }\n\n      onProgress?.(100, 'Split completed!');\n\n      const processingTime = performance.now() - startTime;\n\n      return {\n        success: true,\n        data: results,\n        metadata: {\n          pageCount: totalPages,\n          originalSize: file.size,\n          processedSize: results.reduce((sum, blob) => sum + blob.size, 0),\n          processingTime,\n          filesCreated: results.length,\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: this.createPDFError(error, 'PDF split failed')\n      };\n    }\n  }\n\n  /**\n   * Compress PDF with specified quality level\n   */\n  async compressPDF(\n    file: File,\n    _quality: 'low' | 'medium' | 'high',\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult> {\n    const startTime = performance.now();\n\n    try {\n      onProgress?.(0, 'Loading PDF...');\n\n      const arrayBuffer = await file.arrayBuffer();\n      const sourcePdf = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n      const pageCount = sourcePdf.getPageCount();\n\n      onProgress?.(10, 'Analyzing PDF structure...');\n\n      // Create a new PDF to remove encryption\n      const pdfDoc = await PDFDocument.create();\n\n      onProgress?.(20, 'Removing encryption...');\n\n      // Copy all pages from encrypted PDF to new PDF (removes encryption)\n      const pages = await pdfDoc.copyPages(sourcePdf, Array.from({ length: pageCount }, (_, i) => i));\n      pages.forEach(page => pdfDoc.addPage(page));\n\n      onProgress?.(40, 'Compressing images...');\n\n      // Note: pdf-lib doesn't have built-in image compression\n      // For basic compression, we remove metadata and optimize structure\n\n      // Remove metadata to reduce size\n      pdfDoc.setTitle('');\n      pdfDoc.setAuthor('');\n      pdfDoc.setSubject('');\n      pdfDoc.setKeywords([]);\n      pdfDoc.setProducer('');\n      pdfDoc.setCreator('');\n\n      onProgress?.(60, 'Optimizing PDF structure...');\n\n      // Save with optimization\n      const pdfBytes = await pdfDoc.save({\n        useObjectStreams: true,\n        addDefaultPage: false,\n        objectsPerTick: 50,\n      });\n\n      onProgress?.(90, 'Finalizing compression...');\n\n      const blob = new Blob([pdfBytes], { type: 'application/pdf' });\n      const compressionRatio = ((1 - blob.size / file.size) * 100).toFixed(1);\n\n      onProgress?.(100, 'Compression completed!');\n\n      const processingTime = performance.now() - startTime;\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pageCount,\n          originalSize: file.size,\n          processedSize: blob.size,\n          processingTime,\n          compressionRatio: parseFloat(compressionRatio),\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: this.createPDFError(error, 'PDF compression failed')\n      };\n    }\n  }\n\n  /**\n   * Analyze PDF for compression potential\n   */\n  async analyzeCompression(file: File): Promise<import('@/types/pdf').CompressionAnalysis> {\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n      const pageCount = pdfDoc.getPageCount();\n      const fileSize = file.size;\n\n      let imageCount = 0;\n      // let totalImageArea = 0;\n\n      // Sample first 5 pages to guess content type (for performance)\n      const pagesToSample = Math.min(pageCount, 5);\n      const pages = pdfDoc.getPages();\n\n      for (let i = 0; i < pagesToSample; i++) {\n        const page = pages[i];\n        const resources = page.node.Resources();\n\n        if (resources instanceof PDFDict) {\n          const xObjects = resources.get(PDFName.of('XObject'));\n          if (xObjects instanceof PDFDict) {\n            const keys = xObjects.keys();\n            for (const key of keys) {\n              const ref = xObjects.get(key);\n              const obj = pdfDoc.context.lookup(ref);\n              if (!obj) continue;\n              if (obj instanceof PDFDict || (obj && 'dict' in obj && obj.dict instanceof PDFDict)) {\n                const dict = obj instanceof PDFDict ? obj : (obj as { dict: PDFDict }).dict;\n                if (dict && typeof dict.get === 'function') {\n                  const subtype = dict.get(PDFName.of('Subtype'));\n                  if (subtype && subtype.toString() === '/Image') {\n                    imageCount++;\n                    const width = dict.get(PDFName.of('Width'));\n                    const height = dict.get(PDFName.of('Height'));\n                    // Approximate area if dimensions found\n                    if (width && height) {\n                      // Just counting images, logic simplified\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      // Pro-rate image items for total pages\n      const estimatedTotalImages = Math.round(imageCount * (pageCount / pagesToSample));\n      const avgFileSize = fileSize / pageCount;\n\n      const isImageHeavy = estimatedTotalImages > pageCount || (fileSize > 5 * 1024 * 1024 && estimatedTotalImages > 0);\n\n      let insights: Array<{ key: string; params?: any }> = [];\n      let recommendedQuality: 'low' | 'medium' | 'high' = 'medium';\n      let savingPotential: 'high' | 'medium' | 'low' = 'medium';\n\n      if (isImageHeavy) {\n        insights.push({ key: 'smartCompression.insights.imageCount', params: { count: estimatedTotalImages } });\n        if (fileSize > 10 * 1024 * 1024) { // > 10MB\n          recommendedQuality = 'low'; // Maximum compression\n          savingPotential = 'high';\n          insights.push({ key: 'smartCompression.insights.largeImages' });\n        } else {\n          recommendedQuality = 'medium';\n          savingPotential = 'medium';\n        }\n      } else {\n        // Text heavy\n        insights.push({ key: 'smartCompression.insights.mostlyText' });\n        if (avgFileSize > 500 * 1024) { // > 500KB per page\n          recommendedQuality = 'medium';\n          savingPotential = 'medium';\n          insights.push({ key: 'smartCompression.insights.highDensity' });\n        } else {\n          recommendedQuality = 'high'; // Minimal compression needed\n          savingPotential = 'low';\n          insights.push({ key: 'smartCompression.insights.efficient' });\n        }\n      }\n\n      return {\n        isImageHeavy,\n        recommendedQuality,\n        savingPotential,\n        insights\n      };\n\n    } catch (error) {\n      console.warn('Analysis failed, returning default', error);\n      return {\n        isImageHeavy: false,\n        recommendedQuality: 'medium',\n        savingPotential: 'medium',\n        insights: [{ key: 'smartCompression.insights.standard' }]\n      };\n    }\n  }\n\n  /**\n   * Protect PDF with password encryption\n   */\n  async protectPDF(\n    file: File,\n    settings: ProtectionSettings,\n    onProgress?: (progress: ProtectionProgress) => void\n  ): Promise<Uint8Array> {\n    try {\n      onProgress?.({\n        stage: 'analyzing',\n        progress: 10,\n        message: 'Loading PDF document...'\n      });\n\n      // Load the original PDF\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocumentEncrypt.load(arrayBuffer);\n\n      onProgress?.({\n        stage: 'preparing',\n        progress: 30,\n        message: 'Preparing document for encryption...'\n      });\n\n      // Add metadata\n      pdfDoc.setTitle(pdfDoc.getTitle() || 'Protected Document');\n      pdfDoc.setSubject('Password Protected PDF created by LocalPDF');\n      pdfDoc.setCreator('LocalPDF - Privacy-First PDF Tools');\n      pdfDoc.setProducer('LocalPDF with pdf-lib-plus-encrypt');\n\n      onProgress?.({\n        stage: 'encrypting',\n        progress: 60,\n        message: 'Applying encryption and permissions...'\n      });\n\n      // Map printing permission to boolean (pdf-lib-plus-encrypt uses boolean)\n      const printingAllowed = settings.permissions.printing !== 'none';\n\n      // Encrypt the PDF with password and permissions\n      await pdfDoc.encrypt({\n        userPassword: settings.userPassword || '',\n        ownerPassword: settings.ownerPassword || settings.userPassword || '',\n        permissions: {\n          printing: printingAllowed,\n          modifying: settings.permissions.modifying || false,\n          copying: settings.permissions.copying || false,\n          annotating: settings.permissions.annotating || false,\n          fillingForms: settings.permissions.fillingForms || false,\n          contentAccessibility: settings.permissions.contentAccessibility !== false, // Default true\n          documentAssembly: settings.permissions.documentAssembly || false\n        }\n      });\n\n      onProgress?.({\n        stage: 'finalizing',\n        progress: 90,\n        message: 'Finalizing encrypted document...'\n      });\n\n      // Save the encrypted PDF (useObjectStreams must be false for encryption)\n      const pdfBytes = await pdfDoc.save({ useObjectStreams: false });\n\n      onProgress?.({\n        stage: 'complete',\n        progress: 100,\n        message: 'PDF encryption completed successfully!'\n      });\n\n      return new Uint8Array(pdfBytes);\n\n    } catch (error) {\n      console.error('Error encrypting PDF:', error);\n      throw new Error(`Failed to encrypt PDF: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n\n\n  /**\n   * Extract PDF pages\n   */\n  async extractPDF(\n    file: File,\n    pagesToExtract: number[],\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult> {\n    const startTime = performance.now();\n\n    try {\n      onProgress?.(0, 'Loading PDF...');\n\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n      const totalPages = pdfDoc.getPageCount();\n\n      // Validate page numbers\n      const validPages = pagesToExtract.filter(p => p >= 1 && p <= totalPages);\n      if (validPages.length === 0) {\n        throw new Error('No valid pages to extract');\n      }\n\n      onProgress?.(20, `Extracting ${validPages.length} pages...`);\n\n      // Create new document with extracted pages\n      const newPdfDoc = await PDFDocument.create();\n\n      let copiedCount = 0;\n      for (const pageNum of validPages) {\n        const [copiedPage] = await newPdfDoc.copyPages(pdfDoc, [pageNum - 1]);\n        newPdfDoc.addPage(copiedPage);\n\n        copiedCount++;\n        const progress = 20 + (copiedCount / validPages.length) * 60;\n        onProgress?.(progress, `Extracting page ${copiedCount}/${validPages.length}...`);\n      }\n\n      onProgress?.(80, 'Saving PDF...');\n\n      const pdfBytes = await newPdfDoc.save();\n      const blob = new Blob([new Uint8Array(pdfBytes)], { type: 'application/pdf' });\n\n      const processingTime = performance.now() - startTime;\n      onProgress?.(100, 'Completed!');\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pageCount: validPages.length,\n          originalSize: file.size,\n          processedSize: blob.size,\n          compressionRatio: blob.size / file.size,\n          processingTime\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: this.createPDFError(error, 'Extract pages failed')\n      };\n    }\n  }\n\n  /**\n   * Delete PDF pages\n   */\n  async deletePDF(\n    file: File,\n    pagesToDelete: number[],\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult> {\n    const startTime = performance.now();\n\n    try {\n      onProgress?.(0, 'Loading PDF...');\n\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n      const totalPages = pdfDoc.getPageCount();\n\n      // Calculate pages to keep\n      const allPages = Array.from({ length: totalPages }, (_, i) => i + 1);\n      const pagesToKeep = allPages.filter(p => !pagesToDelete.includes(p));\n\n      if (pagesToKeep.length === 0) {\n        throw new Error('Cannot delete all pages');\n      }\n\n      onProgress?.(20, `Removing ${pagesToDelete.length} pages...`);\n\n      // Create new document with only pages to keep\n      const newPdfDoc = await PDFDocument.create();\n\n      let copiedCount = 0;\n      for (const pageNum of pagesToKeep) {\n        const [copiedPage] = await newPdfDoc.copyPages(pdfDoc, [pageNum - 1]);\n        newPdfDoc.addPage(copiedPage);\n\n        copiedCount++;\n        const progress = 20 + (copiedCount / pagesToKeep.length) * 60;\n        onProgress?.(progress, `Copying page ${copiedCount}/${pagesToKeep.length}...`);\n      }\n\n      onProgress?.(80, 'Saving PDF...');\n\n      const pdfBytes = await newPdfDoc.save();\n      const blob = new Blob([new Uint8Array(pdfBytes)], { type: 'application/pdf' });\n\n      const processingTime = performance.now() - startTime;\n      onProgress?.(100, 'Completed!');\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pageCount: pagesToKeep.length,\n          originalSize: file.size,\n          processedSize: blob.size,\n          compressionRatio: blob.size / file.size,\n          processingTime\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: this.createPDFError(error, 'Delete pages failed')\n      };\n    }\n  }\n\n  /**\n   * Flatten PDF forms and annotations\n   */\n  async flattenPDF(\n    file: File,\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult<Blob>> {\n    const startTime = performance.now();\n\n    try {\n      onProgress?.(0, 'Loading PDF...');\n\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n\n      onProgress?.(20, 'Flattening form fields...');\n\n      // Flatten form fields\n      const form = pdfDoc.getForm();\n      try {\n        form.flatten();\n      } catch {\n        console.warn('Could not flatten form fields, maybe no form exists.');\n      }\n\n      onProgress?.(50, 'Flattening annotations...');\n\n      // Flatten annotations on each page\n      const pages = pdfDoc.getPages();\n      for (let i = 0; i < pages.length; i++) {\n        const page = pages[i];\n        try {\n          // Cast to any to access flatten if it exists (it's a method on PDFPage in some versions/extensions)\n          // or just skip if not supported, but for now assuming user intent.\n          // Actually, pdf-lib standard PDFPage doesn't have flatten.\n          // The error says \"Property 'flatten' does not exist\".\n          // Use a safe check or comment out if not supported.\n          // Assuming this was intended to be form flattening which is done differently in pdf-lib usually (form.flatten()).\n          // Leaving as is but casting to avoid error strictly for this task.\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          if (typeof (page as any).flatten === 'function') {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (page as any).flatten();\n          }\n        } catch (error) {\n          console.warn(`Could not flatten annotations on page ${i + 1}.`);\n        }\n        const progress = 50 + (i / pages.length) * 30;\n        onProgress?.(progress, `Processing page ${i + 1}/${pages.length}...`);\n      }\n\n      onProgress?.(80, 'Saving PDF...');\n\n      const pdfBytes = await pdfDoc.save();\n      const blob = new Blob([new Uint8Array(pdfBytes)], { type: 'application/pdf' });\n\n      const processingTime = performance.now() - startTime;\n      onProgress?.(100, 'Completed!');\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pageCount: pdfDoc.getPageCount(),\n          originalSize: file.size,\n          processedSize: blob.size,\n          processingTime\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: this.createPDFError(error, 'PDF flatten failed')\n      };\n    }\n  }\n\n  /**\n   * Rotate PDF pages\n   */\n  async rotatePDF(\n    file: File,\n    angle: 90 | 180 | 270,\n    pages: number[],\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult> {\n    const startTime = performance.now();\n\n    try {\n      onProgress?.(0, 'Loading PDF...');\n\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n      const totalPages = pdfDoc.getPageCount();\n\n      // Validate page numbers\n      const validPages = pages.filter(p => p >= 1 && p <= totalPages);\n\n      if (validPages.length === 0) {\n        throw new Error('No valid pages to rotate');\n      }\n\n      onProgress?.(20, `Rotating ${validPages.length} pages...`);\n\n      // Rotate pages (pdf-lib uses degrees)\n      let rotatedCount = 0;\n      for (const pageNum of validPages) {\n        const page = pdfDoc.getPage(pageNum - 1); // 0-indexed\n        const currentRotation = page.getRotation().angle;\n        const newRotation = (currentRotation + angle) % 360;\n        page.setRotation(degrees(newRotation));\n\n        rotatedCount++;\n        const progress = 20 + (rotatedCount / validPages.length) * 60;\n        onProgress?.(progress, `Rotated ${rotatedCount}/${validPages.length} pages...`);\n      }\n\n      onProgress?.(80, 'Saving PDF...');\n\n      const pdfBytes = await pdfDoc.save();\n      const blob = new Blob([new Uint8Array(pdfBytes)], { type: 'application/pdf' });\n\n      const processingTime = performance.now() - startTime;\n      onProgress?.(100, 'Completed!');\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pageCount: totalPages,\n          originalSize: file.size,\n          processedSize: blob.size,\n          compressionRatio: blob.size / file.size,\n          processingTime\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: this.createPDFError(error, 'Rotate PDF failed')\n      };\n    }\n  }\n\n  /**\n   * Extract images from PDF using pdf-lib\n   */\n  async extractImages(\n    file: File,\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult<import('@/types/pdf').ExtractedImage[]>> {\n    const startTime = performance.now();\n\n    try {\n      onProgress?.(0, 'Loading PDF...');\n\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n      const pages = pdfDoc.getPages();\n      const totalPages = pages.length;\n\n      const images: import('@/types/pdf').ExtractedImage[] = [];\n      let imageCount = 0;\n\n      onProgress?.(10, 'Extracting images...');\n\n      for (let pageIndex = 0; pageIndex < totalPages; pageIndex++) {\n        const page = pages[pageIndex];\n        const resources = page.node.Resources();\n\n        if (resources && resources instanceof PDFDict) {\n          const xObjects = resources.get(PDFName.of('XObject'));\n\n          if (xObjects && xObjects instanceof PDFDict) {\n            const xObjectKeys = xObjects.keys();\n\n            for (const key of xObjectKeys) {\n              try {\n                const ref = xObjects.get(key);\n                const xObject = pdfDoc.context.lookup(ref);\n\n                if (xObject instanceof PDFDict || (xObject && 'dict' in xObject && xObject.dict instanceof PDFDict)) {\n                  const dict = xObject instanceof PDFDict ? xObject : (xObject as any).dict;\n                  const subtype = dict.get(PDFName.of('Subtype'));\n\n                  // Check if it's an image\n                  if (subtype && subtype.toString() === '/Image') {\n                    // Get image properties\n                    const width = dict.get(PDFName.of('Width'));\n                    const height = dict.get(PDFName.of('Height'));\n                    const colorSpace = dict.get(PDFName.of('ColorSpace'));\n                    const bitsPerComponent = dict.get(PDFName.of('BitsPerComponent')) || 8;\n\n                    if (!width || !height) {\n                      continue;\n                    }\n\n                    // Extract numeric values - width/height can be PDFNumber objects\n                    let w = 0;\n                    let h = 0;\n                    let _bpc = 8;\n\n                    // Try different ways to extract the number\n                    if (typeof width === 'number') {\n                      w = width;\n                    } else if (width && typeof (width as unknown as Record<string, unknown>).asNumber === 'function') {\n                      w = (width as unknown as { asNumber: () => number }).asNumber();\n                    } else if (width && typeof (width as unknown as Record<string, unknown>).numberValue === 'function') {\n                      w = (width as unknown as { numberValue: () => number }).numberValue();\n                    } else if (width && (width as unknown as { value: unknown }).value !== undefined) {\n                      w = Number((width as unknown as { value: unknown }).value);\n                    } else if (width && (width as unknown as { num: unknown }).num !== undefined) {\n                      w = Number((width as unknown as { num: unknown }).num);\n                    }\n\n                    if (typeof height === 'number') {\n                      h = height;\n                    } else if (height && typeof (height as unknown as Record<string, unknown>).asNumber === 'function') {\n                      h = (height as unknown as { asNumber: () => number }).asNumber();\n                    } else if (height && typeof (height as unknown as Record<string, unknown>).numberValue === 'function') {\n                      h = (height as unknown as { numberValue: () => number }).numberValue();\n                    } else if (height && (height as unknown as { value: unknown }).value !== undefined) {\n                      h = Number((height as unknown as { value: unknown }).value);\n                    } else if (height && (height as unknown as { num: unknown }).num !== undefined) {\n                      h = Number((height as unknown as { num: unknown }).num);\n                    }\n\n                    if (typeof bitsPerComponent === 'number') {\n                      _bpc = bitsPerComponent;\n                    } else if (bitsPerComponent && typeof (bitsPerComponent as unknown as Record<string, unknown>).asNumber === 'function') {\n                      _bpc = (bitsPerComponent as unknown as { asNumber: () => number }).asNumber();\n                    } else if (bitsPerComponent && typeof (bitsPerComponent as unknown as Record<string, unknown>).numberValue === 'function') {\n                      _bpc = (bitsPerComponent as unknown as { numberValue: () => number }).numberValue();\n                    } else if (bitsPerComponent && (bitsPerComponent as unknown as { value: unknown }).value !== undefined) {\n                      _bpc = Number((bitsPerComponent as unknown as { value: unknown }).value);\n                    }\n\n                    // Validate dimensions\n                    if (!w || !h || w <= 0 || h <= 0 || !Number.isFinite(w) || !Number.isFinite(h)) {\n                      continue;\n                    }\n\n                    // Skip unreasonably large images (likely errors)\n                    if (w > 10000 || h > 10000) {\n                      continue;\n                    }\n\n                    // Get raw image data\n                    let imageData: Uint8Array | null = null;\n\n                    if ('stream' in xObject && (xObject as any).stream) {\n                      imageData = (xObject as any).stream.contents;\n                    } else if ('contents' in xObject) {\n                      imageData = (xObject as any).contents;\n                    }\n\n                    if (imageData && imageData.length > 0) {\n                      // Try to determine format\n                      const filter = (dict as Map<any, any>).get(PDFName.of('Filter'));\n                      let mimeType = 'image/png';\n                      let ext = 'png';\n\n                      // Check if it's JPEG\n                      if (filter && filter.toString().includes('DCTDecode')) {\n                        mimeType = 'image/jpeg';\n                        ext = 'jpg';\n                        // For JPEG, we can use the raw data directly\n                        const blob = new Blob([imageData as unknown as BlobPart], { type: mimeType });\n                        imageCount++;\n                        const id = `img_${pageIndex + 1}_${imageCount}_${Date.now()}`;\n                        images.push({\n                          id,\n                          blob,\n                          filename: `page${pageIndex + 1}_img${imageCount}.${ext}`,\n                          width: w,\n                          height: h,\n                          pageNumber: pageIndex + 1,\n                          format: ext as 'jpg' | 'png',\n                          size: blob.size,\n                          previewUrl: URL.createObjectURL(blob)\n                        });\n                      } else {\n                        // For other formats, render to canvas\n                        try {\n                          // Validate dimensions again before canvas creation\n                          if (w <= 0 || h <= 0 || !Number.isFinite(w) || !Number.isFinite(h)) {\n                            continue;\n                          }\n\n                          const canvas = document.createElement('canvas');\n                          canvas.width = w;\n                          canvas.height = h;\n                          const ctx = canvas.getContext('2d');\n\n                          if (ctx) {\n                            // Determine color channels\n                            let channels = 4; // RGBA default\n                            if (colorSpace) {\n                              const csStr = colorSpace.toString();\n                              if (csStr.includes('DeviceGray')) channels = 1;\n                              else if (csStr.includes('DeviceRGB')) channels = 3;\n                              else if (csStr.includes('DeviceCMYK')) channels = 4;\n                            }\n\n                            // Validate we have enough data\n                            const expectedSize = w * h * channels;\n                            if (imageData.length < expectedSize) {\n                              continue;\n                            }\n\n                            // Create ImageData\n                            const imgDataArray = new Uint8ClampedArray(w * h * 4);\n\n                            // Simple conversion (this is basic, may not work for all color spaces)\n                            for (let i = 0; i < w * h; i++) {\n                              if (channels === 1) {\n                                // Grayscale\n                                const gray = imageData[i];\n                                imgDataArray[i * 4] = gray;\n                                imgDataArray[i * 4 + 1] = gray;\n                                imgDataArray[i * 4 + 2] = gray;\n                                imgDataArray[i * 4 + 3] = 255;\n                              } else if (channels === 3) {\n                                // RGB\n                                imgDataArray[i * 4] = imageData[i * 3];\n                                imgDataArray[i * 4 + 1] = imageData[i * 3 + 1];\n                                imgDataArray[i * 4 + 2] = imageData[i * 3 + 2];\n                                imgDataArray[i * 4 + 3] = 255;\n                              }\n                            }\n\n                            const imgData = new ImageData(imgDataArray, w, h);\n                            ctx.putImageData(imgData, 0, 0);\n\n                            const blob = await new Promise<Blob | null>(resolve =>\n                              canvas.toBlob(resolve, 'image/png')\n                            );\n\n                            if (blob) {\n                              imageCount++;\n                              const id = `img_${pageIndex + 1}_${imageCount}_${Date.now()}`;\n                              images.push({\n                                id,\n                                blob,\n                                filename: `page${pageIndex + 1}_img${imageCount}.${ext}`,\n                                width: w,\n                                height: h,\n                                pageNumber: pageIndex + 1,\n                                format: ext as 'jpg' | 'png',\n                                size: blob.size,\n                                previewUrl: URL.createObjectURL(blob)\n                              });\n                            }\n                          }\n                        } catch {\n                          // Silently skip - these are likely malformed or unsupported images\n                          continue;\n                        }\n                      }\n                    }\n                  }\n                }\n              } catch {\n                // Ignore annotation errors\n                continue;\n              }\n            }\n          }\n        }\n\n        onProgress?.(\n          10 + ((pageIndex + 1) / totalPages) * 70,\n          `Scanned page ${pageIndex + 1} of ${totalPages}...`\n        );\n      }\n\n      if (images.length === 0) {\n        throw new Error('No images found in the PDF');\n      }\n\n      const processingTime = performance.now() - startTime;\n      onProgress?.(100, 'Extraction completed!');\n\n      return {\n        success: true,\n        data: images,\n        metadata: {\n          pageCount: totalPages,\n          originalSize: file.size,\n          processedSize: images.reduce((sum, img) => sum + img.size, 0),\n          processingTime,\n          filesCreated: images.length\n        }\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: this.createPDFError(error, 'Image extraction failed')\n      };\n    }\n  }\n\n  /**\n   * Remove specific images from PDF by their IDs\n   */\n  async removeSelectedImages(\n    file: File,\n    imageIdsToRemove: string[],\n    extractedImages: import('@/types/pdf').ExtractedImage[],\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult<Blob>> {\n    const startTime = performance.now();\n\n    try {\n      onProgress?.(0, 'Loading PDF...');\n\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n      const pages = pdfDoc.getPages();\n      const totalPages = pages.length;\n\n      onProgress?.(10, 'Processing pages...');\n\n      // Create a map of images to remove grouped by page\n      const imagesToRemoveByPage = new Map<number, Set<string>>();\n      extractedImages.forEach(img => {\n        if (imageIdsToRemove.includes(img.id)) {\n          if (!imagesToRemoveByPage.has(img.pageNumber)) {\n            imagesToRemoveByPage.set(img.pageNumber, new Set());\n          }\n          // Store filename as identifier since we can match it\n          imagesToRemoveByPage.get(img.pageNumber)!.add(img.filename);\n        }\n      });\n\n\n      const imageCountByPage = new Map<number, number>();\n\n      for (let pageIndex = 0; pageIndex < totalPages; pageIndex++) {\n        const pageNumber = pageIndex + 1;\n        const page = pages[pageIndex];\n        const resources = page.node.Resources();\n\n        if (!imagesToRemoveByPage.has(pageNumber)) {\n          continue; // Skip pages with no images to remove\n        }\n\n        if (resources instanceof PDFDict) {\n          const xObjects = resources.get(PDFName.of('XObject'));\n\n          if (xObjects instanceof PDFDict) {\n            const keysToRemove: PDFName[] = [];\n            // let currentImageIndex = 0; // This variable is not used\n\n            const xObjectKeys = xObjects.keys();\n            for (const key of xObjectKeys) {\n              const ref = xObjects.get(key);\n              const obj = pdfDoc.context.lookup(ref);\n\n              const dict = obj instanceof PDFDict ? obj : (obj && 'dict' in obj && obj.dict instanceof PDFDict) ? obj.dict : null;\n\n              if (dict) {\n                const subtype = dict.get(PDFName.of('Subtype'));\n\n                if (subtype && subtype.toString() === '/Image') {\n                  // currentImageIndex++; // This variable is not used\n                  if (!imageCountByPage.has(pageNumber)) {\n                    imageCountByPage.set(pageNumber, 0);\n                  }\n                  const imgIndex = imageCountByPage.get(pageNumber)! + 1;\n                  imageCountByPage.set(pageNumber, imgIndex);\n\n                  const expectedFilename = `page${pageNumber}_img${imgIndex}.jpg`; // or .png\n                  const expectedFilenamePng = `page${pageNumber}_img${imgIndex}.png`;\n\n                  const shouldRemove = imagesToRemoveByPage.get(pageNumber)!.has(expectedFilename) ||\n                    imagesToRemoveByPage.get(pageNumber)!.has(expectedFilenamePng);\n\n                  if (shouldRemove) {\n                    keysToRemove.push(key);\n                  }\n                }\n              }\n            }\n\n            for (const key of keysToRemove) {\n              xObjects.delete(key);\n            }\n          }\n        }\n\n        onProgress?.(\n          10 + ((pageIndex + 1) / totalPages) * 80,\n          `Processed page ${pageNumber} of ${totalPages}...`\n        );\n      }\n\n      onProgress?.(90, 'Saving PDF...');\n\n      const pdfBytes = await pdfDoc.save({ useObjectStreams: true });\n      const blob = new Blob([new Uint8Array(pdfBytes)], { type: 'application/pdf' });\n\n      const processingTime = performance.now() - startTime;\n      onProgress?.(100, 'Removal completed!');\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pageCount: totalPages,\n          originalSize: file.size,\n          processedSize: blob.size,\n          processingTime,\n          filesCreated: 1\n        }\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: this.createPDFError(error, 'Image removal failed')\n      };\n    }\n  }\n\n  /**\n   * Remove ALL images from PDF\n   */\n  async removeImages(\n    file: File,\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult<Blob>> {\n    const startTime = performance.now();\n\n    try {\n      onProgress?.(0, 'Loading PDF...');\n\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n      const pages = pdfDoc.getPages();\n      const totalPages = pages.length;\n\n      onProgress?.(10, 'Processing pages...');\n\n\n\n      for (let i = 0; i < totalPages; i++) {\n        const page = pages[i];\n        const resources = page.node.Resources();\n\n        if (resources instanceof PDFDict) {\n          const xObjects = resources.get(PDFName.of('XObject'));\n\n          if (xObjects instanceof PDFDict) {\n            const keysToRemove: PDFName[] = [];\n\n            const xObjectKeys = xObjects.keys();\n            for (const key of xObjectKeys) {\n              const ref = xObjects.get(key);\n              const obj = pdfDoc.context.lookup(ref);\n              if (!obj) continue;\n\n              if (obj instanceof PDFDict) {\n                const subtype = obj.get(PDFName.of('Subtype'));\n                if (subtype === PDFName.of('Image')) {\n                  keysToRemove.push(key);\n                }\n              } else if (obj instanceof PDFArray) {\n                // Unlikely\n              } else {\n                if (obj && 'dict' in obj && obj.dict instanceof PDFDict) {\n                  const subtype = obj.dict.get(PDFName.of('Subtype'));\n                  if (subtype === PDFName.of('Image')) {\n                    keysToRemove.push(key);\n                  }\n                }\n              }\n            }\n\n            for (const key of keysToRemove) {\n              xObjects.delete(key);\n            }\n          }\n        }\n\n        onProgress?.(\n          10 + ((i + 1) / totalPages) * 80,\n          `Processed page ${i + 1} of ${totalPages}...`\n        );\n      }\n\n      onProgress?.(90, 'Saving PDF...');\n\n      const pdfBytes = await pdfDoc.save({ useObjectStreams: true });\n      const blob = new Blob([new Uint8Array(pdfBytes)], { type: 'application/pdf' });\n\n      const processingTime = performance.now() - startTime;\n      onProgress?.(100, 'Removal completed!');\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pageCount: totalPages,\n          originalSize: file.size,\n          processedSize: blob.size,\n          processingTime,\n          filesCreated: 1\n        }\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        error: this.createPDFError(error, 'Image removal failed')\n      };\n    }\n  }\n\n  /**\n   * Convert images to PDF\n   */\n  async imagesToPDF(\n    imageFiles: File[],\n    onProgress?: ProgressCallback,\n    options?: {\n      pageSize?: 'fit' | 'a4' | 'letter';\n      orientation?: 'portrait' | 'landscape';\n      margin?: number;\n    }\n  ): Promise<PDFProcessingResult> {\n    const startTime = performance.now();\n\n    try {\n      if (imageFiles.length === 0) {\n        throw new Error('At least one image is required');\n      }\n\n      onProgress?.(0, 'Starting conversion...');\n\n      // Create new PDF document\n      const pdfDoc = await PDFDocument.create();\n      let totalOriginalSize = 0;\n\n      // Process each image\n      for (let i = 0; i < imageFiles.length; i++) {\n        const imageFile = imageFiles[i];\n        totalOriginalSize += imageFile.size;\n\n        onProgress?.(\n          (i / imageFiles.length) * 90,\n          `Processing image ${i + 1}/${imageFiles.length}...`\n        );\n\n        // Load image based on type\n        const imageBytes = await imageFile.arrayBuffer();\n        let image;\n\n        const fileType = imageFile.type.toLowerCase();\n        if (fileType.includes('png')) {\n          image = await pdfDoc.embedPng(imageBytes);\n        } else if (fileType.includes('jpeg') || fileType.includes('jpg')) {\n          image = await pdfDoc.embedJpg(imageBytes);\n        } else {\n          throw new Error(`Unsupported image format: ${fileType}. Only PNG and JPEG are supported.`);\n        }\n\n        const imageDims = image.scale(1);\n\n        // Calculate page dimensions based on options\n        let pageWidth: number;\n        let pageHeight: number;\n        const margin = options?.margin || 0;\n\n        if (options?.pageSize === 'a4') {\n          // A4 size in points (1 point = 1/72 inch)\n          pageWidth = 595.28;  // 210mm\n          pageHeight = 841.89; // 297mm\n        } else if (options?.pageSize === 'letter') {\n          // Letter size in points\n          pageWidth = 612;    // 8.5 inch\n          pageHeight = 792;   // 11 inch\n        } else {\n          // Fit to image size\n          pageWidth = imageDims.width + (margin * 2);\n          pageHeight = imageDims.height + (margin * 2);\n        }\n\n        // Handle orientation\n        if (options?.orientation === 'landscape') {\n          [pageWidth, pageHeight] = [pageHeight, pageWidth];\n        }\n\n        // Create page with calculated dimensions\n        const page = pdfDoc.addPage([pageWidth, pageHeight]);\n\n        // Calculate image position and scale to fit within margins\n        const availableWidth = pageWidth - (margin * 2);\n        const availableHeight = pageHeight - (margin * 2);\n\n        let scale = 1;\n        if (options?.pageSize !== 'fit') {\n          // Scale image to fit within page margins\n          const scaleX = availableWidth / imageDims.width;\n          const scaleY = availableHeight / imageDims.height;\n          scale = Math.min(scaleX, scaleY);\n        }\n\n        const scaledWidth = imageDims.width * scale;\n        const scaledHeight = imageDims.height * scale;\n\n        // Center image on page\n        const x = margin + (availableWidth - scaledWidth) / 2;\n        const y = margin + (availableHeight - scaledHeight) / 2;\n\n        page.drawImage(image as import('pdf-lib').PDFImage, {\n          x,\n          y,\n          width: scaledWidth,\n          height: scaledHeight,\n        });\n      }\n\n      onProgress?.(90, 'Saving PDF...');\n\n      // Save PDF\n      const pdfBytes = await pdfDoc.save();\n      const blob = new Blob([new Uint8Array(pdfBytes)], { type: 'application/pdf' });\n\n      const processingTime = performance.now() - startTime;\n      onProgress?.(100, 'Completed!');\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pageCount: imageFiles.length,\n          originalSize: totalOriginalSize,\n          processedSize: blob.size,\n          processingTime\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: this.createPDFError(error, 'Images to PDF conversion failed')\n      };\n    }\n  }\n\n  /**\n   * Convert PDF pages to images\n   */\n  async pdfToImages(\n    file: File,\n    options: ImageConversionOptions,\n    onProgress?: (progress: ImageConversionProgress) => void\n  ): Promise<ImageConversionResult> {\n    const startTime = performance.now();\n\n    try {\n      // Import quality settings dynamically\n      const { QUALITY_SETTINGS } = await import('@/types/image.types');\n\n      // Update progress\n      onProgress?.({\n        currentPage: 0,\n        totalPages: 0,\n        percentage: 0,\n        status: 'preparing',\n        message: 'Loading PDF...'\n      });\n\n      // Load PDF document\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\n      const totalPages = pdfDoc.numPages;\n\n      // Determine which pages to convert\n      const pagesToConvert = this.getPageNumbersForConversion(totalPages, options);\n\n      onProgress?.({\n        currentPage: 0,\n        totalPages: pagesToConvert.length,\n        percentage: 5,\n        status: 'converting',\n        message: `Converting ${pagesToConvert.length} pages...`\n      });\n\n      // Convert pages\n      const convertedImages: ConvertedImage[] = [];\n      const qualitySettings = QUALITY_SETTINGS[options.quality as keyof typeof QUALITY_SETTINGS];\n\n      for (let i = 0; i < pagesToConvert.length; i++) {\n        const pageNumber = pagesToConvert[i];\n\n        onProgress?.({\n          currentPage: i + 1,\n          totalPages: pagesToConvert.length,\n          percentage: 5 + (i / pagesToConvert.length) * 90,\n          status: 'converting',\n          message: `Converting page ${pageNumber}...`\n        });\n\n        const convertedImage = await this.convertPageToImage(\n          pdfDoc,\n          pageNumber,\n          options,\n          qualitySettings.resolution,\n          file.name\n        );\n\n        convertedImages.push(convertedImage);\n      }\n\n      onProgress?.({\n        currentPage: pagesToConvert.length,\n        totalPages: pagesToConvert.length,\n        percentage: 100,\n        status: 'complete',\n        message: 'Conversion complete!'\n      });\n\n      // Calculate sizes\n      const originalSize = file.size;\n      const convertedSize = convertedImages.reduce((sum, img) => sum + img.size, 0);\n\n      return {\n        success: true,\n        images: convertedImages,\n        totalPages,\n        originalSize,\n        convertedSize,\n        metadata: {\n          processingTime: performance.now() - startTime,\n          format: options.format,\n          quality: options.quality,\n          resolution: qualitySettings.resolution\n        }\n      };\n\n    } catch (error) {\n      console.error('[PDFService] PDF to Images conversion failed:', error);\n\n      return {\n        success: false,\n        images: [],\n        totalPages: 0,\n        originalSize: file.size,\n        convertedSize: 0,\n        error: error instanceof Error ? error.message : 'Unknown conversion error'\n      };\n    }\n  }\n\n  /**\n   * Convert single PDF page to image\n   */\n  private async convertPageToImage(\n    pdfDoc: pdfjsLib.PDFDocumentProxy,\n    pageNumber: number,\n    options: ImageConversionOptions,\n    resolution: number,\n    originalFileName: string\n  ): Promise<ConvertedImage> {\n    // Import quality settings dynamically\n    const { QUALITY_SETTINGS } = await import('@/types/image.types');\n\n    // Get page\n    const page = await pdfDoc.getPage(pageNumber);\n\n    // Calculate scale for desired resolution\n    // const viewport = page.getViewport({ scale: 1 }); // This variable is not used\n    const scale = resolution / 72; // 72 DPI is the default\n    const scaledViewport = page.getViewport({ scale });\n\n    // Create canvas\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n\n    if (!context) {\n      throw new Error('Failed to get canvas context');\n    }\n\n    canvas.width = scaledViewport.width;\n    canvas.height = scaledViewport.height;\n\n    // Set background color for JPEG\n    if (options.format === 'jpeg' && options.backgroundColor) {\n      context.fillStyle = options.backgroundColor;\n      context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    // Render page to canvas\n    if (context) {\n      const renderContext = {\n        canvasContext: context,\n        viewport: scaledViewport,\n      };\n      // @ts-expect-error - page.render expects specific context type\n      await page.render(renderContext).promise;\n    }\n\n    // Convert canvas to blob\n    const blob = await this.canvasToBlob(canvas, options);\n\n    // Create data URL for preview\n    const dataUrl = canvas.toDataURL(\n      `image/${options.format}`,\n      options.format === 'jpeg' ? QUALITY_SETTINGS[options.quality].jpegQuality : undefined\n    );\n\n    // Generate filename\n    const baseName = originalFileName.replace(/\\.pdf$/i, '');\n    const filename = `${baseName}_page_${pageNumber}.${options.format}`;\n\n    return {\n      pageNumber,\n      blob,\n      dataUrl,\n      filename,\n      size: blob.size\n    };\n  }\n\n  /**\n   * Convert canvas to blob with specified format and quality\n   */\n  private async canvasToBlob(canvas: HTMLCanvasElement, options: ImageConversionOptions): Promise<Blob> {\n    // Import quality settings dynamically\n    const { QUALITY_SETTINGS } = await import('@/types/image.types');\n\n    return new Promise((resolve, reject) => {\n      const mimeType = `image/${options.format}`;\n      const quality = options.format === 'jpeg'\n        ? QUALITY_SETTINGS[options.quality].jpegQuality\n        : undefined;\n\n      canvas.toBlob(\n        (blob) => {\n          if (blob) {\n            resolve(blob);\n          } else {\n            reject(new Error('Failed to create blob from canvas'));\n          }\n        },\n        mimeType,\n        quality\n      );\n    });\n  }\n\n  /**\n   * Get array of page numbers to convert based on options\n   */\n  private getPageNumbersForConversion(totalPages: number, options: ImageConversionOptions): number[] {\n    switch (options.pages) {\n      case 'all':\n        return Array.from({ length: totalPages }, (_, i) => i + 1);\n\n      case 'specific':\n        return options.pageNumbers?.filter(n => n >= 1 && n <= totalPages) || [];\n\n      case 'range': {\n        if (!options.pageRange) return [];\n        const { start, end } = options.pageRange;\n        const validStart = Math.max(1, Math.min(start, totalPages));\n        const validEnd = Math.min(totalPages, Math.max(end, validStart));\n        return Array.from(\n          { length: validEnd - validStart + 1 },\n          (_, i) => validStart + i\n        );\n      }\n\n      default:\n        return [];\n    }\n  }\n\n  /**\n   * Download single image\n   */\n  downloadImage(image: ConvertedImage): void {\n    const url = URL.createObjectURL(image.blob);\n    const link = document.createElement('a');\n    link.href = url;\n    link.download = image.filename;\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    URL.revokeObjectURL(url);\n  }\n\n  /**\n   * Download all images as separate files\n   */\n  downloadAllImages(images: ConvertedImage[]): void {\n    images.forEach((image, index) => {\n      // Add small delay between downloads to avoid browser blocking\n      setTimeout(() => {\n        this.downloadImage(image);\n      }, index * 100);\n    });\n  }\n\n  /**\n   * Download all images as ZIP archive\n   */\n  async downloadImagesAsZip(images: ConvertedImage[], zipFilename: string = 'pdf-images.zip'): Promise<void> {\n    try {\n      const zip = new JSZip();\n\n      // Add each image to the ZIP\n      // Convert Blob to ArrayBuffer to avoid Buffer.isBuffer issues in browser\n      for (const image of images) {\n        const arrayBuffer = await image.blob.arrayBuffer();\n        zip.file(image.filename, arrayBuffer);\n      }\n\n      // Generate ZIP file\n      const zipBlob = await zip.generateAsync({\n        type: 'blob',\n        compression: 'DEFLATE',\n        compressionOptions: { level: 6 }\n      });\n\n      // Download ZIP\n      this.downloadFile(zipBlob, zipFilename);\n    } catch (error) {\n      console.error('Failed to create ZIP archive:', error);\n      throw new Error('Failed to create ZIP archive');\n    }\n  }\n\n  /**\n   * Convert Word document (.docx) to PDF\n   * Uses mammoth to convert DOCX ‚Üí HTML, then renders HTML as PDF\n   * Supports two modes: 'formatted' (with images/tables) and 'text' (text only)\n   */\n  async wordToPDF(\n    file: File,\n    onProgress?: ProgressCallback,\n    options?: { mode?: 'formatted' | 'text'; quality?: 1 | 2 | 3 }\n  ): Promise<PDFProcessingResult> {\n    const mode = options?.mode || 'text';\n    const quality = options?.quality || 2;\n\n    // Use formatted mode with html2canvas if mode is 'formatted'\n    if (mode === 'formatted') {\n      return this.wordToPDFFormatted(file, quality, onProgress);\n    }\n\n    // Text-only mode (original implementation)\n    try {\n      onProgress?.(10, 'Reading Word document...');\n\n      // Read Word file as ArrayBuffer\n      const arrayBuffer = await file.arrayBuffer();\n\n      onProgress?.(25, 'Converting Word to HTML...');\n\n      // Convert DOCX to HTML using mammoth\n      const result = await mammoth.convertToHtml({ arrayBuffer });\n      const html = result.value;\n\n      const textContent = html.replace(/<[^>]*>/g, '\\n').trim();\n\n      onProgress?.(40, 'Loading font...');\n\n      // Create new PDF document\n      const pdfDoc = await PDFDocument.create();\n      pdfDoc.registerFontkit(fontkit);\n\n      // Check if text contains non-ASCII characters (Cyrillic, extended Latin, etc.)\n      // WinAnsi only supports basic Latin (0x20-0x7E) plus some Western European chars\n\n      const needsUnicodeFont = /[^\\x00-\\xFF]/.test(textContent) || /[\\u0080-\\u024F\\u0400-\\u04FF]/.test(textContent);\n      console.log(`üî§ Text needs Unicode font: ${needsUnicodeFont}`);\n\n      // Load appropriate font\n      let font;\n      if (needsUnicodeFont) {\n        console.log('üåç Loading Unicode font...');\n        try {\n          font = await this.loadUnicodeFont(pdfDoc);\n          console.log('‚úÖ Unicode font loaded successfully');\n        } catch {\n          console.warn('‚ö†Ô∏è Failed to load Unicode font, using Helvetica');\n          font = await pdfDoc.embedFont(StandardFonts.Helvetica);\n        }\n      } else {\n        font = await pdfDoc.embedFont(StandardFonts.Helvetica);\n      }\n\n      onProgress?.(60, 'Creating PDF from text...');\n\n      // Draw text on page\n      const fontSize = 12;\n      const lines = textContent.split('\\n').filter(line => line.trim());\n      const lineHeight = fontSize + 4;\n      const margin = 50;\n\n      let currentPage = pdfDoc.addPage();\n      let { width, height } = currentPage.getSize();\n      let yPosition = height - margin;\n\n      for (const line of lines) {\n        if (!line.trim()) continue;\n\n        // Check if we need a new page\n        if (yPosition < margin + lineHeight) {\n          currentPage = pdfDoc.addPage();\n          const pageSize = currentPage.getSize();\n          width = pageSize.width;\n          height = pageSize.height;\n          yPosition = height - margin;\n        }\n\n        // Wrap line to fit page width\n        const maxChars = Math.floor((width - 2 * margin) / (fontSize * 0.5));\n        const displayLine = line.substring(0, maxChars);\n\n        try {\n          currentPage.drawText(displayLine, {\n            x: margin,\n            y: yPosition,\n            size: fontSize,\n            color: rgb(0, 0, 0),\n            font: font,\n          });\n        } catch (error) {\n          console.warn('Failed to draw line:', error);\n        }\n\n        yPosition -= lineHeight;\n      }\n\n      onProgress?.(85, 'Generating PDF...');\n\n      // Save PDF\n      const pdfBytes = await pdfDoc.save();\n      const blob = new Blob([pdfBytes], { type: 'application/pdf' });\n\n      onProgress?.(100, 'Conversion complete!');\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pageCount: lines.length, // Approximation or track actual pages\n          originalSize: file.size,\n          processedSize: blob.size,\n          processingTime: 0 // Track if needed\n        }\n      };\n\n    } catch (error) {\n      console.error('Word to PDF conversion error:', error);\n      return {\n        success: false,\n        error: this.createPDFError(error, 'Word to PDF conversion failed')\n      };\n    }\n  }\n\n  /**\n   * Convert Word document to PDF with formatting (images, tables, headings)\n   * Uses mammoth ‚Üí HTML ‚Üí html2canvas ‚Üí jsPDF\n   */\n  private async wordToPDFFormatted(\n    file: File,\n    quality: 1 | 2 | 3,\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult> {\n    try {\n      onProgress?.(5, 'Reading Word document...');\n\n      const arrayBuffer = await file.arrayBuffer();\n\n      onProgress?.(15, 'Converting to HTML with images...');\n\n      // Convert DOCX to HTML with image support\n      const mammothResult = await mammoth.convertToHtml(\n        { arrayBuffer },\n        {\n          convertImage: mammoth.images.imgElement((image) => {\n            return image.read(\"base64\").then((imageBuffer) => {\n              return {\n                src: `data:${image.contentType};base64,${imageBuffer}`\n              };\n            });\n          })\n        }\n      );\n\n      const html = mammothResult.value;\n\n      onProgress?.(35, 'Rendering document...');\n\n      // Quality settings\n      const qualitySettings = {\n        1: { scale: 1, imageQuality: 0.7 },\n        2: { scale: 1.5, imageQuality: 0.85 },\n        3: { scale: 2, imageQuality: 0.95 }\n      };\n      const settings = qualitySettings[quality as keyof typeof qualitySettings];\n\n      // A4 dimensions in mm\n      const pageWidth = 210;\n      const pageHeight = 297;\n\n      // Create a hidden container for rendering\n      const container = document.createElement('div');\n      container.style.cssText = `\n        position: absolute;\n        left: -9999px;\n        top: 0;\n        width: ${pageWidth * 3.78}px;\n        font-family: Arial, Helvetica, sans-serif;\n        font-size: 12pt;\n        line-height: 1.6;\n        padding: 40px;\n        box-sizing: border-box;\n        background: white;\n        color: black;\n      `;\n\n      // Add CSS for better formatting\n      const styleSheet = `\n        <style>\n          * { box-sizing: border-box; }\n          h1 { font-size: 24pt; font-weight: bold; margin: 20px 0 10px 0; color: #000; }\n          h2 { font-size: 18pt; font-weight: bold; margin: 16px 0 8px 0; color: #000; }\n          h3 { font-size: 14pt; font-weight: bold; margin: 14px 0 6px 0; color: #000; }\n          h4 { font-size: 12pt; font-weight: bold; margin: 12px 0 6px 0; color: #000; }\n          p { margin: 8px 0; color: #000; }\n          img { max-width: 100%; height: auto; margin: 12px 0; display: block; }\n          table { border-collapse: collapse; width: 100%; margin: 16px 0; }\n          td, th { border: 1px solid #333; padding: 8px 12px; text-align: left; }\n          th { background-color: #f0f0f0; font-weight: bold; }\n          ul, ol { margin: 10px 0; padding-left: 30px; }\n          li { margin: 4px 0; }\n          strong, b { font-weight: bold; }\n          em, i { font-style: italic; }\n          a { color: #0066cc; text-decoration: underline; }\n          blockquote { margin: 10px 0; padding: 10px 20px; border-left: 4px solid #ccc; background: #f9f9f9; }\n        </style>\n      `;\n\n      container.innerHTML = styleSheet + html;\n      document.body.appendChild(container);\n\n      onProgress?.(55, 'Creating PDF...');\n\n      // Dynamic import of html2canvas\n      const html2canvas = (await import('html2canvas')).default;\n\n      const canvas = await html2canvas(container, {\n        scale: settings.scale,\n        useCORS: true,\n        allowTaint: true,\n        backgroundColor: '#ffffff',\n        logging: false\n      });\n\n      document.body.removeChild(container);\n\n      onProgress?.(75, 'Generating pages...');\n\n      // Dynamic import of jsPDF\n      const { jsPDF } = await import('jspdf');\n\n      const pdf = new jsPDF({\n        orientation: 'portrait',\n        unit: 'mm',\n        format: 'a4'\n      });\n\n      // Calculate dimensions\n      const marginX = 10; // mm\n      const marginY = 10; // mm\n      const contentWidth = pageWidth - (marginX * 2);\n      const contentHeight = pageHeight - (marginY * 2);\n\n      // Pixels per mm for the canvas\n      const pxPerMm = canvas.width / (pageWidth - (marginX * 2));\n      const pageHeightPx = contentHeight * pxPerMm;\n\n      // Calculate number of pages needed\n      const totalPages = Math.ceil(canvas.height / pageHeightPx);\n\n      for (let pageNum = 0; pageNum < totalPages; pageNum++) {\n        if (pageNum > 0) {\n          pdf.addPage();\n        }\n\n        // Calculate slice position\n        const sourceY = pageNum * pageHeightPx;\n        const sourceHeight = Math.min(pageHeightPx, canvas.height - sourceY);\n\n        // Create a temporary canvas for this page slice\n        const pageCanvas = document.createElement('canvas');\n        pageCanvas.width = canvas.width;\n        pageCanvas.height = sourceHeight;\n        const pageCtx = pageCanvas.getContext('2d');\n\n        if (pageCtx) {\n          // Draw the slice from the main canvas\n          pageCtx.drawImage(\n            canvas,\n            0, sourceY, canvas.width, sourceHeight,  // source\n            0, 0, canvas.width, sourceHeight          // destination\n          );\n\n          // Convert to image and add to PDF\n          const pageImgData = pageCanvas.toDataURL('image/jpeg', settings.imageQuality);\n          const sliceHeightMm = sourceHeight / pxPerMm;\n\n          pdf.addImage(pageImgData, 'JPEG', marginX, marginY, contentWidth, sliceHeightMm);\n        }\n\n        onProgress?.(75 + (pageNum / totalPages) * 20, `Generating page ${pageNum + 1}/${totalPages}...`);\n      }\n\n      onProgress?.(95, 'Finalizing...');\n\n      const pdfBlob = pdf.output('blob');\n\n      onProgress?.(100, 'Conversion complete!');\n\n      return {\n        success: true,\n        data: pdfBlob,\n        metadata: {\n          pageCount: totalPages, // Actual page count\n          originalSize: file.size,\n          processedSize: pdfBlob.size,\n          processingTime: 0 // Track if needed\n        }\n      };\n\n    } catch (error) {\n      console.error('Formatted Word to PDF conversion error:', error);\n      return {\n        success: false,\n        error: this.createPDFError(error, 'Word to PDF (formatted) conversion failed')\n      };\n    }\n  }\n\n  /**\n   * Load Unicode-compatible font from CDN (supports Cyrillic, Extended Latin, etc.)\n   */\n  private async loadUnicodeFont(pdfDoc: PDFDocument): Promise<import('pdf-lib').PDFFont> {\n    const fontUrls = [\n      'https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxK.woff',\n      'https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37.3/ttf/DejaVuSans.ttf'\n    ];\n\n    for (const fontUrl of fontUrls) {\n      try {\n        console.log(`üî§ Loading font from: ${fontUrl}`);\n\n        const response = await fetch(fontUrl, {\n          mode: 'cors',\n          headers: {\n            'Accept': 'application/font-woff2,application/font-woff,application/font-ttf,*/*'\n          }\n        });\n\n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}`);\n        }\n\n        const fontBytes = await response.arrayBuffer();\n\n        if (fontBytes.byteLength < 1000) {\n          throw new Error('Font data too small');\n        }\n\n        const font = await pdfDoc.embedFont(fontBytes);\n        console.log(`‚úÖ Font loaded successfully from ${fontUrl}`);\n        return font;\n\n      } catch (error) {\n        console.warn(`‚ùå Failed to load font from ${fontUrl}:`, error);\n        continue;\n      }\n    }\n\n    throw new Error('All font sources failed');\n  }\n\n  /**\n   * Convert PDF to Word document (.docx)\n   * Uses pdfjs to extract text and images, then docx library to create DOCX\n   * Supports options: includeImages, smartHeadings\n   */\n  async pdfToWord(\n    file: File,\n    onProgress?: ProgressCallback,\n    options?: { includeImages?: boolean; smartHeadings?: boolean; extractImages?: boolean }\n  ): Promise<PDFProcessingResult> {\n    const includeImages = options?.includeImages ?? true;\n    const smartHeadings = options?.smartHeadings ?? true;\n    const extractImages = options?.extractImages ?? true; // Extract embedded images when in text mode\n\n    try {\n      onProgress?.(5, 'Reading PDF file...');\n\n      // Load PDF\n      const arrayBuffer = await file.arrayBuffer();\n      const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });\n      const pdfDoc = await loadingTask.promise;\n      const numPages = pdfDoc.numPages;\n\n      onProgress?.(10, 'Analyzing document structure...');\n\n      // === SMART HEADING DETECTION: Pre-analyze all pages ===\n      // Collect font size statistics across the entire document\n      interface FontSizeStats {\n        size: number;\n        count: number;\n        totalChars: number;\n      }\n      const fontSizeMap = new Map<number, FontSizeStats>();\n      let totalTextItems = 0;\n      let bodyTextSize: number | undefined;\n      const headingSizes: Map<number, 'Heading1' | 'Heading2' | 'Heading3'> = new Map();\n\n      if (smartHeadings && !includeImages) {\n        for (let pageNum = 1; pageNum <= numPages; pageNum++) {\n          const page = await pdfDoc.getPage(pageNum);\n          const textContent = await page.getTextContent();\n          const items = textContent.items as PDFTextItem[];\n\n          for (const item of items) {\n            if (item.height && item.str?.trim()) {\n              // Round to nearest 0.5 to group similar sizes\n              const roundedSize = Math.round(item.height * 2) / 2;\n              const existing = fontSizeMap.get(roundedSize);\n              if (existing) {\n                existing.count++;\n                existing.totalChars += item.str.length;\n              } else {\n                fontSizeMap.set(roundedSize, {\n                  size: roundedSize,\n                  count: 1,\n                  totalChars: item.str.length\n                });\n              }\n              totalTextItems++;\n            }\n          }\n        }\n\n        // Determine body text size (most common size by character count)\n        let maxChars = 0;\n        bodyTextSize = 12; // Initialize bodyTextSize here\n        for (const [size, stats] of fontSizeMap) {\n          if (stats.totalChars > maxChars) {\n            maxChars = stats.totalChars;\n            bodyTextSize = size;\n          }\n        }\n\n        // Identify heading sizes: larger than body text and relatively rare\n        // Sort sizes descending\n        const sortedSizes = Array.from(fontSizeMap.values())\n          .filter(s => s.size > (bodyTextSize || 0)) // Use bodyTextSize, default to 0 if undefined\n          .sort((a, b) => b.size - a.size);\n\n        // Assign heading levels to the top 3 largest sizes that are rare (< 10% of items)\n        let headingLevel = 1;\n        for (const sizeStats of sortedSizes) {\n          if (headingLevel > 3) break;\n          // Heading should be rare: less than 10% of text items\n          const frequency = sizeStats.count / totalTextItems;\n          if (frequency < 0.1) {\n            headingSizes.set(sizeStats.size, `Heading${headingLevel}` as 'Heading1' | 'Heading2' | 'Heading3');\n            headingLevel++;\n          }\n        }\n\n        // Store for use in page processing\n        // headingSizes and bodyTextSize are available in closure\n      }\n\n      onProgress?.(15, 'Extracting content from PDF...');\n\n      // Extract text and images from all pages\n      // Extract text and images from all pages\n      const sections: Paragraph[] = [];\n      // The type definition for extractedImages was also incorrect in the original snippet.\n      // The correct type for extractedImages is defined within the scope of the loop.\n\n      for (let pageNum = 1; pageNum <= numPages; pageNum++) {\n        const page = await pdfDoc.getPage(pageNum);\n\n        if (includeImages) {\n          // Mode: Render page as image (preserves layout)\n          try {\n            const scale = 2; // Higher quality\n            const viewport = page.getViewport({ scale }); // Renamed from _viewport to viewport\n            const canvas = document.createElement('canvas');\n            canvas.width = viewport.width;\n            canvas.height = viewport.height;\n            const ctx = canvas.getContext('2d');\n\n            if (ctx) {\n              const renderContext = {\n                canvasContext: ctx,\n                viewport: viewport,\n              };\n              // @ts-expect-error - page.render expects specific context type\n              await page.render(renderContext).promise;\n              // Convert canvas to PNG blob\n              const pngBlob = await new Promise<Blob | null>((resolve) => {\n                canvas.toBlob((blob) => resolve(blob), 'image/png', 0.92);\n              });\n\n              if (pngBlob) {\n                const buffer = await pngBlob.arrayBuffer();\n\n                // Calculate dimensions to fit A4 page (width ~595px at 72dpi)\n                const maxWidth = 550;\n                const maxHeight = 750;\n                let width = viewport.width;\n                let height = viewport.height;\n\n                if (width > maxWidth) {\n                  const ratio = maxWidth / width;\n                  width = maxWidth;\n                  height = Math.round(height * ratio);\n                }\n                if (height > maxHeight) {\n                  const ratio = maxHeight / height;\n                  height = maxHeight;\n                  width = Math.round(width * ratio);\n                }\n\n                sections.push(\n                  new Paragraph({\n                    children: [\n                      new ImageRun({\n                        data: new Uint8Array(buffer),\n                        transformation: {\n                          width: width,\n                          height: height,\n                        },\n                        type: 'png',\n                      }),\n                    ],\n                  })\n                );\n              }\n            }\n          } catch (pageImgError) {\n            console.warn('Image rendering error on page', pageNum, pageImgError);\n          }\n        } else {\n          // Mode: Extract text with optional embedded images\n          const textContent = await page.getTextContent();\n          const viewport = page.getViewport({ scale: 1.0 });\n          const pageWidth = viewport.width;\n          const pageHeight = viewport.height;\n          const items = textContent.items as PDFTextItem[];\n\n          // Use pre-analyzed heading sizes from document analysis\n          // headingSizes and bodyTextSize are available in closure\n          const avgFontSize = (typeof bodyTextSize !== 'undefined') ? bodyTextSize : 12;\n\n          // === EXTRACT EMBEDDED IMAGES ===\n          interface ExtractedImage {\n            data: Uint8Array;\n            x: number;\n            y: number;\n            width: number;\n            height: number;\n            yNormalized: number; // Y position from top (0-1)\n          }\n          const pageImages: ExtractedImage[] = [];\n\n          if (extractImages) {\n            try {\n              const operatorList = await page.getOperatorList();\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              const objs = (page as any).objs;\n\n              // Track current transformation matrix\n              let currentMatrix = [1, 0, 0, 1, 0, 0];\n              const matrixStack: number[][] = [];\n\n              for (let i = 0; i < operatorList.fnArray.length; i++) {\n                const fn = operatorList.fnArray[i];\n                const args = operatorList.argsArray[i];\n\n                // Track transformation matrix changes\n                if (fn === 10) { // OPS.save\n                  matrixStack.push([...currentMatrix]);\n                } else if (fn === 11) { // OPS.restore\n                  if (matrixStack.length > 0) {\n                    currentMatrix = matrixStack.pop()!;\n                  }\n                } else if (fn === 12) { // OPS.transform\n                  if (args && args.length >= 6) {\n                    // Multiply matrices\n                    const [a, b, c, d, e, f] = args;\n                    const [a2, b2, c2, d2, e2, f2] = currentMatrix;\n                    currentMatrix = [\n                      a * a2 + b * c2,\n                      a * b2 + b * d2,\n                      c * a2 + d * c2,\n                      c * b2 + d * d2,\n                      e * a2 + f * c2 + e2,\n                      e * b2 + f * d2 + f2\n                    ];\n                  }\n                }\n\n                // OPS.paintImageXObject = 85, OPS.paintJpegXObject = 82, OPS.paintInlineImageXObject = 84\n                if (fn === 85 || fn === 82 || fn === 84) {\n                  try {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    let imgData: any = null;\n\n                    if (fn === 84) {\n                      // Inline image - data is directly in args\n                      imgData = args[0];\n                    } else {\n                      // XObject image - need to fetch from objs\n                      const imgName = args[0];\n\n                      // Try different methods to get image data\n                      if (objs._objs && objs._objs.has(imgName)) {\n                        imgData = objs._objs.get(imgName).data;\n                      } else if (typeof objs.get === 'function') {\n                        imgData = await new Promise<any>((resolve) => {\n                          const timeout = setTimeout(() => resolve(null), 1000);\n                          try {\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            objs.get(imgName, (data: any) => {\n                              clearTimeout(timeout);\n                              resolve(data);\n                            });\n                          } catch {\n                            clearTimeout(timeout);\n                            resolve(null);\n                          }\n                        });\n                      }\n                    }\n\n                    if (imgData && imgData.width && imgData.height) {\n                      // Get position and size from current transformation matrix\n                      const imgWidth = Math.abs(currentMatrix[0]) || imgData.width;\n                      const imgHeight = Math.abs(currentMatrix[3]) || imgData.height;\n                      const imgX = currentMatrix[4] || 0;\n                      const imgY = currentMatrix[5] || 0;\n\n                      // Skip very small images (likely decorative)\n                      if (imgWidth < 20 || imgHeight < 20) continue;\n\n                      // Convert image data to PNG\n                      const canvas = document.createElement('canvas');\n                      canvas.width = imgData.width;\n                      canvas.height = imgData.height;\n                      const ctx = canvas.getContext('2d');\n\n                      if (ctx && imgData.data) {\n                        const canvasImageData = ctx.createImageData(imgData.width, imgData.height);\n                        const srcData = imgData.data;\n                        const dstData = canvasImageData.data;\n                        const pixelCount = imgData.width * imgData.height;\n\n                        // Determine format based on data length\n                        const bytesPerPixel = srcData.length / pixelCount;\n\n                        if (bytesPerPixel >= 4) {\n                          // RGBA format\n                          for (let p = 0; p < pixelCount; p++) {\n                            dstData[p * 4] = srcData[p * 4];\n                            dstData[p * 4 + 1] = srcData[p * 4 + 1];\n                            dstData[p * 4 + 2] = srcData[p * 4 + 2];\n                            dstData[p * 4 + 3] = srcData[p * 4 + 3];\n                          }\n                        } else if (bytesPerPixel >= 3) {\n                          // RGB format\n                          for (let p = 0; p < pixelCount; p++) {\n                            dstData[p * 3] = srcData[p * 3];\n                            dstData[p * 3 + 1] = srcData[p * 3 + 1];\n                            dstData[p * 3 + 2] = srcData[p * 3 + 2];\n                            dstData[p * 4 + 3] = 255;\n                          }\n                        } else if (bytesPerPixel >= 1) {\n                          // Grayscale format\n                          for (let p = 0; p < pixelCount; p++) {\n                            const gray = srcData[p];\n                            dstData[p * 4] = gray;\n                            dstData[p * 4 + 1] = gray;\n                            dstData[p * 4 + 2] = gray;\n                            dstData[p * 4 + 3] = 255;\n                          }\n                        } else {\n                          continue; // Unknown format\n                        }\n\n                        ctx.putImageData(canvasImageData, 0, 0);\n\n                        const pngBlob = await new Promise<Blob | null>((resolve) => {\n                          canvas.toBlob((blob) => resolve(blob), 'image/png', 0.9);\n                        });\n\n                        if (pngBlob && pngBlob.size > 500) { // Skip very small images\n                          const buffer = await pngBlob.arrayBuffer();\n\n                          // Calculate Y position from top (normalized 0-1)\n                          const yFromTop = 1 - (imgY / pageHeight);\n\n                          pageImages.push({\n                            data: new Uint8Array(buffer),\n                            x: imgX,\n                            y: imgY,\n                            width: imgWidth,\n                            height: imgHeight,\n                            yNormalized: Math.max(0, Math.min(1, yFromTop))\n                          });\n                        }\n                      }\n                    }\n                  } catch (imgError) {\n                    // Skip this image if extraction fails\n                    console.warn('Failed to extract image:', imgError);\n                  }\n                }\n              }\n            } catch (opError) {\n              console.warn('Failed to get operator list for images:', opError);\n            }\n          }\n\n          // === COLUMN DETECTION ===\n          // Detect columns by finding vertical gaps in text distribution\n          const detectColumns = (textItems: PDFTextItem[], pageWidth: number): number[] => {\n            if (textItems.length < 10) return []; // Not enough items to detect columns\n\n            // Collect all X positions with their widths\n            const xRanges: Array<{ start: number; end: number }> = [];\n            for (const item of textItems) {\n              if (!item.str?.trim() || !item.transform) continue;\n              const x = item.transform[4];\n              const width = item.width || (item.str.length * (item.height || 12) * 0.5);\n              xRanges.push({ start: x, end: x + width });\n            }\n\n            if (xRanges.length < 10) return [];\n\n            // Create histogram of X coverage (buckets of 10px)\n            const bucketSize = 10;\n            const numBuckets = Math.ceil(pageWidth / bucketSize);\n            const histogram = new Array(numBuckets).fill(0);\n\n            for (const range of xRanges) {\n              const startBucket = Math.max(0, Math.floor(range.start / bucketSize));\n              const endBucket = Math.min(numBuckets - 1, Math.floor(range.end / bucketSize));\n              for (let b = startBucket; b <= endBucket; b++) {\n                histogram[b]++;\n              }\n            }\n\n            // Find gaps (consecutive empty or near-empty buckets)\n            const minGapWidth = pageWidth * 0.05; // Minimum 5% of page width\n            const threshold = Math.max(2, xRanges.length * 0.02); // Buckets with < 2% of items considered empty\n\n            const gaps: Array<{ start: number; end: number; center: number }> = [];\n            let gapStart = -1;\n\n            // Only look for gaps in the middle 80% of the page (10%-90%)\n            const startBucket = Math.floor(numBuckets * 0.1);\n            const endBucket = Math.floor(numBuckets * 0.9);\n\n            for (let b = startBucket; b <= endBucket; b++) {\n              if (histogram[b] <= threshold) {\n                if (gapStart === -1) gapStart = b;\n              } else {\n                if (gapStart !== -1) {\n                  const gapEnd = b - 1;\n                  const gapWidth = (gapEnd - gapStart + 1) * bucketSize;\n                  if (gapWidth >= minGapWidth) {\n                    gaps.push({\n                      start: gapStart * bucketSize,\n                      end: (gapEnd + 1) * bucketSize,\n                      center: ((gapStart + gapEnd + 1) / 2) * bucketSize\n                    });\n                  }\n                  gapStart = -1;\n                }\n              }\n            }\n\n            // Close any open gap at the end\n            if (gapStart !== -1) {\n              const gapEnd = endBucket;\n              const gapWidth = (gapEnd - gapStart + 1) * bucketSize;\n              if (gapWidth >= minGapWidth) {\n                gaps.push({\n                  start: gapStart * bucketSize,\n                  end: (gapEnd + 1) * bucketSize,\n                  center: ((gapStart + gapEnd + 1) / 2) * bucketSize\n                });\n              }\n            }\n\n            // Return column boundaries (centers of gaps)\n            // Limit to max 3 columns (2 gaps)\n            return gaps.slice(0, 2).map(g => g.center);\n          };\n\n          const columnBoundaries = detectColumns(items, pageWidth);\n\n          // Split items into columns\n          const splitIntoColumns = (textItems: PDFTextItem[], boundaries: number[]): PDFTextItem[][] => {\n            if (boundaries.length === 0) return [textItems];\n\n            const columns: PDFTextItem[][] = [];\n            const sortedBoundaries = [0, ...boundaries, Infinity];\n\n            for (let i = 0; i < sortedBoundaries.length - 1; i++) {\n              const left = sortedBoundaries[i];\n              const right = sortedBoundaries[i + 1];\n              const columnItems = textItems.filter(item => {\n                if (!item.transform) return false;\n                const x = item.transform[4];\n                return x >= left && x < right;\n              });\n              if (columnItems.length > 0) {\n                columns.push(columnItems);\n              }\n            }\n\n            return columns.length > 0 ? columns : [textItems];\n          };\n\n          const columns = splitIntoColumns(items, columnBoundaries);\n\n          // Process each column separately\n          const processColumn = (columnItems: PDFTextItem[]): Array<{ text: string; fontSize: number; y: number; xStart: number; xEnd: number }> => {\n            // Sort items by Y (top to bottom), then by X (left to right)\n            const sortedItems = [...columnItems].sort((a, b) => {\n              const yA = a.transform ? a.transform[5] : 0;\n              const yB = b.transform ? b.transform[5] : 0;\n              const yDiff = yB - yA; // Higher Y = higher on page in PDF coordinates\n              if (Math.abs(yDiff) > 2) return yDiff;\n              const xA = a.transform ? a.transform[4] : 0;\n              const xB = b.transform ? b.transform[4] : 0;\n              return xA - xB;\n            });\n\n            // Group text items by line (same Y position)\n            const lines: Array<{ text: string; fontSize: number; y: number; xStart: number; xEnd: number }> = [];\n            let currentLine = '';\n            let currentFontSize = 0;\n            let lastY = -1;\n            let lastX = -1;\n            let lineXStart = 0;\n            let lineXEnd = 0;\n\n            for (let i = 0; i < sortedItems.length; i++) {\n              const item = sortedItems[i];\n              if (!item.str) continue;\n\n              const itemY = item.transform ? item.transform[5] : 0;\n              const itemX = item.transform ? item.transform[4] : 0;\n              const itemWidth = item.width || (item.str.length * (item.height || 12) * 0.5);\n              const itemHeight = item.height || 12;\n\n              // Check if this is a new line (Y position changed)\n              const isNewLine = lastY !== -1 && Math.abs(itemY - lastY) > 2;\n\n              if (isNewLine && currentLine.trim()) {\n                lines.push({\n                  text: currentLine.trim(),\n                  fontSize: currentFontSize,\n                  y: lastY,\n                  xStart: lineXStart,\n                  xEnd: lineXEnd\n                });\n                currentLine = '';\n                currentFontSize = 0;\n                lastX = -1;\n                lineXStart = itemX;\n                lineXEnd = itemX + itemWidth;\n              }\n\n              // Track line boundaries\n              if (currentLine === '') {\n                lineXStart = itemX;\n              }\n              lineXEnd = itemX + itemWidth;\n\n              // Add space if there's a gap between words on same line\n              if (currentLine && lastX !== -1) {\n                const gap = itemX - lastX;\n                if (gap > itemHeight * 0.3) {\n                  currentLine += ' ';\n                }\n              }\n\n              currentLine += item.str;\n              if (item.height) currentFontSize = Math.max(currentFontSize, item.height);\n              lastY = itemY;\n              lastX = itemX + itemWidth;\n            }\n\n            // Add last line\n            if (currentLine.trim()) {\n              lines.push({\n                text: currentLine.trim(),\n                fontSize: currentFontSize,\n                y: lastY,\n                xStart: lineXStart,\n                xEnd: lineXEnd\n              });\n            }\n\n            return lines;\n          };\n\n          // Process all columns and combine lines\n          const allLines: Array<{ text: string; fontSize: number; y: number; columnIndex: number; xStart: number; xEnd: number }> = [];\n          for (let colIndex = 0; colIndex < columns.length; colIndex++) {\n            const columnLines = processColumn(columns[colIndex]);\n            for (const line of columnLines) {\n              allLines.push({ ...line, columnIndex: colIndex });\n            }\n          }\n\n          // Collect all page elements (paragraphs and images) with Y positions for proper ordering\n          interface PageElement {\n            type: 'paragraph' | 'image';\n            yPosition: number; // Y from top (higher = lower on page in output)\n            paragraph?: Paragraph;\n            image?: ExtractedImage;\n          }\n          const pageElements: PageElement[] = [];\n\n          // Add images to page elements\n          for (const img of pageImages) {\n            pageElements.push({\n              type: 'image',\n              yPosition: img.yNormalized,\n              image: img\n            });\n          }\n\n          // Group lines into paragraphs, processing columns sequentially\n          // (all paragraphs from column 0, then column 1, etc.)\n          for (let colIndex = 0; colIndex < columns.length; colIndex++) {\n            const columnLines = allLines\n              .filter(l => l.columnIndex === colIndex)\n              .sort((a, b) => b.y - a.y); // Sort by Y descending (top to bottom)\n\n            let paragraphLines: string[] = [];\n            let paragraphFontSize = 0;\n            let paragraphXStart = 0;\n            let paragraphXEnd = 0;\n            let paragraphYStart = 0; // Track Y position for ordering\n\n            for (let i = 0; i < columnLines.length; i++) {\n              const line = columnLines[i];\n              const nextLine = columnLines[i + 1];\n\n              // Track Y position of first line in paragraph\n              if (paragraphLines.length === 0) {\n                paragraphYStart = line.y;\n              }\n\n              paragraphLines.push(line.text);\n              paragraphFontSize = Math.max(paragraphFontSize, line.fontSize);\n\n              // Track paragraph bounds for centering detection\n              if (paragraphLines.length === 1) {\n                paragraphXStart = line.xStart;\n                paragraphXEnd = line.xEnd;\n              } else {\n                paragraphXStart = Math.min(paragraphXStart, line.xStart);\n                paragraphXEnd = Math.max(paragraphXEnd, line.xEnd);\n              }\n\n              // Check if paragraph ends (large gap to next line, or end of lines)\n              const lineHeight = line.fontSize || 12;\n              const gapToNext = nextLine ? Math.abs(line.y - nextLine.y) : 999;\n              const isParagraphEnd = !nextLine || gapToNext > lineHeight * 2;\n\n              if (isParagraphEnd && paragraphLines.length > 0) {\n                const paraText = paragraphLines.join(' ');\n                let headingLevel: 'Heading1' | 'Heading2' | 'Heading3' | undefined;\n\n                // === TEXT ALIGNMENT DETECTION ===\n                const lineWidth = paragraphXEnd - paragraphXStart;\n                const leftMargin = paragraphXStart;\n                const rightMargin = pageWidth - paragraphXEnd;\n                const centerThreshold = pageWidth * 0.1; // 10% tolerance for centering\n                const rightAlignThreshold = pageWidth * 0.15; // 15% tolerance for right align\n\n                // Check if text is centered (both margins roughly equal)\n                const isCentered = Math.abs(leftMargin - rightMargin) < centerThreshold;\n                // Check if text is right-aligned (small right margin, large left margin)\n                const isRightAligned = rightMargin < rightAlignThreshold && leftMargin > pageWidth * 0.3;\n                // Check if text spans most of the page width (justified or left-aligned body text)\n                const isFullWidth = lineWidth > pageWidth * 0.7;\n\n                let alignment: AlignmentType | undefined;\n                if (isCentered && !isFullWidth) {\n                  alignment = AlignmentType.CENTER;\n                } else if (isRightAligned && !isFullWidth) {\n                  alignment = AlignmentType.RIGHT;\n                }\n                // Left alignment is default, no need to set explicitly\n\n                if (smartHeadings && paragraphFontSize > 0) {\n                  // Round font size to match pre-analyzed sizes\n                  const roundedFontSize = Math.round(paragraphFontSize * 2) / 2;\n\n                  // First try: use pre-analyzed heading sizes (most accurate)\n                  if (headingSizes && headingSizes.has(roundedFontSize)) {\n                    headingLevel = headingSizes.get(roundedFontSize);\n                  } else {\n                    // Fallback: use ratio-based detection\n                    const fontRatio = paragraphFontSize / avgFontSize;\n                    if (fontRatio >= 1.6) headingLevel = 'Heading1';\n                    else if (fontRatio >= 1.3) headingLevel = 'Heading2';\n                    else if (fontRatio >= 1.15) headingLevel = 'Heading3';\n                  }\n\n                  // Boost: centered short text with larger font is likely a heading\n                  const isShortText = paraText.length < 100 && paragraphLines.length <= 2;\n\n                  if (isCentered && isShortText && paragraphFontSize > avgFontSize && !headingLevel) {\n                    // Centered short text with larger font ‚Üí likely Heading2\n                    headingLevel = 'Heading2';\n                  }\n                }\n\n                // === LIST DETECTION ===\n                // Check for bullet list patterns: ‚Ä¢, -, *, ‚ó¶, ‚ñ™, ‚ñ∏, ‚ñ∫, ‚óè, ‚óã\n                const bulletPattern = /^\\s*([‚Ä¢\\-\\*‚ó¶‚ñ™‚ñ∏‚ñ∫‚óè‚óã])\\s+(.+)$/;\n                // Check for numbered list patterns: 1. 2. 3. or 1) 2) 3) or (1) (2) (3)\n                const numberedPattern = /^\\s*(?:(\\d+)[.\\):]|\\((\\d+)\\))\\s+(.+)$/;\n\n                const bulletMatch = paraText.match(bulletPattern);\n                const numberedMatch = paraText.match(numberedPattern);\n\n                // Calculate normalized Y position for ordering\n                const paragraphYNormalized = 1 - (paragraphYStart / pageHeight);\n\n                let para: Paragraph;\n                if (bulletMatch && !headingLevel) {\n                  // Bulleted list item\n                  const listText = bulletMatch[2];\n                  para = new Paragraph({\n                    children: [\n                      new TextRun({\n                        text: listText,\n                        size: 22,\n                      }),\n                    ],\n                    bullet: { level: 0 },\n                    alignment: alignment,\n                  });\n                } else if (numberedMatch && !headingLevel) {\n                  // Numbered list item\n                  const listText = numberedMatch[3];\n                  para = new Paragraph({\n                    children: [\n                      new TextRun({\n                        text: listText,\n                        size: 22,\n                      }),\n                    ],\n                    numbering: { reference: 'default-numbering', level: 0 },\n                    alignment: alignment,\n                  });\n                } else {\n                  // Regular paragraph or heading\n                  para = new Paragraph({\n                    children: [\n                      new TextRun({\n                        text: paraText,\n                        size: 22,\n                        bold: headingLevel !== undefined,\n                      }),\n                    ],\n                    heading: headingLevel,\n                    alignment: alignment,\n                  });\n                }\n\n                pageElements.push({\n                  type: 'paragraph',\n                  yPosition: paragraphYNormalized,\n                  paragraph: para\n                });\n\n                paragraphLines = [];\n                paragraphFontSize = 0;\n                paragraphXStart = 0;\n                paragraphXEnd = 0;\n              }\n            }\n          }\n\n          // Sort all elements by Y position (top to bottom)\n          pageElements.sort((a, b) => a.yPosition - b.yPosition);\n\n          // Add elements to sections with proper image handling\n          for (const element of pageElements) {\n            if (element.type === 'paragraph' && element.paragraph) {\n              sections.push(element.paragraph);\n            } else if (element.type === 'image' && element.image) {\n              // Determine image alignment based on X position\n              const img = element.image;\n              const imgCenterX = img.x + img.width / 2;\n              const pageCenter = pageWidth / 2;\n\n              let imgAlignment = AlignmentType.LEFT;\n              if (Math.abs(imgCenterX - pageCenter) < pageWidth * 0.15) {\n                imgAlignment = AlignmentType.CENTER;\n              } else if (imgCenterX > pageCenter + pageWidth * 0.2) {\n                imgAlignment = AlignmentType.RIGHT;\n              }\n\n              // Scale image to fit Word page width (max ~500px)\n              const maxImgWidth = 500;\n              const maxImgHeight = 600;\n              let scaledWidth = img.width;\n              let scaledHeight = img.height;\n\n              if (scaledWidth > maxImgWidth) {\n                const ratio = maxImgWidth / scaledWidth;\n                scaledWidth = maxImgWidth;\n                scaledHeight = Math.round(scaledHeight * ratio);\n              }\n              if (scaledHeight > maxImgHeight) {\n                const ratio = maxImgHeight / scaledHeight;\n                scaledHeight = maxImgHeight;\n                scaledWidth = Math.round(scaledWidth * ratio);\n              }\n\n              // Determine if image should float (for smaller images not centered)\n              const isSmallImage = scaledWidth < pageWidth * 0.4;\n              const shouldFloat = isSmallImage && imgAlignment !== AlignmentType.CENTER;\n\n              if (shouldFloat) {\n                // Floating image with text wrap\n                const horizontalPos = img.x < pageWidth / 2 ? 'left' : 'right';\n                sections.push(\n                  new Paragraph({\n                    children: [\n                      new ImageRun({\n                        data: img.data,\n                        transformation: {\n                          width: scaledWidth,\n                          height: scaledHeight,\n                        },\n                        type: 'png',\n                        floating: {\n                          horizontalPosition: {\n                            relative: 'column',\n                            align: horizontalPos,\n                          },\n                          verticalPosition: {\n                            relative: 'paragraph',\n                            offset: 0,\n                          },\n                          wrap: {\n                            type: 'square',\n                            side: 'bothSides',\n                          },\n                          margins: {\n                            top: 100000,\n                            bottom: 100000,\n                            left: horizontalPos === 'right' ? 200000 : 0,\n                            right: horizontalPos === 'left' ? 200000 : 0,\n                          },\n                        },\n                      }),\n                    ],\n                  })\n                );\n              } else {\n                // Inline image (centered or full-width)\n                sections.push(\n                  new Paragraph({\n                    children: [\n                      new ImageRun({\n                        data: img.data,\n                        transformation: {\n                          width: scaledWidth,\n                          height: scaledHeight,\n                        },\n                        type: 'png',\n                      }),\n                    ],\n                    alignment: imgAlignment,\n                  })\n                );\n              }\n            }\n          }\n        }\n\n        // Add page break after each page except the last one\n        if (pageNum < numPages) {\n          sections.push(\n            new Paragraph({\n              children: [],\n              pageBreakBefore: true,\n            })\n          );\n        }\n\n        onProgress?.(15 + (pageNum / numPages) * 60, `Processing page ${pageNum}/${numPages}...`);\n      }\n\n      onProgress?.(80, 'Creating Word document...');\n\n      // Create DOCX document with numbering definition for lists\n      const doc = new Document({\n        numbering: {\n          config: [\n            {\n              reference: 'default-numbering',\n              levels: [\n                {\n                  level: 0,\n                  format: 'decimal',\n                  text: '%1.',\n                  alignment: 'start',\n                  style: {\n                    paragraph: {\n                      indent: { left: 720, hanging: 360 },\n                    },\n                  },\n                },\n              ],\n            },\n          ],\n        },\n        sections: [\n          {\n            properties: {},\n            children: sections,\n          },\n        ],\n      });\n\n      onProgress?.(90, 'Generating DOCX file...');\n\n      // Generate blob\n      const docxBuffer = await Packer.toBlob(doc);\n\n      onProgress?.(100, 'Conversion complete!');\n\n      return {\n        success: true,\n        data: docxBuffer,\n        metadata: {\n          pageCount: numPages, // Approximation or track actual pages\n          originalSize: file.size,\n          processedSize: docxBuffer.size,\n          processingTime: 0 // Track if needed\n        }\n      };\n\n    } catch (error) {\n      console.error('PDF to Word conversion error:', error);\n      return {\n        success: false,\n        error: this.createPDFError(error, 'PDF to Word conversion failed')\n      };\n    }\n  }\n\n  /**\n   * Find text occurrences in PDF using PDF.js\n   */\n  async findTextInPDF(\n    file: File,\n    searchText: string,\n    pageNumber?: number\n  ): Promise<import('@/types/pdf').TextOccurrence[]> {\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;\n      const occurrences: import('@/types/pdf').TextOccurrence[] = [];\n\n      const startPage = pageNumber || 1;\n      const endPage = pageNumber || pdf.numPages;\n\n      for (let pageNum = startPage; pageNum <= endPage; pageNum++) {\n        const page = await pdf.getPage(pageNum);\n        const textContent = await page.getTextContent();\n        const viewport = page.getViewport({ scale: 1.0 });\n\n        // Search through text items\n        for (const item of textContent.items) {\n          if ('str' in item && item.str.toLowerCase().includes(searchText.toLowerCase())) {\n            const transform = item.transform;\n            const x = transform[4];\n            const y = viewport.height - transform[5]; // Convert to top-left origin\n            const width = item.width || 100;\n            const height = item.height || 20;\n\n            occurrences.push({\n              id: `search-${pageNum}-${x}-${y}`,\n              pageNumber: pageNum,\n              text: item.str,\n              mode: 'replace', // Default to replace mode\n              x,\n              y,\n              width,\n              height,\n            });\n          }\n        }\n      }\n\n      return occurrences;\n    } catch (error) {\n      console.error('Error finding text in PDF:', error);\n      throw this.createPDFError(error, 'Text search failed');\n    }\n  }\n\n  /**\n   * Create a standardized PDF error\n   */\n  private createPDFError(error: unknown, context: string = 'PDF processing'): ProcessingError {\n    let message = 'An error occurred during PDF processing';\n\n    if (error instanceof Error) {\n      message = error.message;\n\n      const errorText = message.toLowerCase();\n\n      if (errorText.includes('invalid') || errorText.includes('corrupt')) {\n        message = 'The PDF file is corrupted or invalid';\n      } else if (errorText.includes('too large') || errorText.includes('size')) {\n        message = 'The file is too large to process';\n      } else if (errorText.includes('memory')) {\n        message = 'Not enough memory to process the file';\n      }\n    }\n\n    return {\n      code: 'PROCESSING_ERROR',\n      message: `${context}: ${message}`,\n      details: error instanceof Error ? error.stack : String(error)\n    };\n  }\n\n  /**\n   * Add form fields to PDF\n   * Creates interactive fillable forms with text fields, checkboxes, radio buttons, and dropdowns\n   */\n  async addFormFieldsToPDF(\n    file: File,\n    options: FormFieldOptions\n  ): Promise<PDFProcessingResult<Blob>> {\n    try {\n      const { fields, onProgress } = options;\n\n      onProgress?.(10, 'Loading PDF document...');\n\n      // Load the PDF\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n\n      onProgress?.(20, 'Creating form...');\n\n      // Get or create the form\n      const form = pdfDoc.getForm();\n\n      // Process each field\n      for (let i = 0; i < fields.length; i++) {\n        const field = fields[i];\n        const progress = 20 + (i / fields.length) * 60;\n        onProgress?.(progress, `Adding field ${i + 1}/${fields.length}...`);\n\n        // Get the page\n        const page = pdfDoc.getPage(field.page);\n        const { height: pageHeight } = page.getSize();\n\n        // Convert Y coordinate (canvas uses top-left origin, PDF uses bottom-left)\n        const pdfY = pageHeight - field.y - field.height;\n\n        try {\n          switch (field.type) {\n            case 'text': {\n              const textField = field as TextFormField;\n              const pdfTextField = form.createTextField(textField.name);\n              pdfTextField.addToPage(page, {\n                x: textField.x,\n                y: pdfY,\n                width: textField.width,\n                height: textField.height,\n              });\n\n              if (textField.defaultValue) {\n                pdfTextField.setText(textField.defaultValue);\n              }\n              if (textField.maxLength) {\n                pdfTextField.setMaxLength(textField.maxLength);\n              }\n              if (textField.fontSize) {\n                pdfTextField.defaultUpdateAppearances(await pdfDoc.embedFont(StandardFonts.Helvetica));\n              }\n              if (textField.required) {\n                pdfTextField.enableRequired();\n              }\n              if (textField.readonly) {\n                pdfTextField.enableReadOnly();\n              }\n              break;\n            }\n\n            case 'multiline': {\n              const multilineField = field as MultilineFormField;\n              const pdfTextField = form.createTextField(multilineField.name);\n              pdfTextField.addToPage(page, {\n                x: multilineField.x,\n                y: pdfY,\n                width: multilineField.width,\n                height: multilineField.height,\n              });\n              pdfTextField.enableMultiline();\n\n              if (multilineField.defaultValue) {\n                pdfTextField.setText(multilineField.defaultValue);\n              }\n              if (multilineField.maxLength) {\n                pdfTextField.setMaxLength(multilineField.maxLength);\n              }\n              if (multilineField.fontSize) {\n                pdfTextField.defaultUpdateAppearances(await pdfDoc.embedFont(StandardFonts.Helvetica));\n              }\n              if (multilineField.required) {\n                pdfTextField.enableRequired();\n              }\n              if (multilineField.readonly) {\n                pdfTextField.enableReadOnly();\n              }\n              break;\n            }\n\n            case 'checkbox': {\n              const checkboxField = field as CheckboxFormField;\n              const pdfCheckbox = form.createCheckBox(checkboxField.name);\n              pdfCheckbox.addToPage(page, {\n                x: checkboxField.x,\n                y: pdfY,\n                width: checkboxField.width,\n                height: checkboxField.height,\n              });\n\n              if (checkboxField.checked) {\n                pdfCheckbox.check();\n              }\n              if (checkboxField.required) {\n                pdfCheckbox.enableRequired();\n              }\n              if (checkboxField.readonly) {\n                pdfCheckbox.enableReadOnly();\n              }\n              break;\n            }\n\n            case 'radio': {\n              const radioField = field as RadioFormField;\n              // Check if radio group already exists\n              let radioGroup;\n              try {\n                radioGroup = form.getRadioGroup(radioField.group);\n              } catch {\n                radioGroup = form.createRadioGroup(radioField.group);\n              }\n\n              radioGroup.addOptionToPage(radioField.value, page, {\n                x: radioField.x,\n                y: pdfY,\n                width: radioField.width,\n                height: radioField.height,\n              });\n\n              if (radioField.selected) {\n                radioGroup.select(radioField.value);\n              }\n              if (radioField.required) {\n                radioGroup.enableRequired();\n              }\n              if (radioField.readonly) {\n                radioGroup.enableReadOnly();\n              }\n              break;\n            }\n\n            case 'dropdown': {\n              const dropdownField = field as DropdownFormField;\n              const pdfDropdown = form.createDropdown(dropdownField.name);\n              pdfDropdown.addToPage(page, {\n                x: dropdownField.x,\n                y: pdfY,\n                width: dropdownField.width,\n                height: dropdownField.height,\n              });\n\n              pdfDropdown.addOptions(dropdownField.options);\n\n              if (dropdownField.selectedIndex !== undefined && dropdownField.options[dropdownField.selectedIndex]) {\n                pdfDropdown.select(dropdownField.options[dropdownField.selectedIndex]);\n              }\n              if (dropdownField.multiSelect) {\n                pdfDropdown.enableMultiselect();\n              }\n              if (dropdownField.required) {\n                pdfDropdown.enableRequired();\n              }\n              if (dropdownField.readonly) {\n                pdfDropdown.enableReadOnly();\n              }\n              break;\n            }\n          }\n        } catch (fieldError) {\n          console.warn(`Failed to add field ${field.name}:`, fieldError);\n          // Continue with other fields even if one fails\n        }\n      }\n\n      onProgress?.(85, 'Saving PDF...');\n\n      // Save the PDF\n      const pdfBytes = await pdfDoc.save();\n      const blob = new Blob([pdfBytes], { type: 'application/pdf' });\n\n      onProgress?.(100, 'Complete');\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pageCount: pdfDoc.getPageCount(),\n          originalSize: file.size,\n          processedSize: blob.size,\n          processingTime: 0,\n        }\n      };\n    } catch (error) {\n      console.warn('Failed to add fields:', error);\n      return {\n        success: false,\n        error: this.createPDFError(error, 'Failed to add form fields')\n      };\n    }\n  }\n\n  /**\n   * Edit text in a PDF using a vector-based approach (no rasterization)\n   */\n  async editTextInPDFVector(\n    file: File,\n    options: import('@/types/pdf').VectorEditTextOptions,\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult<Blob>> {\n    const startTime = Date.now();\n\n    try {\n      onProgress?.(0, 'Loading PDF...');\n      const {\n        selections,\n        backgroundColor,\n        textColor,\n        fontSize,\n        fontFamily,\n        isBold,\n        isItalic,\n        textOffsetX,\n        textOffsetY,\n        canvasScale\n      } = options;\n\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n      pdfDoc.registerFontkit(fontkit);\n\n      onProgress?.(10, 'Loading fonts...');\n\n      // Map font family to pdf-lib standard fonts\n      const fontMap = {\n        'Arial': StandardFonts.Helvetica,\n        'Helvetica': StandardFonts.Helvetica,\n        'Times New Roman': StandardFonts.TimesRoman,\n        'Courier New': StandardFonts.Courier,\n        'Georgia': StandardFonts.TimesRoman, // No direct match, use Times\n        'Verdana': StandardFonts.Helvetica, // No direct match, use Helvetica\n      };\n\n      const boldFontMap = {\n        'Arial': StandardFonts.HelveticaBold,\n        'Helvetica': StandardFonts.HelveticaBold,\n        'Times New Roman': StandardFonts.TimesRomanBold,\n        'Courier New': StandardFonts.CourierBold,\n        'Georgia': StandardFonts.TimesRomanBold,\n        'Verdana': StandardFonts.HelveticaBold,\n      };\n\n      const italicFontMap = {\n        'Arial': StandardFonts.HelveticaOblique,\n        'Helvetica': StandardFonts.HelveticaOblique,\n        'Times New Roman': StandardFonts.TimesRomanItalic,\n        'Courier New': StandardFonts.CourierOblique,\n        'Georgia': StandardFonts.TimesRomanItalic,\n        'Verdana': StandardFonts.HelveticaOblique,\n      };\n\n      const boldItalicFontMap = {\n        'Arial': StandardFonts.HelveticaBoldOblique,\n        'Helvetica': StandardFonts.HelveticaBoldOblique,\n        'Times New Roman': StandardFonts.TimesRomanBoldItalic,\n        'Courier New': StandardFonts.CourierBoldOblique,\n        'Georgia': StandardFonts.TimesRomanBoldItalic,\n        'Verdana': StandardFonts.HelveticaBoldOblique,\n      };\n\n      let fontKey = fontMap[fontFamily];\n      if (isBold && isItalic) fontKey = boldItalicFontMap[fontFamily];\n      else if (isBold) fontKey = boldFontMap[fontFamily];\n      else if (isItalic) fontKey = italicFontMap[fontFamily];\n\n      const font = await pdfDoc.embedFont(fontKey);\n\n      // Group selections by page\n      const selectionsByPage = new Map<number, typeof selections>();\n      for (const sel of selections) {\n        if (!selectionsByPage.has(sel.pageNumber)) {\n          selectionsByPage.set(sel.pageNumber, []);\n        }\n        selectionsByPage.get(sel.pageNumber)!.push(sel);\n      }\n\n      const totalPagesToProcess = selectionsByPage.size;\n      let processedPages = 0;\n\n      onProgress?.(20, `Preparing to edit ${totalPagesToProcess} pages...`);\n\n      // Process each page\n      for (const [pageNum, pageSelections] of selectionsByPage.entries()) {\n        const page = pdfDoc.getPage(pageNum - 1);\n        const { height: pageHeight } = page.getSize();\n        const { width: pageWidth } = page.getSize();\n\n        // Get the original page's viewport to calculate scaling\n        const pdfjsDoc = await pdfjsLib.getDocument({ data: arrayBuffer.slice(0) }).promise;\n        const pdfjsPage = await pdfjsDoc.getPage(pageNum);\n        const viewport = pdfjsPage.getViewport({ scale: canvasScale });\n\n        const scaleX = pageWidth / viewport.width;\n        const scaleY = pageHeight / viewport.height;\n\n        for (const sel of pageSelections) {\n          // Scale selection coordinates from canvas space to PDF space\n          const pdfX = sel.x * scaleX;\n          const pdfY = pageHeight - (sel.y * scaleY);\n          const pdfWidth = sel.width * scaleX;\n          const pdfHeight = sel.height * scaleY;\n\n          // Draw background rectangle\n          const bgColor = this.hexToRgb(backgroundColor);\n          page.drawRectangle({\n            x: pdfX,\n            y: pdfY - pdfHeight,\n            width: pdfWidth,\n            height: pdfHeight,\n            color: rgb(bgColor.red, bgColor.green, bgColor.blue),\n            borderWidth: 0,\n          });\n\n          if (sel.mode === 'replace' && sel.text) {\n            // Simple word wrap implementation\n            const words = sel.text.split(' ');\n            const lines: string[] = [];\n            let line = '';\n            // Adjust starting Y for text baseline and offset\n            let currentY = pdfY - (textOffsetY * scaleY) - (fontSize);\n\n            const textWidth = pdfWidth - (textOffsetX * scaleX * 2);\n            const txtColor = this.hexToRgb(textColor);\n            const alignment = sel.textAlign || 'left';\n\n            // Build lines with word wrapping\n            for (let n = 0; n < words.length; n++) {\n              const testLine = line + words[n] + ' ';\n              const width = font.widthOfTextAtSize(testLine, fontSize);\n              if (width > textWidth && n > 0) {\n                lines.push(line.trim());\n                line = words[n] + ' ';\n              } else {\n                line = testLine;\n              }\n            }\n            if (line.trim()) {\n              lines.push(line.trim());\n            }\n\n            // Draw each line with proper alignment\n            for (const lineText of lines) {\n              const lineWidth = font.widthOfTextAtSize(lineText, fontSize);\n              let lineX = pdfX + (textOffsetX * scaleX);\n\n              // Apply text alignment\n              if (alignment === 'center') {\n                lineX += (textWidth - lineWidth) / 2;\n              } else if (alignment === 'right') {\n                lineX += (textWidth - lineWidth);\n              }\n\n              page.drawText(lineText, {\n                x: lineX,\n                y: currentY,\n                font,\n                size: fontSize,\n                color: rgb(txtColor.red, txtColor.green, txtColor.blue),\n              });\n              currentY -= (fontSize * 1.2); // Move to next line\n            }\n          }\n        }\n        processedPages++;\n        onProgress?.(\n          20 + (processedPages / totalPagesToProcess) * 70,\n          `Processing page ${pageNum} (${processedPages}/${totalPagesToProcess})...`\n        );\n      }\n\n      onProgress?.(90, 'Saving PDF...');\n      const pdfBytes = await pdfDoc.save();\n      const resultBlob = new Blob([pdfBytes], { type: 'application/pdf' });\n      onProgress?.(100, 'Edits applied successfully!');\n\n      return {\n        success: true,\n        data: resultBlob,\n        metadata: {\n          pageCount: pdfDoc.getPageCount(),\n          originalSize: file.size,\n          processedSize: resultBlob.size,\n          processingTime: Date.now() - startTime\n        }\n      };\n    } catch (error) {\n      console.error('Error editing text in PDF (Vector):', error);\n      return {\n        success: false,\n        error: this.createPDFError(error, 'Vector text edit failed'),\n      };\n    }\n  }\n\n  /**\n   * Helper to convert hex color string to RGB object for pdf-lib\n   */\n  private hexToRgb(hex: string): { red: number; green: number; blue: number } {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (!result) {\n      return { red: 0, green: 0, blue: 0 }; // Default to black\n    }\n    return {\n      red: parseInt(result[1], 16) / 255,\n      green: parseInt(result[2], 16) / 255,\n      blue: parseInt(result[3], 16) / 255,\n    };\n  }\n\n  /**\n   * Organize PDF pages - reorder, rotate, and delete pages\n   */\n  /**\n   * Organize PDF pages - reorder, rotate, delete, and insert pages from other files\n   */\n  async organizePDF(\n    file: File,\n    pageOperations: Array<{\n      originalPageNumber: number;\n      rotation: number;\n      sourceFile?: File; // Optional: if provided, page comes from this file\n    }>,\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult<Blob>> {\n    try {\n      onProgress?.(10, 'Loading resources...');\n\n      // Map to store loaded source documents to avoid reloading\n      const sourceDocs = new Map<File, PDFDocument>();\n\n      // Helper to get or load a document\n      const getSourceDoc = async (f: File) => {\n        if (!sourceDocs.has(f)) {\n          const arrayBuffer = await f.arrayBuffer();\n          const doc = await PDFDocument.load(arrayBuffer, { ignoreEncryption: true });\n          sourceDocs.set(f, doc);\n        }\n        return sourceDocs.get(f);\n      };\n\n      // Load main source PDF first\n      await getSourceDoc(file);\n\n      onProgress?.(20, 'Creating new document...');\n\n      // Create new PDF document\n      const newPdf = await PDFDocument.create();\n\n      onProgress?.(30, 'Organizing pages...');\n\n      // Copy pages in new order with rotations\n      const totalOperations = pageOperations.length;\n      for (let i = 0; i < totalOperations; i++) {\n        const operation = pageOperations[i];\n\n        // Progress update\n        const progressPercent = 30 + Math.floor((i / totalOperations) * 50);\n        onProgress?.(\n          progressPercent,\n          `Processing page ${i + 1}/${totalOperations}...`\n        );\n\n        // Determine source file and document\n        const sourceFile = operation.sourceFile || file;\n        const sourcePdf = await getSourceDoc(sourceFile);\n\n        // Get source page (pdf-lib uses 0-based indexing)\n        const sourcePageIndex = operation.originalPageNumber - 1;\n\n        if (sourcePageIndex < 0 || sourcePageIndex >= sourcePdf.getPageCount()) {\n          console.warn(`Invalid page number: ${operation.originalPageNumber} for file ${sourceFile.name}`);\n          continue;\n        }\n\n        // Copy page to new document\n        const [copiedPage] = await newPdf.copyPages(sourcePdf, [sourcePageIndex]);\n\n        // Apply rotation if needed\n        if (operation.rotation !== 0) {\n          const currentRotation = copiedPage.getRotation().angle;\n          copiedPage.setRotation(degrees(currentRotation + operation.rotation));\n        }\n\n        // Add page to new document\n        newPdf.addPage(copiedPage);\n      }\n\n      onProgress?.(85, 'Finalizing document...');\n\n      // Save the new PDF\n      const pdfBytes = await newPdf.save();\n      const blob = new Blob([pdfBytes], { type: 'application/pdf' });\n\n      onProgress?.(100, 'Complete!');\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pageCount: newPdf.getPageCount(),\n          originalSize: file.size, // Note: this might not be accurate if we added many files, but it's a baseline\n          processedSize: blob.size,\n          processingTime: 0,\n        },\n      };\n    } catch (error) {\n      console.error('Error organizing PDF:', error);\n      return {\n        success: false,\n        error: this.createPDFError(error, 'Failed to organize PDF')\n      };\n    }\n  }\n}\n\nconst pdfService = PDFService.getInstance();\nexport default pdfService;\n\nexport { pdfService };\nexport type { PDFFileInfo, PDFProcessingResult };\n\n// Export individual methods for convenience\nexport const mergePDFs = (files: File[], onProgress?: ProgressCallback, options?: MergeOptions) =>\n  pdfService.mergePDFs(files, onProgress, options);\n\nexport const splitPDF = (\n  file: File,\n  mode: 'pages' | 'range' | 'intervals' | 'custom',\n  options: { pages?: number[]; start?: number; end?: number; interval?: number },\n  onProgress?: ProgressCallback\n) => pdfService.splitPDF(file, mode, options, onProgress);\n\nexport const compressPDF = (file: File, quality: 'low' | 'medium' | 'high', onProgress?: ProgressCallback) =>\n  pdfService.compressPDF(file, quality, onProgress);\n\nexport const protectPDF = (\n  file: File,\n  settings: ProtectionSettings,\n  onProgress?: (progress: ProtectionProgress) => void\n) => pdfService.protectPDF(file, settings, onProgress);\n\nexport const rotatePDF = (\n  file: File,\n  angle: 90 | 180 | 270,\n  pages: number[],\n  onProgress?: ProgressCallback\n) => pdfService.rotatePDF(file, angle, pages, onProgress);\n\nexport const deletePDF = (\n  file: File,\n  pagesToDelete: number[],\n  onProgress?: ProgressCallback\n) => pdfService.deletePDF(file, pagesToDelete, onProgress);\n\nexport const flattenPDF = (file: File, onProgress?: ProgressCallback) =>\n  pdfService.flattenPDF(file, onProgress);\n\nexport const extractPDF = (\n  file: File,\n  pagesToExtract: number[],\n  onProgress?: ProgressCallback\n) => pdfService.extractPDF(file, pagesToExtract, onProgress);\n\nexport const getPDFInfo = (file: File) => pdfService.getPDFInfo(file);\nexport const validatePDF = (file: File) => pdfService.validatePDF(file);\nexport const downloadFile = (blob: Blob, filename: string) => pdfService.downloadFile(blob, filename);\nexport const createZipArchive = (files: Array<{ blob: Blob; filename: string }>, onProgress?: ProgressCallback) =>\n  pdfService.createZipArchive(files, onProgress);\nexport const downloadAsZip = (files: Array<{ blob: Blob; filename: string }>, archiveName: string, onProgress?: ProgressCallback) =>\n  pdfService.downloadAsZip(files, archiveName, onProgress);\nexport const formatFileSize = (bytes: number) => pdfService.formatFileSize(bytes);\nexport const formatTime = (ms: number) => pdfService.formatTime(ms);\nexport const wordToPDF = (\n  file: File,\n  onProgress?: ProgressCallback,\n  options?: { mode?: 'formatted' | 'text'; quality?: 1 | 2 | 3 }\n) => pdfService.wordToPDF(file, onProgress, options);\nexport const pdfToWord = (\n  file: File,\n  onProgress?: ProgressCallback,\n  options?: { includeImages?: boolean; smartHeadings?: boolean }\n) => pdfService.pdfToWord(file, onProgress, options);\nexport const addFormFieldsToPDF = (file: File, options: FormFieldOptions) =>\n  pdfService.addFormFieldsToPDF(file, options);\n\nexport const organizePDF = (\n  file: File,\n  pageOperations: Array<{\n    originalPageNumber: number;\n    newPosition: number;\n    rotation: number;\n  }>,\n  onProgress?: ProgressCallback\n) => pdfService.organizePDF(file, pageOperations, onProgress);\n","usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/services/smartImageFilterService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/services/smartMergeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/services/smartOrganizeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/types/addText.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/types/formFields.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/types/image.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/types/pdf.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/utils/languageDetector.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/utils/ocrWorkerManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/utils/quickOCR.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/utils/searchablePDFGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/src/utils/textToPDFGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/website/astro.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/website/src/content.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/website/src/content/config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/website/src/pages/blog/rss.xml.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/aleksejskokoulins/Desktop/clientpdf-pro/website/src/pages/blog/search.json.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
