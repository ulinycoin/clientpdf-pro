/**
 * LocalPDF Service Worker
 * 
 * –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –æ—Ñ–ª–∞–π–Ω —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å –∏ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ—Å—É—Ä—Å–æ–≤.
 * –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç app shell pattern –¥–ª—è –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ UI.
 */

const CACHE_NAME = 'localpdf-v1.0.0';
const STATIC_CACHE = 'localpdf-static-v1.0.0';
const DYNAMIC_CACHE = 'localpdf-dynamic-v1.0.0';

// –†–µ—Å—É—Ä—Å—ã –¥–ª—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è (app shell)
const STATIC_ASSETS = [
  '/',
  '/index.html',
  '/manifest.json',
  '/favicon.svg',
  '/favicon.ico',
  // –î–æ–±–∞–≤—è—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏ —Å–±–æ—Ä–∫–µ
];

// CDN —Ä–µ—Å—É—Ä—Å—ã –¥–ª—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
const CDN_ASSETS = [
  'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js',
  'https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap',
];

// –°—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
const CACHE_STRATEGIES = {
  CACHE_FIRST: 'cache-first',
  NETWORK_FIRST: 'network-first',
  STALE_WHILE_REVALIDATE: 'stale-while-revalidate',
  NETWORK_ONLY: 'network-only',
  CACHE_ONLY: 'cache-only'
};

// –ü—Ä–∞–≤–∏–ª–∞ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Ä–µ—Å—É—Ä—Å–æ–≤
const CACHE_RULES = [
  {
    pattern: /\.(js|css|woff2|woff|ttf)$/,
    strategy: CACHE_STRATEGIES.CACHE_FIRST,
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 –¥–Ω–µ–π
  },
  {
    pattern: /\.(png|jpg|jpeg|gif|svg|ico)$/,
    strategy: CACHE_STRATEGIES.CACHE_FIRST,
    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 –¥–Ω–µ–π
  },
  {
    pattern: /\.html$/,
    strategy: CACHE_STRATEGIES.NETWORK_FIRST,
    maxAge: 24 * 60 * 60 * 1000, // 1 –¥–µ–Ω—å
  },
  {
    pattern: /\/api\//,
    strategy: CACHE_STRATEGIES.NETWORK_ONLY,
  }
];

/**
 * –£—Å—Ç–∞–Ω–æ–≤–∫–∞ Service Worker
 */
self.addEventListener('install', (event) => {
  console.log('üîß Service Worker installing...');
  
  event.waitUntil(
    Promise.all([
      cacheStaticAssets(),
      cacheCDNAssets()
    ]).then(() => {
      console.log('‚úÖ Service Worker installed successfully');
      // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–π SW
      return self.skipWaiting();
    }).catch((error) => {
      console.error('‚ùå Service Worker installation failed:', error);
    })
  );
});

/**
 * –ê–∫—Ç–∏–≤–∞—Ü–∏—è Service Worker
 */
self.addEventListener('activate', (event) => {
  console.log('üöÄ Service Worker activating...');
  
  event.waitUntil(
    Promise.all([
      cleanupOldCaches(),
      claimClients()
    ]).then(() => {
      console.log('‚úÖ Service Worker activated successfully');
    }).catch((error) => {
      console.error('‚ùå Service Worker activation failed:', error);
    })
  );
});

/**
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ fetch –∑–∞–ø—Ä–æ—Å–æ–≤
 */
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º non-GET –∑–∞–ø—Ä–æ—Å—ã
  if (request.method !== 'GET') {
    return;
  }

  // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º chrome-extension –∏ webkit –∑–∞–ø—Ä–æ—Å—ã
  if (url.protocol.startsWith('chrome-extension') || 
      url.protocol.startsWith('webkit')) {
    return;
  }

  event.respondWith(handleFetchRequest(request));
});

/**
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç main thread
 */
self.addEventListener('message', (event) => {
  const { data } = event;
  
  switch (data.type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;
      
    case 'GET_CACHE_SIZE':
      getCacheSize().then(size => {
        event.ports[0].postMessage({ type: 'CACHE_SIZE', size });
      });
      break;
      
    case 'CLEAR_CACHE':
      clearAllCaches().then(() => {
        event.ports[0].postMessage({ type: 'CACHE_CLEARED' });
      });
      break;
      
    case 'PRELOAD_ASSETS':
      preloadAssets(data.assets).then(() => {
        event.ports[0].postMessage({ type: 'ASSETS_PRELOADED' });
      });
      break;
  }
});

/**
 * –ö–µ—à–∏—Ä—É–µ—Ç —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ—Å—É—Ä—Å—ã
 */
async function cacheStaticAssets() {
  try {
    const cache = await caches.open(STATIC_CACHE);
    
    // –ü–æ–ª—É—á–∞–µ–º –º–∞–Ω–∏—Ñ–µ—Å—Ç —Å–±–æ—Ä–∫–∏ –¥–ª—è –∞–∫—Ç—É–∞–ª—å–Ω—ã—Ö –ø—É—Ç–µ–π
    const assetsToCache = await getAssetPaths();
    
    await cache.addAll(assetsToCache);
    console.log(`üì¶ Cached ${assetsToCache.length} static assets`);
  } catch (error) {
    console.error('‚ùå Failed to cache static assets:', error);
  }
}

/**
 * –ö–µ—à–∏—Ä—É–µ—Ç CDN —Ä–µ—Å—É—Ä—Å—ã
 */
async function cacheCDNAssets() {
  try {
    const cache = await caches.open(STATIC_CACHE);
    
    for (const asset of CDN_ASSETS) {
      try {
        await cache.add(asset);
      } catch (error) {
        console.warn(`‚ö†Ô∏è Failed to cache CDN asset: ${asset}`, error);
      }
    }
    
    console.log(`üåê Cached ${CDN_ASSETS.length} CDN assets`);
  } catch (error) {
    console.error('‚ùå Failed to cache CDN assets:', error);
  }
}

/**
 * –ü–æ–ª—É—á–∞–µ—Ç –ø—É—Ç–∏ —Ä–µ—Å—É—Ä—Å–æ–≤ –¥–ª—è –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
 */
async function getAssetPaths() {
  const baseAssets = [...STATIC_ASSETS];
  
  try {
    // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –º–∞–Ω–∏—Ñ–µ—Å—Ç Vite
    const manifestResponse = await fetch('/manifest.json');
    if (manifestResponse.ok) {
      const manifest = await manifestResponse.json();
      // –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ—Å—É—Ä—Å—ã –∏–∑ –º–∞–Ω–∏—Ñ–µ—Å—Ç–∞
      if (manifest.src) {
        baseAssets.push(manifest.src);
      }
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è Could not load manifest, using base assets only');
  }
  
  return baseAssets;
}

/**
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç fetch –∑–∞–ø—Ä–æ—Å —Å–æ–≥–ª–∞—Å–Ω–æ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
 */
async function handleFetchRequest(request) {
  const url = new URL(request.url);
  
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è
  const rule = findCacheRule(url.pathname);
  
  switch (rule.strategy) {
    case CACHE_STRATEGIES.CACHE_FIRST:
      return cacheFirst(request, rule);
      
    case CACHE_STRATEGIES.NETWORK_FIRST:
      return networkFirst(request, rule);
      
    case CACHE_STRATEGIES.STALE_WHILE_REVALIDATE:
      return staleWhileRevalidate(request, rule);
      
    case CACHE_STRATEGIES.NETWORK_ONLY:
      return fetch(request);
      
    case CACHE_STRATEGIES.CACHE_ONLY:
      return cacheOnly(request);
      
    default:
      return networkFirst(request, rule);
  }
}

/**
 * –ù–∞—Ö–æ–¥–∏—Ç –ø—Ä–∞–≤–∏–ª–æ –∫–µ—à–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è URL
 */
function findCacheRule(pathname) {
  for (const rule of CACHE_RULES) {
    if (rule.pattern.test(pathname)) {
      return rule;
    }
  }
  
  // –î–µ—Ñ–æ–ª—Ç–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ
  return {
    strategy: CACHE_STRATEGIES.NETWORK_FIRST,
    maxAge: 24 * 60 * 60 * 1000
  };
}

/**
 * –°—Ç—Ä–∞—Ç–µ–≥–∏—è Cache First
 */
async function cacheFirst(request, rule) {
  try {
    const cachedResponse = await getCachedResponse(request, rule);
    if (cachedResponse) {
      return cachedResponse;
    }
    
    const networkResponse = await fetch(request);
    await cacheResponse(request, networkResponse.clone(), rule);
    return networkResponse;
  } catch (error) {
    return handleFetchError(request, error);
  }
}

/**
 * –°—Ç—Ä–∞—Ç–µ–≥–∏—è Network First
 */
async function networkFirst(request, rule) {
  try {
    const networkResponse = await fetch(request);
    await cacheResponse(request, networkResponse.clone(), rule);
    return networkResponse;
  } catch (error) {
    const cachedResponse = await getCachedResponse(request, rule);
    if (cachedResponse) {
      return cachedResponse;
    }
    return handleFetchError(request, error);
  }
}

/**
 * –°—Ç—Ä–∞—Ç–µ–≥–∏—è Stale While Revalidate
 */
async function staleWhileRevalidate(request, rule) {
  const cachedResponse = await getCachedResponse(request, rule);
  
  // –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º –∫–µ—à
  fetch(request).then(networkResponse => {
    if (networkResponse.ok) {
      cacheResponse(request, networkResponse.clone(), rule);
    }
  }).catch(error => {
    console.warn('Background fetch failed:', error);
  });
  
  if (cachedResponse) {
    return cachedResponse;
  }
  
  // –ï—Å–ª–∏ –Ω–µ—Ç –∫–µ—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏, –∂–¥–µ–º —Å–µ—Ç—å
  try {
    const networkResponse = await fetch(request);
    await cacheResponse(request, networkResponse.clone(), rule);
    return networkResponse;
  } catch (error) {
    return handleFetchError(request, error);
  }
}

/**
 * –°—Ç—Ä–∞—Ç–µ–≥–∏—è Cache Only
 */
async function cacheOnly(request) {
  const cachedResponse = await getCachedResponse(request, {});
  if (cachedResponse) {
    return cachedResponse;
  }
  
  return new Response('Not found in cache', { 
    status: 404,
    statusText: 'Not Found'
  });
}

/**
 * –ü–æ–ª—É—á–∞–µ—Ç –æ—Ç–≤–µ—Ç –∏–∑ –∫–µ—à–∞ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Å—Ä–æ–∫–∞ –¥–µ–π—Å—Ç–≤–∏—è
 */
async function getCachedResponse(request, rule) {
  const cache = await caches.open(DYNAMIC_CACHE);
  const cachedResponse = await cache.match(request);
  
  if (!cachedResponse) {
    return null;
  }
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è
  if (rule.maxAge) {
    const dateHeader = cachedResponse.headers.get('date');
    if (dateHeader) {
      const cachedDate = new Date(dateHeader).getTime();
      const now = Date.now();
      
      if (now - cachedDate > rule.maxAge) {
        // –ö–µ—à —É—Å—Ç–∞—Ä–µ–ª
        await cache.delete(request);
        return null;
      }
    }
  }
  
  return cachedResponse;
}

/**
 * –ö–µ—à–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç
 */
async function cacheResponse(request, response, rule) {
  if (!response.ok) {
    return;
  }
  
  try {
    const cache = await caches.open(DYNAMIC_CACHE);
    await cache.put(request, response);
  } catch (error) {
    console.warn('Failed to cache response:', error);
  }
}

/**
 * –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—à–∏–±–∫–∏ fetch
 */
function handleFetchError(request, error) {
  console.error('Fetch error:', error);
  
  // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—Ñ–ª–∞–π–Ω —Å—Ç—Ä–∞–Ω–∏—Ü—É –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–æ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
  if (request.mode === 'navigate') {
    return caches.match('/index.html');
  }
  
  return new Response('Network error', {
    status: 500,
    statusText: 'Network Error'
  });
}

/**
 * –û—á–∏—â–∞–µ—Ç —Å—Ç–∞—Ä—ã–µ –∫–µ—à–∏
 */
async function cleanupOldCaches() {
  const cacheNames = await caches.keys();
  const currentCaches = [CACHE_NAME, STATIC_CACHE, DYNAMIC_CACHE];
  
  const deletePromises = cacheNames
    .filter(cacheName => !currentCaches.includes(cacheName))
    .map(cacheName => caches.delete(cacheName));
  
  await Promise.all(deletePromises);
  console.log(`üßπ Cleaned up ${deletePromises.length} old caches`);
}

/**
 * –ó–∞—è–≤–ª—è–µ—Ç –∫–æ–Ω—Ç—Ä–æ–ª—å –Ω–∞–¥ –≤—Å–µ–º–∏ –∫–ª–∏–µ–Ω—Ç–∞–º–∏
 */
async function claimClients() {
  return self.clients.claim();
}

/**
 * –ü–æ–ª—É—á–∞–µ—Ç —Ä–∞–∑–º–µ—Ä –≤—Å–µ—Ö –∫–µ—à–µ–π
 */
async function getCacheSize() {
  const cacheNames = await caches.keys();
  let totalSize = 0;
  
  for (const cacheName of cacheNames) {
    const cache = await caches.open(cacheName);
    const requests = await cache.keys();
    
    for (const request of requests) {
      const response = await cache.match(request);
      if (response) {
        const responseBlob = await response.blob();
        totalSize += responseBlob.size;
      }
    }
  }
  
  return totalSize;
}

/**
 * –û—á–∏—â–∞–µ—Ç –≤—Å–µ –∫–µ—à–∏
 */
async function clearAllCaches() {
  const cacheNames = await caches.keys();
  const deletePromises = cacheNames.map(cacheName => caches.delete(cacheName));
  await Promise.all(deletePromises);
  console.log('üßπ All caches cleared');
}

/**
 * –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∂–∞–µ—Ç —Ä–µ—Å—É—Ä—Å—ã
 */
async function preloadAssets(assets) {
  const cache = await caches.open(DYNAMIC_CACHE);
  
  const addPromises = assets.map(async (asset) => {
    try {
      await cache.add(asset);
    } catch (error) {
      console.warn(`Failed to preload asset: ${asset}`, error);
    }
  });
  
  await Promise.all(addPromises);
  console.log(`üì¶ Preloaded ${assets.length} assets`);
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ push —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π (–¥–ª—è –±—É–¥—É—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è)
self.addEventListener('push', (event) => {
  if (!event.data) {
    return;
  }
  
  const data = event.data.json();
  const options = {
    body: data.body,
    icon: '/favicon.svg',
    badge: '/favicon.svg',
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: data.primaryKey
    },
    actions: [
      {
        action: 'explore',
        title: 'Open LocalPDF',
        icon: '/favicon.svg'
      },
      {
        action: 'close',
        title: 'Close notification',
        icon: '/favicon.svg'
      }
    ]
  };
  
  event.waitUntil(
    self.registration.showNotification(data.title, options)
  );
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –ø–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—é
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  if (event.action === 'explore') {
    event.waitUntil(
      clients.openWindow('/')
    );
  }
});

console.log('üîß LocalPDF Service Worker loaded');
