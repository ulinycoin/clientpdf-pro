import { PDFDocument } from 'pdf-lib';\nimport { \n  PDFProcessingResult, \n  PDFMetadata, \n  PDFError, \n  PDFErrorCode,\n  MergeOptions,\n  SplitOptions,\n  RotationOptions,\n  WatermarkOptions,\n  ProgressCallback,\n  IPDFService\n} from '../types';\n\nexport class PDFService implements IPDFService {\n  name = 'PDFService';\n  version = '1.0.0';\n  \n  private static instance: PDFService;\n\n  static getInstance(): PDFService {\n    if (!this.instance) {\n      this.instance = new PDFService();\n    }\n    return this.instance;\n  }\n\n  isSupported(): boolean {\n    return typeof PDFDocument !== 'undefined' && \n           typeof File !== 'undefined' && \n           typeof Blob !== 'undefined';\n  }\n\n  /**\n   * Validate if file is a valid PDF\n   */\n  async validateFile(file: File): Promise<boolean> {\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer);\n      return pdfDoc.getPageCount() > 0;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Get PDF metadata\n   */\n  async getMetadata(file: File): Promise<PDFMetadata> {\n    try {\n      const arrayBuffer = await file.arrayBuffer();\n      const pdfDoc = await PDFDocument.load(arrayBuffer);\n      const pageCount = pdfDoc.getPageCount();\n      \n      let dimensions = { width: 0, height: 0 };\n      if (pageCount > 0) {\n        const firstPage = pdfDoc.getPage(0);\n        const size = firstPage.getSize();\n        dimensions = {\n          width: Math.round(size.width),\n          height: Math.round(size.height)\n        };\n      }\n      \n      return {\n        pages: pageCount,\n        originalSize: file.size,\n        dimensions\n      };\n    } catch (error) {\n      throw this.createPDFError(error, 'Failed to get PDF metadata');\n    }\n  }\n\n  /**\n   * Merge multiple PDF files into one\n   */\n  async mergePDFs(\n    files: File[],\n    options: MergeOptions = {},\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult> {\n    const startTime = performance.now();\n    \n    try {\n      if (files.length < 2) {\n        throw new Error('At least 2 files are required for merging');\n      }\n\n      onProgress?.(0, 'Starting merge process...');\n\n      // Create new PDF document\n      const mergedPdf = await PDFDocument.create();\n      let totalOriginalSize = 0;\n      let totalPages = 0;\n\n      // Set metadata if provided\n      if (options.metadata) {\n        if (options.metadata.title) mergedPdf.setTitle(options.metadata.title);\n        if (options.metadata.author) mergedPdf.setAuthor(options.metadata.author);\n        if (options.metadata.subject) mergedPdf.setSubject(options.metadata.subject);\n        if (options.metadata.keywords) mergedPdf.setKeywords([options.metadata.keywords]);\n      }\n\n      // Determine file order\n      const fileOrder = options.order ? \n        options.order.map(index => files[index]).filter(Boolean) : \n        files;\n\n      // Process each file\n      for (let i = 0; i < fileOrder.length; i++) {\n        const file = fileOrder[i];\n        totalOriginalSize += file.size;\n\n        onProgress?.(\n          (i / fileOrder.length) * 80, \n          `Processing ${file.name}...`\n        );\n\n        try {\n          // Load PDF\n          const arrayBuffer = await file.arrayBuffer();\n          const pdf = await PDFDocument.load(arrayBuffer);\n          \n          // Copy all pages\n          const pageIndices = Array.from(\n            { length: pdf.getPageCount() }, \n            (_, i) => i\n          );\n          const copiedPages = await mergedPdf.copyPages(pdf, pageIndices);\n          \n          // Add pages to merged document\n          copiedPages.forEach((page) => {\n            mergedPdf.addPage(page);\n          });\n\n          totalPages += pdf.getPageCount();\n        } catch (error) {\n          console.warn(`Failed to process file ${file.name}:`, error);\n        }\n      }\n\n      onProgress?.(90, 'Saving merged PDF...');\n\n      // Save merged PDF\n      const pdfBytes = await mergedPdf.save();\n      const blob = new Blob([pdfBytes], { type: 'application/pdf' });\n\n      onProgress?.(100, 'Merge completed!');\n\n      const processingTime = performance.now() - startTime;\n\n      return {\n        success: true,\n        data: blob,\n        metadata: {\n          pages: totalPages,\n          originalSize: totalOriginalSize,\n          processedSize: blob.size,\n          processingTime\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: this.createPDFError(error, 'PDF merge failed')\n      };\n    }\n  }\n\n  /**\n   * Split PDF - placeholder implementation\n   */\n  async splitPDF(\n    file: File,\n    options: SplitOptions,\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult[]> {\n    throw new Error('Split functionality not yet implemented');\n  }\n\n  /**\n   * Compress PDF - delegates to compression service\n   */\n  async compressPDF(\n    file: File,\n    options: any,\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult> {\n    throw new Error('Use CompressionService for PDF compression');\n  }\n\n  /**\n   * Rotate PDF pages - placeholder implementation\n   */\n  async rotatePDF(\n    file: File,\n    options: RotationOptions,\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult> {\n    throw new Error('Rotation functionality not yet implemented');\n  }\n\n  /**\n   * Add watermark - placeholder implementation\n   */\n  async addWatermark(\n    file: File,\n    options: WatermarkOptions,\n    onProgress?: ProgressCallback\n  ): Promise<PDFProcessingResult> {\n    throw new Error('Watermark functionality not yet implemented');\n  }\n\n  /**\n   * Create a standardized PDF error\n   */\n  private createPDFError(error: any, context: string = 'PDF processing'): PDFError {\n    let code = PDFErrorCode.PROCESSING_ERROR;\n    let message = 'An error occurred during PDF processing';\n    \n    if (error instanceof Error) {\n      message = error.message;\n      \n      const errorText = message.toLowerCase();\n      \n      if (errorText.includes('invalid') || errorText.includes('corrupt')) {\n        code = PDFErrorCode.CORRUPT_PDF;\n        message = 'The PDF file is corrupted or invalid';\n      } else if (errorText.includes('too large') || errorText.includes('size')) {\n        code = PDFErrorCode.FILE_TOO_LARGE;\n        message = 'The file is too large to process';\n      } else if (errorText.includes('memory')) {\n        code = PDFErrorCode.MEMORY_ERROR;\n        message = 'Not enough memory to process the file';\n      }\n    }\n    \n    return {\n      code,\n      message: `${context}: ${message}`,\n      details: error.stack || error.toString()\n    };\n  }\n}\n\n// Export singleton instance\nexport const pdfService = PDFService.getInstance();"